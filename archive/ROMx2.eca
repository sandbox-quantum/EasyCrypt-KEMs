require import AllCore Distr List FMap PROM.
require (*--*) ROM.

(* Auxiliary properties *) 
lemma size_behead (s : 'a list) : 
  size (behead s) = if s = [] then 0 else size s - 1.
proof. by elim: s. qed.

lemma behead_drop (s : 'a list) (n : int) :
  0 <= n => behead (drop n s) = drop (n + 1) s. 
proof. by elim: s n => // /#. qed. 

lemma uniq_le_mem_size_perm_eq (s1 s2 : 'a list) :
  uniq s1 => mem s1 <= mem s2 => size s2 <= size s1 => perm_eq s1 s2. 
proof.
elim: s1 s2 => [| x l ih s2 /= [ninl uql] lemem le1sz]; 1: smt(size_ge0). 
move: (ih (rem x s2) uql _ _); 1,2: smt(mem_rem_neq size_rem).
rewrite -(perm_cons x) => peqxc.
rewrite (perm_eq_trans _ _ _ peqxc) perm_eq_sym perm_to_rem 1:/#.
qed.

lemma uniq_drop (s : 'a list) (n : int) :
  uniq s => uniq (drop n s). 
proof. by elim: s n => // /#. qed.


(* Types *)
(** Input type of first oracle **) 
type in_t1.

(** Input type of second oracle **)
type in_t2.

(* Output type of oracles *)
type out_t.


(* Distributions *)
(* Distribution over output type *)
op [lossless] dout : out_t distr.


(* Oracles *)
(** 
  Interface of (first type of) random oracle for security notions, 
  exposes both initialization and query
**)
module type RandomOracle1i = {
  proc init() : unit
  proc get(x : in_t1) : out_t
}.

(** 
  Interface of (second type of) random oracle for security notions, 
  exposes both initialization and query
**)
module type RandomOracle2i = {
  proc init() : unit
  proc get(x : in_t2) : out_t
}.

(** 
  Interface of (first type of) random oracle for security notions, 
  exposes both initialization and query
**)
module type RandomOracle1 = {
  include RandomOracle1i [get]
}.

(** 
  Interface of (second type of) random oracle for security notions, 
  exposes both initialization and query
**)
module type RandomOracle2 = {
  include RandomOracle2i [get]
}.


(** Default implementation for first (type of) oracle **)
module RO1_Default : RandomOracle1i = {
  var m : (in_t1, out_t) fmap

  proc init() : unit = {
    m <- empty;
  }

  proc get(x : in_t1) = {
    var r : out_t;

    r <$ dout;
    if (x \notin m) {
      m.[x] <- r;
    }
    
    return oget m.[x];
  }
}.

(** Default implementation of second (type of) oracle **)
module RO2_Default : RandomOracle2i = {
  var m : (in_t2, out_t) fmap

  proc init() : unit = {
    m <- empty;
  }

  proc get(x : in_t2) = {
    var r : out_t;

    r <$ dout;
    if (x \notin m) {
      m.[x] <- r;
    }
    
    return oget m.[x];
  }
}.

(** Counting wrapper for first (type of) oracle **)
module Counting_RO1 (RO1 : RandomOracle1) : RandomOracle1 = {
  var q : int
    
  proc get(x : in_t1) : out_t = {
    var y : out_t;
    
    y <@ RO1.get(x);
    
    q <- q + 1;
        
    return y;
  }
}.

(** Counting wrapper for second (type of) oracle **)
module Counting_RO2 (RO2 : RandomOracle2) : RandomOracle2 = {
  var q : int

  proc get(x : in_t2) : out_t = {
    var y : out_t;
    
    y <@ RO2.get(x);
    
    q <- q + 1;
        
    return y;
  }
}.


(* Properties *)
(* Collision resistance between two random oracles (CR-ROM-x2) *)
(** Adversary class for CR-ROM-x2 **)
module type Adv_CRROMx2 (RO1 : RandomOracle1) (RO2 : RandomOracle2) = { 
  proc find() : in_t1 * in_t2
}.

(** CR-ROM-x2 security game **)
module CR_ROM_x2 (RO1 : RandomOracle1i) (RO2 : RandomOracle2i) (A : Adv_CRROMx2) = {
  proc main() : bool = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y1, y2 : out_t;
    
    RO1.init();
    RO2.init();
        
    (x1, x2) <@ A(RO1, RO2).find();
    
    y1 <@ RO1.get(x1);
    y2 <@ RO2.get(x2);
    
    return y1 = y2; 
  }
}.



section.
(* Declare arbitrary adversary against CR-ROM-x2 *)
declare module A <: Adv_CRROMx2 { -RO1_Default, -RO2_Default, -Counting_RO1, -Counting_RO2 }.

(* By assumption, the adversary's finding procedure terminates (given that its oracles terminate) *)
declare axiom A_find_ll (RO1 <: RandomOracle1{-A}) (RO2 <: RandomOracle2{-A}) :
  islossless RO1.get => islossless RO2.get => islossless A(RO1, RO2).find.

(* 
  By assumption, the number of adversary queries is bounded 
  (by some non-negative constants)

declare op q1 : { int | 0 <= q1 } as ge0_q1.
declare axiom A_find_qs1 (RO1 <: RandomOracle1{-A, -Counting_RO1}) (RO2 <: RandomOracle2{-A, -Counting_RO1}) :
  hoare[A(Counting_RO1(RO1), RO2).find : Counting_RO1.q = 0 ==> Counting_RO1.q <= q1].

declare op q2 : { int | 0 <= q2 } as ge0_q2.
declare axiom A_find_qs2 (RO1 <: RandomOracle1{-A, -Counting_RO2}) (RO2 <: RandomOracle2{-A, -Counting_RO2}) :
  hoare[A(RO1, Counting_RO2(RO2)).find : Counting_RO2.q = 0 ==> Counting_RO2.q <= q2].

declare op q1 : { int | 0 <= q1 } as ge0_q1.
declare axiom A_find_qs1 :
  hoare[A(Counting_RO1(RO1_Default), RO2_Default).find : Counting_RO1.q = 0 ==> Counting_RO1.q <= q1].

declare op q2 : { int | 0 <= q2 } as ge0_q2.
declare axiom A_find_qs2 :
  hoare[A(RO1_Default, Counting_RO2(RO2_Default)).find : Counting_RO2.q = 0 ==> Counting_RO2.q <= q2].
*)

declare op q1 : { int | 0 <= q1 } as ge0_q1.
declare axiom A_find_qs1 :
  hoare[A(RO1_Default, RO2_Default).find : fsize RO1_Default.m = 0 ==> fsize RO1_Default.m <= q1].

declare op q2 : { int | 0 <= q2 } as ge0_q2.
declare axiom A_find_qs2 :
  hoare[A(RO1_Default, RO2_Default).find : fsize RO2_Default.m = 0 ==> fsize RO2_Default.m <= q2].

  
(* 
  Clone and import relevant ROM-related results 
  for first (type of) random oracle
*)
local clone FullRO as FullRO1 with
  type in_t <- in_t1,
  type out_t <- out_t,
  
  op dout <- fun _ => dout,
  
  type d_in_t <- unit,
  type d_out_t <- bool
  
  proof *.

(* 
  Clone and import relevant ROM-related results 
  for second (type of) random oracle
*)  
local clone FullRO as FullRO2 with
  type in_t <- in_t2,
  type out_t <- out_t,
  
  op dout <- fun _ => dout,

  type d_in_t <- unit,
  type d_out_t <- bool
  
  proof *.

(* 
  Clone and import relevant ROM-related results for an
  intermediate (auxiliary) RO in order to perform lazy-eager argument on 
  RO1 (can do similarly on RO2 if desired).
local clone import FullRO as FullROI with
  type in_t <- int,
  type out_t <- out_t,
  
  type d_in_t <- unit,
  type d_out_t <- bool,
  
  op dout <- fun _ => dout
  
  proof *.
*)
local clone import FullRO as FullROI with
  type in_t <- int,
  type out_t <- out_t,
  
  type d_in_t <- unit,
  type d_out_t <- bool,
  
  op dout <- fun _ => dout
  
  proof *.

  
(* 
  Step (1):
  Show equivalence between original game and one where the default 
  random oracles are replaced by their more advanced (lazy) variants from the
  PROM theory (as to be able to utilize the results from PROM later)

local equiv Eqv_CRROMx2_PROM :
  CR_ROM_x2(RO1_Default, RO2_Default, A).main ~ CR_ROM_x2(FullRO1.LRO, FullRO2.LRO, A).main :
    ={glob A} ==> ={res}.
proof. by proc; sim. qed.
*)
local equiv Eqv_CRROMx2_PROM :
  CR_ROM_x2(RO1_Default, RO2_Default, A).main ~ CR_ROM_x2(FullRO1.LRO, FullRO2.LRO, A).main :
    ={glob A} ==> ={res} /\ ={m}(RO1_Default, FullRO1.RO) /\ ={m}(RO2_Default, FullRO2.RO).
proof. by proc; sim. qed.

(* 
  Auxiliary oracle that simulates the first random oracle 
  by employing an intermediate (type of) oracle. This is the key to 
  performing the lazy sampling -> eager sampling step: If ROI is instantiated with  
  the lazy oracle, ROI.sample does nothing and, hence, RO1_WI.init will do nohting
  but initialize i to 0; if ROI is instantiated with the 
  eager oracle, ROI.sample is the same as ROI.get and, hence, RO1_WI.init will 
  already eagerly sample q1 oracle mappings/entries.
  Note that the map and q are assumed to be initialized by the game, in order to
  massage everything into the right form for the results from PROM. 
*)
local module RO1_WI (ROI : FullROI.RO) : FullRO1.RO = {
  include var FullRO1.RO [-init, get] 
  var qu : int

  proc init() : unit = { 
    var i : int;
    
    i <- 0;
    while (i < q1) { 
      ROI.sample(i);
      i <- i + 1;
    }
  }

  proc get(x : in_t1) : out_t = {
    var y : out_t;

    if (x \notin FullRO1.RO.m) {
      y <@ ROI.get(qu);
      FullRO1.RO.m.[x] <- y;
      qu <- qu + 1;
    } else {
      y <- oget FullRO1.RO.m.[x];
    }

    return y;
  }
}.


local lemma test (ROI <: FullROI.RO{-RO1_WI}) (RO2 <: FullRO2.RO{-RO1_WI}): 
  hoare[A(RO1_WI(ROI), RO2).find : 
          RO1_WI.qu = 0 /\ FullRO1.RO.m = empty ==> RO1_WI.qu <= fsize FullRO1.RO.m]. 
proof.
proc (RO1_WI.qu <= fsize FullRO1.RO.m).
smt(fsize_empty). smt(fsize_empty).
proc (RO1_WI.qu <= fsize FullRO1.RO.m) => //.
proc; auto.
if.
wp.
call (: true).
skip => />; smt(fsize_set).
by wp.
qed.


local lemma test2 :
  equiv[A(RO1_Default, RO2_Default).find ~ A(FullRO1.LRO, FullRO2.LRO).find :
          ={glob A} /\ ={m}(RO1_Default, FullRO1.RO) /\ ={m}(RO2_Default, FullRO2.RO) 
        ==>
          ={m}(RO1_Default, FullRO1.RO) /\ ={m}(RO2_Default, FullRO2.RO)]. 
proof.
proc (={m}(RO1_Default, FullRO1.RO) /\ ={m}(RO2_Default, FullRO2.RO)) => //.
by sim.
by sim.
qed.


(* 
  Auxiliary intermediate variant of CR-ROM-x2 that
  uses the above auxiliary oracle (RO1_W) instead of RO1.
  This acts as the distinguisher between the lazy and eager
  oracles (of the intermediate type).
  Uses a separate procedure to have the correct form
  for the results from PROM.    

local module CR_ROM_x2_I (ROI : FullROI.RO) = {
  proc distinguish() = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y1, y2 : out_t;
    
    RO1_WI(ROI).init();
    
    (x1, x2) <@ A(RO1_WI(ROI), FullRO2.LRO).find();
    
    if (x1 \notin FullRO1.RO.m) {
      y1 <$ dout;
    } else {
      y1 <- oget FullRO1.RO.m.[x1];
    }
    
    if (x2 \notin FullRO2.RO.m) {
      y2 <$ dout;
    } else {
      y2 <- oget FullRO2.RO.m.[x2];
    }
    
    return y1 = y2;  
  }
  
  proc main() = {
    var b : bool;
    
    ROI.init();
    FullRO1.RO.m <- empty;
    RO1_WI.qu <- 0;
    FullRO2.RO.m <- empty;
    
    b <@ distinguish();
    
    return b;
  }  
}.
*)
local module CR_ROM_x2_I (ROI : FullROI.RO) = {  
  var x1 : in_t1
  var x2 : in_t2
  
  proc distinguish() = {    
    
    RO1_WI(ROI).init();
    
    (x1, x2) <@ A(RO1_WI(ROI), FullRO2.LRO).find();
    
    return RO1_WI.qu <= fsize FullRO1.RO.m;
  }
  
  proc main() = {
    var y1, y2 : out_t;
    
    x1 <- witness;
    x2 <- witness;
    ROI.init();
    FullRO1.RO.m <- empty;
    RO1_WI.qu <- 0;
    FullRO2.RO.m <- empty;
    
    distinguish();

    if (x1 \notin FullRO1.RO.m) {
      y1 <$ dout;
    } else {
      y1 <- oget FullRO1.RO.m.[x1];
    }
    
    if (x2 \notin FullRO2.RO.m) {
      y2 <$ dout;
    } else {
      y2 <- oget FullRO2.RO.m.[x2];
    }

    return y1 = y2;
  }  
}.

local equiv Eqv_CRROMx2_Dist_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).distinguish ~ CR_ROM_x2_I(FullROI.RO).distinguish :
    ={glob CR_ROM_x2_I, FullROI.RO.m} ==> ={res, glob CR_ROM_x2_I, RO1_WI.qu}.   
proof.
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D CR_ROM_x2_I _) => //.
by move => ?; apply dout_ll.
qed.

local equiv Eqv_CRROMx2_Main_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).main ~ CR_ROM_x2_I(FullROI.RO).main :
    ={glob A} ==> ={res, FullRO1.RO.m, FullRO2.RO.m}.
proof.
proc.
seq 4 4 : ( ={glob CR_ROM_x2_I, FullROI.RO.m}); 1: by inline *; auto. 
by rewrite equiv[{1} 1 Eqv_CRROMx2_Dist_LRO_RO]; sim.
qed.

(*
  Step (2):
  Show equivalence between original CR-ROM-x2 (with the first and second 
  type of lazy oracles from PROM) 
  and the above auxiliary intermediate CR-ROM-x2 using the intermediate type 
  of lazy oracle from PROM.   
local equiv Eqv_CRROMx2RO_ILRO :
  CR_ROM_x2(FullRO1.LRO, FullRO2.LRO, A).main ~ CR_ROM_x2_I(FullROI.LRO).main :
    ={glob A} ==> ={res}.
proof.
proc.
inline{2} distinguish.
seq 2 5 : (   ={glob A} 
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{2} = empty
           /\ RO1_WI.qu{2} = 0).
+ inline *.
  while{2} (true) (q1 - i{2}).
  + by auto => /> /#. 
  by auto => />; smt(ge0_q1). 
inline get.   
seq 1 1 : (   ={x1, x2, FullRO1.RO.m, FullRO2.RO.m}
           /\ RO1_WI.qu{2} \notin RO.m{2}).
+ call (:   ={FullRO1.RO.m, FullRO2.RO.m} 
         /\ dom RO.m{2} = mem (range 0 RO1_WI.qu{2}) 
         /\ 0 <= RO1_WI.qu{2}).
  + proc.
    by wp; rnd.
  + proc.
    inline{2} get.
    case (x{1} \notin FullRO1.RO.m{1}).
    + rcondt{1} ^if; 1: by auto.
      rcondt{2} ^if; 1: by auto.
      rcondt{2} ^if; 1: move => &m. 
      + rnd; wp; skip => /> &m'. 
        by rewrite fun_ext => /(_ RO1_WI.qu{m'}); rewrite mem_range => -> /#.
      by wp; rnd; wp; skip => /> &m; smt(get_set_sameE mem_range mem_set). 
    rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by rnd{1}; wp.
  by skip => />; smt(mem_empty mem_range). 
sp 1 0.
case (x{1} \notin FullRO1.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  case (x2{1} \notin FullRO2.RO.m{1}).
  + rcondt{1} ^if; 1: by auto.
    rcondt{2} ^if; 1: by auto.
    by auto => />; smt(get_set_sameE).  
  + rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by wp; rnd{1}; wp; rnd; skip => />; smt(get_set_sameE).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
case (x2{1} \notin FullRO2.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  auto => />; smt(get_set_sameE).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
by wp; rnd{1}; wp; rnd{1}; skip.
qed.
*)
local equiv Eqv_CRROMx2RO_ILRO :
  CR_ROM_x2(FullRO1.LRO, FullRO2.LRO, A).main ~ CR_ROM_x2_I(FullROI.LRO).main :
        ={glob A} 
    ==> 
           ={res} 
        /\ fsize FullRO1.RO.m{2} <= fsize FullRO1.RO.m{1}
        /\ fsize FullRO2.RO.m{2} <= fsize FullRO2.RO.m{1}.
proof.
proc.
inline{2} distinguish.
seq 2 5 : (   ={glob A} 
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{2} = empty
           /\ RO1_WI.qu{2} = 0).
+ inline *.
  while{2} (true) (q1 - i{2}).
  + by auto => /> /#. 
  by auto => />; smt(ge0_q1). 
inline get.   
seq 1 2 : (   ={x1, x2, FullRO1.RO.m, FullRO2.RO.m}
           (*/\ x1{1} = CR_ROM_x2_I.x1{2}
            /\ x2{1} = CR_ROM_x2_I.x2{2}*)
           /\ RO1_WI.qu{2} \notin RO.m{2}).
+ wp. 
  call (:   ={FullRO1.RO.m, FullRO2.RO.m} 
         /\ dom RO.m{2} = mem (range 0 RO1_WI.qu{2}) 
         /\ 0 <= RO1_WI.qu{2}).
  + proc.
    by wp; rnd.
  + proc.
    inline{2} get.
    case (x{1} \notin FullRO1.RO.m{1}).
    + rcondt{1} ^if; 1: by auto.
      rcondt{2} ^if; 1: by auto.
      rcondt{2} ^if; 1: move => &m. 
      + rnd; wp; skip => /> &m'. 
        by rewrite fun_ext => /(_ RO1_WI.qu{m'}); rewrite mem_range => -> /#.
      by wp; rnd; wp; skip => /> &m; smt(get_set_sameE mem_range mem_set). 
    rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by rnd{1}; wp.
  by skip => />; smt(mem_empty mem_range). 
sp 1 0.
case (x{1} \notin FullRO1.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  case (x2{1} \notin FullRO2.RO.m{1}).
  + rcondt{1} ^if; 1: by auto.
    rcondt{2} ^if; 1: by auto.    
    by auto => />; smt(get_set_sameE fsize_set).  
  + rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by wp; rnd{1}; wp; rnd; skip => />; smt(get_set_sameE fsize_set).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
case (x2{1} \notin FullRO2.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  auto => />; smt(get_set_sameE fsize_set).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
by wp; rnd{1}; wp; rnd{1}; skip.
qed.

(*
local equiv Eqv_CRROMx2RO_ILRO :
  CR_ROM_x2(FullRO1.LRO, FullRO2.LRO, A).main ~ CR_ROM_x2_I(FullROI.LRO).main :
    ={glob A} ==> ={res, glob FullRO1.RO, glob FullRO2.RO}.
proof.
proc.
inline{2} distinguish.
seq 2 5 : (   ={glob A} 
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{2} = empty
           /\ RO1_WI.qu{2} = 0).
+ inline *.
  while{2} (true) (q1 - i{2}).
  + by auto => /> /#. 
  by auto => />; smt(ge0_q1). 
inline get.   
seq 1 1 : (   ={x1, x2, FullRO1.RO.m, FullRO2.RO.m}
           /\ RO1_WI.qu{2} \notin RO.m{2}).
+ call (:   ={FullRO1.RO.m, FullRO2.RO.m} 
         /\ dom RO.m{2} = mem (range 0 RO1_WI.qu{2}) 
         /\ 0 <= RO1_WI.qu{2}).
  + proc.
    by wp; rnd.
  + proc.
    inline{2} get.
    case (x{1} \notin FullRO1.RO.m{1}).
    + rcondt{1} ^if; 1: by auto.
      rcondt{2} ^if; 1: by auto.
      rcondt{2} ^if; 1: move => &m. 
      + rnd; wp; skip => /> &m'. 
        by rewrite fun_ext => /(_ RO1_WI.qu{m'}); rewrite mem_range => -> /#.
      by wp; rnd; wp; skip => /> &m; smt(get_set_sameE mem_range mem_set). 
    rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by rnd{1}; wp.
  by skip => />; smt(mem_empty mem_range). 
sp 1 0.
case (x{1} \notin FullRO1.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  case (x2{1} \notin FullRO2.RO.m{1}).
  + rcondt{1} ^if; 1: by auto.
    rcondt{2} ^if; 1: by auto.
    auto => />. .; smt(get_set_sameE).  
  + rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by wp; rnd{1}; wp; rnd; skip => />; smt(get_set_sameE).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
case (x2{1} \notin FullRO2.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  auto => />; smt(get_set_sameE).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
by wp; rnd{1}; wp; rnd{1}; skip.
qed.
*)

(* 
  Step (3):
  Apply the results from PROM to show move from lazy sampling to eagerly sampling
  (up to q1 queries) for the first (type of) random oracle.

local equiv Eqv_CRROMx2_Dist_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).distinguish ~ CR_ROM_x2_I(FullROI.RO).distinguish :
    ={glob CR_ROM_x2_I, FullROI.RO.m} ==> ={res, glob CR_ROM_x2_I}.   
proof.
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D CR_ROM_x2_I _) => //.
by move => ?; apply dout_ll.
qed.

local equiv Eqv_CRROMx2_Main_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).main ~ CR_ROM_x2_I(FullROI.RO).main :
    ={glob A} ==> ={res}.
proof.
proc.
seq 4 4 : ( ={glob CR_ROM_x2_I, FullROI.RO.m}); 1: by inline *; auto. 
by rewrite equiv[{1} 1 Eqv_CRROMx2_Dist_LRO_RO]; sim.
qed.
*)

local equiv Eqv_CRROMx2_Dist_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).distinguish ~ CR_ROM_x2_I(FullROI.RO).distinguish :
    ={glob CR_ROM_x2_I, FullROI.RO.m} ==> ={res, glob CR_ROM_x2_I}.   
proof.
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D CR_ROM_x2_I _) => //.
by move => ?; apply dout_ll.
qed.

local equiv Eqv_CRROMx2_Main_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).main ~ CR_ROM_x2_I(FullROI.RO).main :
    ={glob A} ==> ={res, FullRO1.RO.m, FullRO2.RO.m}.
proof.
proc.
seq 4 4 : ( ={glob CR_ROM_x2_I, FullROI.RO.m}); 1: by inline *; auto. 
by rewrite equiv[{1} 1 Eqv_CRROMx2_Dist_LRO_RO]; sim.
qed.

local module As (ROI : FullROI.RO) = { 
  proc distinguish = A(RO1_WI(ROI), FullRO2.LRO).find
}. 

local equiv Eqv_Adv_PROM :
  A(RO1_Default, RO2_Default).find ~ A(FullRO1.LRO, FullRO2.LRO).find :
    ={glob A} /\ ={m}(RO1_Default, FullRO1.RO) /\ ={m}(RO2_Default, FullRO2.RO)
    ==> 
    ={res} /\ ={m}(RO1_Default, FullRO1.RO) /\ ={m}(RO2_Default, FullRO2.RO).
proof. 
by proc (={m}(RO1_Default, FullRO1.RO) /\ ={m}(RO2_Default, FullRO2.RO)) => //; sim. 
qed.


local equiv Eqv_Adv_PRO2M :
  A(FullRO1.LRO, FullRO2.LRO).find ~ As(FullROI.LRO).distinguish :
       ={glob A, FullRO1.RO.m, FullRO2.RO.m} 
    /\ FullROI.RO.m{2} = empty
    /\ RO1_WI.qu{2} = 0
    ==> 
    ={res, FullRO1.RO.m, FullRO2.RO.m} /\ 0 <= RO1_WI.qu{2} <= fsize FullRO1.RO.m{2}.
proof.
proc (   ={FullRO1.RO.m, FullRO2.RO.m} 
      /\ dom FullROI.RO.m{2} = mem (range 0 RO1_WI.qu{2})
      /\ 0 <= RO1_WI.qu{2} <= fsize FullRO1.RO.m{2}) => //. 
smt(mem_empty mem_range domE ge0_fsize).
proc; auto.
proc.
case (x{1} \notin FullRO1.RO.m{1}). 
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  inline get.
  rcondt{2} ^if; 1: by auto; smt(mem_range domE).
  auto. progress. 
  smt(@FMap). 
  smt(@FMap).   
  smt(mem_set mem_range).  smt(mem_set mem_range).
  smt(mem_set mem_range fsize_set).
+ rcondf{1} ^if; 1: by auto.
  rcondf{2} ^if; 1: by auto.
  inline get.
  auto.
qed.

print FullROI.FullEager.RO_LRO.
local equiv Eqv_Adv_Dist_LRO_RO :
  As(FullROI.LRO).distinguish ~ As(FullROI.RO).distinguish :
    ={glob As, glob RO1_WI, FullROI.RO.m} ==> ={res, glob As, glob RO1_WI}.   
proof.
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D As _) => //.
by move => ?; apply dout_ll.
qed.


local hoare Eqv_Adv_Dist_LRO_ROT :
  As(FullROI.LRO).distinguish : 
    RO1_WI.qu = 0 ==> RO1_WI.qu <= q1.
proof.
have eqv_qqu :
  equiv[ A(RO1_WI(RO), FullRO2.LRO).find ~ A(Counting_RO1(RO1_WI(RO)), FullRO2.LRO).find : 
          ={glob A, glob RO, glob RO1_WI, glob FullRO2.LRO} /\ RO1_WI.qu{2} <= Counting_RO1.q{2} 
            ==> 
          ={res, RO1_WI.qu} /\ RO1_WI.qu{2} <= Counting_RO1.q{2}]. 
+ proc (={glob RO, glob RO1_WI, glob FullRO2.LRO} /\ RO1_WI.qu{2} <= Counting_RO1.q{2}) => //.  
  + by proc; auto. 
  proc; inline get.
  sp 0 1.
  by if => //; auto => /> /#. 
conseq eqv_qqu (: Counting_RO1.q = 0 ==> Counting_RO1.q <
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D As _) => //.
by move => ?; apply dout_ll.
qed.


local lemma A_find_qs1_RO1WI :
  hoare[A(RO1_WI(RO), FullRO2.LRO).find : 
                 FullRO1.RO.m = empty
              /\ dom FullROI.RO.m = mem (range 0 q1)
              /\ RO1_WI.qu = 0 
          ==> 
                 RO1_WI.qu <= q1].
proof.

local equiv Eqv_Adv_Dist_LRO_RO :
  As(FullROI.LRO).distinguish ~ As(FullROI.RO).distinguish :
    ={glob As, FullROI.RO.m} ==> ={res, glob As, glob RO1_WI}.   
proof.
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D As _) => //.
by move => ?; apply dout_ll.
qed.



(* 
  Auxiliary first oracle that directly eagerly samples
  q1 oracle mappings/entries. Effectively an inlined
  version of RO1_WI(FullROI.RO).
*)
local module RO1_Eager : RandomOracle1i = {
  import var FullRO1.RO
  var mi : (int, out_t) fmap

  proc init() = {
    var y : out_t;

    m <- empty;

    mi <- empty;
    while (fsize mi < q1) {
      y <$ dout;
      mi.[fsize mi] <- y;
    }
  }

  proc get(x : in_t1) = {
    var y : out_t;

    if (x \notin m) {
      if (fsize m < q1) {
        m.[x] <- oget mi.[fsize m];
      }  
      y <- oget m.[x];
    } else {
      y <- oget m.[x];
    }

    return y;
  }     
}.  

(*
  Auxiliary version of CR-ROM-x2 that employs the above 
  eagerly sampling first oracle (i.e., RO1_Eager). Splits up
  execution in separate procedures, as well as moves some local variables
  to the module level, to massage it into the right form for using the FEL   
*)
local module CR_ROM_x2_Eager1 = {
  var x1 : in_t1
  var x2 : in_t2
  
  proc advcr() : unit = {        
    RO1_Eager.init();
    FullRO2.RO.init();
    
    (x1, x2) <@ A(RO1_Eager, FullRO2.LRO).find();
  }
   
  proc main() = {
    var y1, y2 : out_t;
    
    advcr();
    
    if (x1 \notin FullRO1.RO.m) {
      y1 <$ dout;
    } else {
      y1 <- oget FullRO1.RO.m.[x1];
    }
    
    if (x2 \notin FullRO2.RO.m) {
      y2 <$ dout;
    } else {
      y2 <- oget FullRO2.RO.m.[x2];
    }
    
    return y1 = y2;
  }
}.


(*
  Step (3.5):
  Translate the assumption regarding the adversary's (first) oracle 
  queries to a concrete statement usable in the current stage 
  of the proof.

local lemma A_find_qs1_RO1WI :
  hoare[A(RO1_WI(RO), FullRO2.LRO).find : RO1_WI.qu = 0 ==> RO1_WI.qu <= q1].
proof.
have eqv_qqu :
  equiv[ A(RO1_WI(RO), FullRO2.LRO).find ~ A(Counting_RO1(RO1_WI(RO)), FullRO2.LRO).find : 
          ={glob A, glob RO, glob RO1_WI, glob FullRO2.LRO} /\ RO1_WI.qu{2} <= Counting_RO1.q{2} 
            ==> 
          ={res, RO1_WI.qu} /\ RO1_WI.qu{2} <= Counting_RO1.q{2}]. 
+ proc (={glob RO, glob RO1_WI, glob FullRO2.LRO} /\ RO1_WI.qu{2} <= Counting_RO1.q{2}) => //.  
  + by proc; auto. 
  proc; inline get.
  sp 0 1.
  by if => //; auto => /> /#. 
conseq eqv_qqu (: Counting_RO1.q = 0 ==> Counting_RO1.q <= q1); 1,2: by smt(). 
by apply (A_find_qs1 (RO1_WI(RO)) (FullRO2.LRO)).
qed.
*)

local lemma A_find_qs1_RO1WI :
  hoare[A(RO1_WI(RO), FullRO2.LRO).find : 
                 FullRO1.RO.m = empty
              /\ dom FullROI.RO.m = mem (range 0 q1)
              /\ RO1_WI.qu = 0 
          ==> 
                 RO1_WI.qu <= q1].
proof.
have eqv_qqu :
  equiv[ A(RO1_WI(RO), FullRO2.LRO).find ~ A(RO1_Default, RO2_Default).find : 
               ={glob A}
            /\ FullRO1.RO.m{1} = RO1_Default.m{2}
            /\ FullRO2.RO.m{1} = RO2_Default.m{2}
            /\ FullRO1.RO.m{1} = empty
            /\ dom FullROI.RO.m{1} = mem (range 0 q1)
            /\ RO1_WI.qu{1} = 0 
        ==> 
            fsize RO1_Default.m{2} <= q1
            /\ 
            (fsize RO1_Default.m{2} <= q1 =>
               ={res} 
            /\ RO1_WI.qu{1} <= fsize RO1_Default.m{2}) ]. 
+ conseq (: 
               ={glob A}
            /\ FullRO1.RO.m{1} = RO1_Default.m{2}
            /\ FullRO2.RO.m{1} = RO2_Default.m{2}
            /\ FullRO1.RO.m{1} = empty
            /\ dom FullROI.RO.m{1} = mem (range 0 q1)
            /\ RO1_WI.qu{1} = 0 
  ==>
  (fsize RO1_Default.m{2} <= q1 =>
               ={res} 
            /\ RO1_WI.qu{1} <= fsize RO1_Default.m{2})  ) _ A_find_qs1 => //.
            progress. smt(fsize_empty).
  proc (q1 < fsize RO1_Default.m)
       (   FullRO1.RO.m{1} = RO1_Default.m{2}
        /\ FullRO2.RO.m{1} = RO2_Default.m{2}
        /\ dom FullROI.RO.m{1} = mem (range 0 q1)
        /\ 0 <= RO1_WI.qu{1} <= fsize RO1_Default.m{2}) => //. 
   progress.  smt(fsize_empty).
   progress;  smt(fsize_empty).
   move => O1 O2 O2ll O1ll; apply (A_find_ll O1 O2 O1ll O2ll).
  + by proc; auto. 
  move=> &2 lt1. 
  proc; auto. smt(dout_ll).
  move=> _. 
  proc.
  auto. smt(dout_ll).
  proc. 
  case (x{1} \notin FullRO1.RO.m{1}).
  rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  inline get.
  
  case (RO1_WI.qu{1} = q1).
  wp -1 -1.
  conseq (: _ ==> true).   
  progress; smt(@FMap @List mem_range domE ge0_q1). 
  
  by auto.  
  
  rcondf{1} ^if. auto.   progress; smt(@FMap @List mem_range domE ge0_q1). 
  auto => />; progress. 
    smt(@FMap @List mem_range domE ge0_q1). 

  
  move: H0.
  rewrite fun_ext => /(_ RO1_WI.qu{hr}) ->.
  rewrite mem_range.
  
  


  wp; rnd; wp; skip => />.
  progress.
  smt(get_set_sameE).
  smt(get_set_sameE).
  smt(get_set_sameE fsize_set).
  smt(get_set_sameE).
      
  rcondt{1}
  
conseq eqv_qqu (: fsize RO1_Default.m = 0 ==> fsize RO1_Default.m <= q1); 1,2: smt(fsize_empty). 
by apply (A_find_qs1).
qed.

(* 
  Step (4):
  Show equivalence between (1) auxiliary CR-ROM-x2 using RO1_WI(RO) as first oracle
  and (2) auxiliary CR-ROM-x2 using RO1_Eager as first oracle
*)
local equiv Eqv_CRROMx2IRO_Eager1 :
  CR_ROM_x2_I(FullROI.RO).main ~ CR_ROM_x2_Eager1.main :
    ={glob A} ==> ={res}.
proof.
proc.
inline{1} init distinguish.
inline{2} advcr init.
seq 6 4 : (   ={glob A}
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{1} = RO1_Eager.mi{2}
           /\ dom FullROI.RO.m{1} = mem (range 0 q1)
           /\ RO1_WI.qu{1} = 0).
+ swap{2} 4 -1. 
  while (   FullROI.RO.m{1} = RO1_Eager.mi{2}
         /\ dom FullROI.RO.m{1} = mem (range 0 i{1})
         /\ i{1} = fsize FullROI.RO.m{1}
         /\ i{1} <= q1).
  + inline{1} sample get. 
    sp; rcondt{1} ^if; first by auto => />; smt(mem_range).
    by wp; rnd; skip => /> &2; smt(ge0_q1 mem_set mem_range fsize_set ge0_fsize).  
  by wp; skip => />; smt(ge0_q1 fsize_empty mem_empty mem_range).
wp.
seq 1 1 : (   ={FullRO2.RO.m, FullRO1.RO.m} 
           /\ x1{1} = CR_ROM_x2_Eager1.x1{2}
           /\ x2{1} = CR_ROM_x2_Eager1.x2{2}); 2: by sim.
call (:   ={glob A} 
       /\ FullRO1.RO.m{1} = empty 
       /\ FullRO1.RO.m{2} = empty
       /\ FullRO2.RO.m{1} = empty
       /\ FullRO2.RO.m{2} = empty
       /\ RO.m{1} = RO1_Eager.mi{2}
       /\ dom RO.m{1} = mem (range 0 q1)
       /\ RO1_WI.qu{1} = 0
         ==>           
          RO1_WI.qu{1} <= q1 
       /\ (RO1_WI.qu{1} <= q1 =>  
            ={FullRO1.RO.m, FullRO2.RO.m, res})).
+ conseq (: RO1_WI.qu{1} <= q1 => ={FullRO1.RO.m, FullRO2.RO.m, res})
         A_find_qs1_RO1WI _ => //. 
  symmetry.
  proc (q1 < RO1_WI.qu) 
       (   ={FullRO1.RO.m, FullRO2.RO.m} 
        /\ fsize FullRO1.RO.m{1} = RO1_WI.qu{2}
        /\ RO.m{2} = RO1_Eager.mi{1} 
        /\ dom RO.m{2} = mem (range 0 q1)) => //; 1,2: smt(fsize_empty).  
  + by move => RO1 RO2 RO1ll RO2ll; apply (A_find_ll RO1 RO2 RO2ll RO1ll). 
  + by proc; auto. 
  + by move=> &2 lt_qu; proc; auto; smt(dout_ll).
  + by move=> _; proc; auto; smt(dout_ll).
  + proc; inline get.
    if => //; 2: by wp; skip.
    by wp; rnd{2}; wp; skip => />; smt(get_setE mem_range fsize_set ge0_fsize).
  + move=> &2 ltqu_q1.
    by proc; wp. 
  move => _. 
  proc. inline get.
  if => //; 2: by wp.
  by wp; rnd; wp; skip => />; smt(dout_ll).
by skip => />.
qed.

(*
  Step (5):
  Show the bound on a relevant collision occuring by queries of the adversary
  (i.e., the final potential samplings after the adversary has returned are not
  taken into account here).
*)
local lemma Bnd_CRROMx2Eager1_AdvCR &m :
  Pr[CR_ROM_x2_Eager1.advcr() @ &m : 
         fsize FullRO2.RO.m <= q2
      /\ CR_ROM_x2_Eager1.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1.x2]]
  <=
  (q1 * q2)%r * p_max dout.
proof.  
fel 2
    (fsize FullRO2.RO.m)
    (fun _ => q1%r * p_max dout)
    q2
    (exists (x1 : int) (x2 : in_t2), 
           x1 \in RO1_Eager.mi 
        /\ x2 \in FullRO2.RO.m 
        /\ RO1_Eager.mi.[x1] = FullRO2.RO.m.[x2])
    [ RO1_Eager.get : false; FullRO2.LRO.get : (arg \notin FullRO2.RO.m) ]
    (   dom RO1_Eager.mi = mem (range 0 q1) 
     /\ rng FullRO1.RO.m <= rng RO1_Eager.mi
     /\ fsize RO1_Eager.mi = q1) => //. 
+ by rewrite StdBigop.Bigreal.BRA.sumri_const 1:ge0_q2 RField.intmulr /#.
+ move => &m0 [#] leq2_fsz x1in x2in coll [#] eqdm lerng eqq1_fsz.
  split; 2: smt().
  by move: lerng => /(_ (oget FullRO1.RO.m{m0}.[CR_ROM_x2_Eager1.x1{m0}]) _) /#. 
+ inline init.
  wp; sp.
  while (   dom RO1_Eager.mi = mem (range 0 (fsize RO1_Eager.mi))
         /\ fsize RO1_Eager.mi <= q1).
  + by wp; rnd; skip => /> &m0 eqdm _ ltq1_fsz y0 _; smt(mem_set mem_range ge0_fsize fsize_set).
  by skip => />; smt(ge0_q1 mem_empty mem_range fsize_empty emptyE).
+ move => b c /=.
  proc.
  by wp; skip => /> &2; smt(rng_set domE rem_id mem_range ge0_fsize). 
+ proc.
  rcondt ^if; 1: by rnd.
  wp; rnd; skip => /> &m0 ge0_fsz ltq_fsz nex eqdm lerng eqq1_fsz x0nin.
  apply (StdOrder.RealOrder.ler_trans 
          (mu dout (fun y => exists (i : int), 
             dom RO1_Eager.mi{m0} i /\ RO1_Eager.mi{m0}.[i] = Some y))).
  + by apply mu_sub => k -[x1 x2] []; smt(get_setE).
  rewrite -eqq1_fsz Mu_mem.mu_mem_le_fsize => u ? /= -@/pred1. 
  by apply (StdOrder.RealOrder.ler_trans (mu1 dout (oget RO1_Eager.mi{m0}.[u]))); smt(mu_sub pmax_upper_bound).
+ move => c. 
  proc.
  by wp; rnd; skip => />; smt(fsize_set).
move => b c /=.
proc.
rcondf ^if; 1: by auto.
by rnd.
qed.

(*
  Step (5.5):
  Translate the assumption regarding the adversary's (second) oracle 
  queries to a concrete statement usable in the current stage 
  of the proof.
*)
local lemma A_find_qs2_RO1Eager :
  hoare[A(RO1_Eager, FullRO2.LRO).find : fsize FullRO2.RO.m = 0 ==> fsize FullRO2.RO.m <= q2].
proof.
have eqv_fszq :
  equiv[ A(RO1_Eager, FullRO2.LRO).find ~ A(RO1_Eager, Counting_RO2(FullRO2.LRO)).find : 
          ={glob A, glob RO1_Eager, glob FullRO2.LRO} /\ fsize FullRO2.RO.m{2} <= Counting_RO2.q{2} 
            ==> 
          ={res, glob FullRO2.RO} /\ fsize FullRO2.RO.m{2} <= Counting_RO2.q{2} ]. 
+ proc (={glob RO1_Eager, glob FullRO2.LRO} /\ fsize FullRO2.RO.m{2} <= Counting_RO2.q{2}) => //.  
  + proc; inline get. 
    by auto => />; smt(fsize_set).
  by proc; wp.
conseq eqv_fszq (: Counting_RO2.q = 0 ==> Counting_RO2.q <= q2); 1,2: by smt(). 
by apply (A_find_qs2 (RO1_Eager) (FullRO2.LRO)).
qed. 


(* 
  Step (6) (Final):
  Show bound on CR-ROM-x2 by combining previously obtained results.
*)
(**
  Bounds success probability of any adversary playing in CR-ROM-x2
  by `(q1 * q2 + 1) * p_max dout`. Here, q1 and q2 are the number of
  queries to the first and second random oracle, respecively, and 
  `p_max dout` is the maximum probability assigned to a single 
  value by distribution `dout` (indeed, if dout is the usual uniform 
  distribution, this is simply 1 / |out_t|).
**)   
lemma Bnd_CRROMx2 &m :
  Pr[CR_ROM_x2(RO1_Default, RO2_Default, A).main() @ &m : res] 
  <=
  (q1 * q2 + 1)%r * p_max dout.
proof.
have ->: 
  Pr[CR_ROM_x2(RO1_Default, RO2_Default, A).main() @ &m : res]
  =
  Pr[CR_ROM_x2_Eager1.main() @ &m : res].
+ byequiv (: ={glob A} ==> _) => //.
  transitivity CR_ROM_x2(FullRO1.LRO, FullRO2.LRO, A).main
               (={glob A} ==> ={res})
               (={glob A} ==> ={res}) => //; 1: smt().
  + by apply Eqv_CRROMx2_PROM.  
  transitivity CR_ROM_x2_I(LRO).main
               (={glob A} ==> ={res})
               (={glob A} ==> ={res}) => //; 1: smt().
  + by apply Eqv_CRROMx2RO_ILRO.
  transitivity CR_ROM_x2_I(RO).main
               (={glob A} ==> ={res})
               (={glob A} ==> ={res}) => //; 1: smt().
  + by apply Eqv_CRROMx2_Main_LRO_RO.
  by apply Eqv_CRROMx2IRO_Eager1. 
rewrite fromintD RField.mulrDl /=.
byphoare => //.
proc.
seq 1 : (    CR_ROM_x2_Eager1.x1 \in FullRO1.RO.m 
          /\ CR_ROM_x2_Eager1.x2 \in FullRO2.RO.m 
          /\ FullRO1.RO.m.[CR_ROM_x2_Eager1.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1.x2]) 
        ((q1 * q2)%r * p_max dout) 
        1%r 
        1%r 
        (p_max dout) => //.
+ call (:     true 
          ==>
             (CR_ROM_x2_Eager1.x1 \in FullRO1.RO.m) 
          /\ (CR_ROM_x2_Eager1.x2 \in FullRO2.RO.m) 
          /\ FullRO1.RO.m.[CR_ROM_x2_Eager1.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1.x2]) => //.
  bypr => &m0 _.  
  have ->:
    Pr[CR_ROM_x2_Eager1.advcr() @ &m0 : 
          (CR_ROM_x2_Eager1.x1 \in FullRO1.RO.m) 
       /\ (CR_ROM_x2_Eager1.x2 \in FullRO2.RO.m) 
       /\ FullRO1.RO.m.[CR_ROM_x2_Eager1.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1.x2]]
    =
    Pr[CR_ROM_x2_Eager1.advcr() @ &m0 : 
          fsize FullRO2.RO.m <= q2
       /\ (CR_ROM_x2_Eager1.x1 \in FullRO1.RO.m) 
       /\ (CR_ROM_x2_Eager1.x2 \in FullRO2.RO.m) 
       /\ FullRO1.RO.m.[CR_ROM_x2_Eager1.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1.x2]].
  + byequiv (:     ={glob A} 
               ==> 
                   ={CR_ROM_x2_Eager1.x1, CR_ROM_x2_Eager1.x2, FullRO1.RO.m, FullRO2.RO.m} 
                /\ fsize FullRO2.RO.m{2} <= q2) => //.
    proc.    
    call (:      ={glob A, glob RO1_Eager, glob FullRO2.RO} 
              /\ FullRO2.RO.m{2} = empty
            ==>
                 ={res, glob RO1_Eager, glob FullRO2.RO}
              /\ fsize FullRO2.RO.m{2} <= q2).
    + conseq (:     ={glob A, glob RO1_Eager, glob FullRO2.RO} 
                ==> 
                    ={res, glob RO1_Eager, glob FullRO2.RO}) 
             _ 
             A_find_qs2_RO1Eager => //; 1: smt(fsize_empty).
      + by proc (={glob RO1_Eager, glob FullRO2.RO}) => //; proc; auto.
    inline init.    
    wp; while (={RO1_Eager.mi}); 1: by auto.
    by wp; skip.
  by apply (Bnd_CRROMx2Eager1_AdvCR &m0).  
if => //; swap 1 1; if => //; swap 1 1. 
+ by rnd; rnd; skip => />; smt(mu_eq pmax_upper_bound).
+ wp; rnd; skip => /> &2 ncoll x1nin x2in. 
  by rewrite (mu_eq _ _ (pred1 (oget FullRO2.RO.m{2}.[CR_ROM_x2_Eager1.x2{2}]))); smt(pmax_upper_bound).
+ rnd; wp; skip => /> &2 ncoll x1in x2nin. 
  by rewrite (mu_eq _ _ (pred1 (oget FullRO1.RO.m{2}.[CR_ROM_x2_Eager1.x1{2}]))); smt(pmax_upper_bound).
wp; conseq (: _ ==> false); 1: smt().
by hoare; 1: smt(pmax_ge0).
qed.

end section.


(* 
  One output, Two functions version (of CR-ROM-x2):
  Adversary asked to provide single output x such that 
  RO1(x) collides with RO2(f a x) for some fixed, known f and a 
*) 
abstract theory OT.
(*
  Here, we assume that the input type to the first oracle, in_t1,
  is finite. Surely, this seems like a reasonable assumption. 
  
  This significantly simplifies the proof (or at least makes it more
  natural) while not losing much genericity. (Surely, the finiteness of the
  number of possible input elements seems like a reasonable assumption.)
*)
require import FinType.
clone import FinType as FinIn1 with 
  type t <= in_t1.
  
(* Additional auxiliary input to function mapping between random oracle inputs *)
type aux_t.

(* Type of output provided by adversary, mapped to inputs of random oracles  *)
type s_t.

(* Function mapping abetween random oracle inputs *)
op f : aux_t -> s_t -> in_t1. 
op g : aux_t -> s_t -> in_t2.


(* Security *)
(* Collision resistance between two random oracles (CR-ROM-x2), OT version *)
(** Adversary class for CR-ROM-x2-OT **)
module type Adv_CRROMx2_OT (RO1 : RandomOracle1) (RO2 : RandomOracle2) = {
  proc find(a : aux_t) : s_t
}.

(** CR-ROM-x2-OT game **)
module CR_ROM_x2_OT (RO1 : RandomOracle1i) (RO2 : RandomOracle2i) (A : Adv_CRROMx2_OT) = {
  proc main(a : aux_t) : bool = {
    var x : s_t;
    var y1, y2 : out_t;
    
    RO1.init();
    RO2.init();
        
    x <@ A(RO1, RO2).find(a);
    
    y1 <@ RO1.get(f a x);
    y2 <@ RO2.get(g a x);
    
    return y1 = y2; 
  }
}.


section.
(* 
  By assumption, one of the functions f/g is injective w.r.t its 
  final input (i.e., fixing the auxiliary information, the function is 
  injective for any input of in_t1/in_t2). 
  Wlog, take g to be injective.
*)
declare axiom inj_g (a : aux_t) : injective (g a).


(* Declare arbitrary adversary against CR-ROM-x2-OT *)
declare module A <: Adv_CRROMx2_OT { -RO1_Default, -RO2_Default, -Counting_RO1, -Counting_RO2 }.

(* By assumption, the adversary's finding procedure terminates (given that its oracles terminate) *)
declare axiom A_find_ll (RO1 <: RandomOracle1{-A}) (RO2 <: RandomOracle2{-A}) :
  islossless RO1.get => islossless RO2.get => islossless A(RO1, RO2).find.

(* 
  By assumption, the number of adversary queries (to the second oracle) is bounded 
  (by some non-negative constant)
*)
declare op q2 : { int | 0 <= q2 } as ge0_q2.
declare axiom A_find_qs2 (RO1 <: RandomOracle1{-A, -Counting_RO2}) (RO2 <: RandomOracle2{-A, -Counting_RO2}) :
  hoare[A(RO1, Counting_RO2(RO2)).find : Counting_RO2.q = 0 ==> Counting_RO2.q <= q2].


(* 
  Clone and import relevant ROM-related results 
  for first (type of) random oracle
*)
local clone FullRO as FullRO1 with
  type in_t <- in_t1,
  type out_t <- out_t,
  
  op dout <- fun _ => dout,
  
  type d_in_t <- aux_t,
  type d_out_t <- bool
  
  proof *.

local clone FullRO1.FinEager as FinEagerRO1 with
  theory FinFrom <- FinIn1.

(* 
  Clone and import relevant ROM-related results 
  for second (type of) random oracle
*)  
local clone FullRO as FullRO2 with
  type in_t <- in_t2,
  type out_t <- out_t,
  
  op dout <- fun _ => dout,

  type d_in_t <- unit,
  type d_out_t <- bool
  
  proof *.

(* 
  Auxiliary intermediate variant of CR-ROM-x2-OT that
  acts as the distinguisher between the lazy and eager
  oracles (of the first type).
  Uses a separate procedure to have the correct form
  for the results from PROM.    
*)
local module CR_ROM_x2_OT_I (RO1 : FullRO1.RO) = {
  proc distinguish(a) = {
    var x : s_t;
    var y1 : out_t;
    var y2 : out_t;
    
    x <@ A(RO1, FullRO2.LRO).find(a);
    y1 <@ RO1.get(f a x);
    y2 <@ FullRO2.LRO.get(g a x);
    
    return y1 = y2;
  }
   
  proc main(a : aux_t) = {        
    var b : bool;
    
    RO1.init();
    FullRO2.LRO.init();
    
    b <@ distinguish(a);
    
    return b;
  }  
}.


(* 
  Step (1):
  Show equivalence between original game and the above auxiliary intermediate
  variant (essentially replacing the default random oracles by their more advanced 
  (lazy) variants from the PROM theory).
*)
local equiv Eqv_CRROMx2OT_I :
  CR_ROM_x2_OT(RO1_Default, RO2_Default, A).main ~ CR_ROM_x2_OT_I(FullRO1.LRO).main :
    ={glob A, arg} ==> ={res}.
proof. by proc; inline distinguish; wp; sim. qed. 


(*
  Step (2):
  Apply the results from PROM to show move from lazy sampling to eagerly sampling
  (entirely) for the first (type of) random oracle.
*)
local equiv Eqv_CRROMx2OTI_Dist_LRO_FinRO : 
   FullRO1.MainD(CR_ROM_x2_OT_I, FullRO1.LRO).distinguish ~ FullRO1.MainD(CR_ROM_x2_OT_I, FinEagerRO1.FinRO).distinguish : 
     ={glob CR_ROM_x2_OT_I, arg} ==> ={res}. 
proof.
transitivity FullRO1.MainD(CR_ROM_x2_OT_I, FullRO1.RO).distinguish
             (={glob CR_ROM_x2_OT_I, arg} ==> ={res, glob CR_ROM_x2_OT_I})
             (={glob CR_ROM_x2_OT_I, arg} ==> ={res, glob CR_ROM_x2_OT_I}) => [ /# | // | |].
+ symmetry; conseq (FullRO1.FullEager.RO_LRO CR_ROM_x2_OT_I _) => //.
  by move => ?; rewrite dout_ll. 
apply (FinEagerRO1.RO_FinRO_D _ CR_ROM_x2_OT_I) => //.
by move => ?; rewrite dout_ll. 
qed.

local equiv Eqv_CRROMx2OTI_Main_LRO_FinRO :
   CR_ROM_x2_OT_I(FullRO1.LRO).main ~ CR_ROM_x2_OT_I(FinEagerRO1.FinRO).main :
     ={glob A, arg} ==> ={res}. 
proof.
proc. 
swap{1} 1 1; swap{2} 1 1.
seq 1 1 : (={glob CR_ROM_x2_OT_I, a}); 1: by inline; wp. 
transitivity{1} { b <@ FullRO1.MainD(CR_ROM_x2_OT_I, FullRO1.LRO).distinguish(a); } 
                (={glob CR_ROM_x2_OT_I, a} ==> ={b})
                (={glob CR_ROM_x2_OT_I, a} ==> ={b}) => [/# | // | |].
+ by inline distinguish; sim.
rewrite equiv [{1} 1 Eqv_CRROMx2OTI_Dist_LRO_FinRO].
by inline distinguish; sim.
qed.


(*
  Auxiliary version of CR-ROM-x2-OT that employs the fully 
  eagerly sampled first oracle (i.e., FinEagerRO1.FinRO). Splits up
  execution in separate procedures, as well as moves some local variables
  to the module level, to massage it into the right form for using the FEL   
*)
local module CR_ROM_x2_OT_Eager1 = {
  var x : s_t
  
  proc advcr(a : aux_t) = {
    FinEagerRO1.FinRO.init();
    FullRO2.LRO.init();

    x <@ A(FinEagerRO1.FinRO, FullRO2.LRO).find(a);
  }
   
  proc main(a : aux_t) = {
    var y1 : out_t;
    var y2 : out_t;
    
    advcr(a);
    
    y1 <- oget FullRO1.RO.m.[f a x];
    
    if (g a x \notin FullRO2.RO.m) {
      y2 <$ dout;
    } else {
      y2 <- oget FullRO2.RO.m.[g a x];
    }
    
    return y1 = y2;
  }
}.


(* 
  Step (3):
  Show equivalence between (1) auxiliary CR-ROM-x2-OT-I given
  a fully eagerly first oracle and (2) CR-ROM-x2-OT-Eager1
*)
local equiv Eqv_CRROMx2OTI_Eager1 :
  CR_ROM_x2_OT_I(FinEagerRO1.FinRO).main ~ CR_ROM_x2_OT_Eager1.main :
     ={glob A, arg} ==> ={res}. 
proof.
proc.
inline advcr distinguish get.
seq 4 4 : (   ={FullRO1.RO.m, FullRO2.RO.m, a, a0} 
           /\ a{1} = a0{1} 
           /\ x{1} = CR_ROM_x2_OT_Eager1.x{2}). 
+ call (: ={FullRO1.RO.m, FullRO2.RO.m}); 1,2: by sim. 
  inline init sample get; wp.
  by while (={FullRO1.RO.m, l}); auto. 
case (g a{1} x{1} \notin FullRO2.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  wp; rnd; wp; skip => />; smt(get_set_sameE). 
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
by wp; rnd{1}; wp; skip.
qed.


(*
  Step (4):
  Show the bound on a relevant collision occuring by queries of the adversary
  (i.e., the final potential samplings after the adversary has returned are not
  taken into account here).
*)
local lemma Bnd_CRROMx2Eager1V_CR_RS &m (a : aux_t) :
  Pr[CR_ROM_x2_OT_Eager1.advcr(a) @ &m : 
         fsize FullRO2.RO.m <= q2
      /\ g a CR_ROM_x2_OT_Eager1.x \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[f a CR_ROM_x2_OT_Eager1.x] = FullRO2.RO.m.[g a CR_ROM_x2_OT_Eager1.x]]
  <=
  q2%r * p_max dout.
proof.
fel 2
    (fsize FullRO2.RO.m)
    (fun _ => p_max dout)
    q2
    (exists (x : s_t),
           g a x \in FullRO2.RO.m
        /\ FullRO1.RO.m.[f a x] = FullRO2.RO.m.[g a x])
    [ FinEagerRO1.FinRO.get : false; FullRO2.LRO.get : (arg \notin FullRO2.RO.m) ] 
    (dom FullRO1.RO.m = mem enum) => //.
+ by rewrite StdBigop.Bigreal.BRA.sumri_const 1:ge0_q2 RField.intmulr /#.
+ move => &m0 [#] leq2_fsz gaxin coll eqdm.
  split; 2: smt().
  by exists CR_ROM_x2_OT_Eager1.x{m0}.
+ inline init sample get.
  wp.
  while (   (forall x, ! (x \in l) <=> x \in FullRO1.RO.m)   
         /\ l = drop (card - size l) enum).
  + auto => /> &m0 mdef eql nemptyl r0 r0in.
    split => [hlnin | hlin]. 
    + split => [x1 |]; 2: smt(behead_drop).
      move: (mdef x1); rewrite -{1}(head_behead _ (witness) nemptyl) /= negb_or mem_set => <-. 
      by split => [/# | [// |]]; smt(uniq_drop enum_uniq).
    split => [x1 |]; 2: smt(behead_drop).
    move: (mdef x1); rewrite -{1}(head_behead _ (witness) nemptyl)/= negb_or => <-. 
    by split; smt(uniq_drop enum_uniq). 
  wp; skip => />.
  by split; smt(mem_empty fsize_empty enumP).
+ proc.
  rcondt ^if; 1: by rnd. 
  wp; rnd; skip => /> &m0 _ ltq2 nexis eqdm. 
  case (! (exists x1, g a x1 = x{m0})) => [nex | [x1 eqgax]].
  + rewrite (mu_eq dout _ pred0) 2:mu0 2:pmax_ge0 => y //. 
    rewrite /pred0 neqF negb_exists => x' /=. 
    by rewrite negb_and mem_set negb_or get_setE (: g a x' <> x{m0}) /#.
  rewrite -eqgax (mu_eq dout _ (pred1 (oget FullRO1.RO.m{m0}.[f a x1]))); 2: smt(pmax_upper_bound).
  move => y /=; rewrite eq_iff; split; 1: smt(get_setE inj_g).
  move => @/pred1 ->; exists x1. 
  rewrite mem_set get_set_sameE -some_oget 2://.
  move: eqdm; rewrite -domE fun_ext => /(_ (f a x1)). 
  by rewrite enumP => ->.
+ move => c.
  proc. 
  by wp; rnd; skip => />; smt(fsize_set).
move=> b c.
proc.  
by wp; rnd; skip => />; smt(fsize_set).
qed.


(*
  Step (4.5):
  Translate the assumption regarding the adversary's (second) oracle 
  queries to a concrete statement usable in the current stage 
  of the proof.
*)
local lemma A_find_qs2_RO1Eager :
  hoare[A(FinEagerRO1.FinRO, FullRO2.LRO).find : fsize FullRO2.RO.m = 0 ==> fsize FullRO2.RO.m <= q2].
proof.
have eqv_fszq :
  equiv[ A(FinEagerRO1.FinRO, FullRO2.LRO).find ~ A(FinEagerRO1.FinRO, Counting_RO2(FullRO2.LRO)).find : 
          ={glob A, glob FinEagerRO1.FinRO, glob FullRO2.LRO, arg} /\ fsize FullRO2.RO.m{2} <= Counting_RO2.q{2} 
            ==> 
          ={res, glob FullRO2.RO} /\ fsize FullRO2.RO.m{2} <= Counting_RO2.q{2} ]. 
+ proc (={glob FinEagerRO1.FinRO, glob FullRO2.LRO} /\ fsize FullRO2.RO.m{2} <= Counting_RO2.q{2}) => //.
  + proc; inline get. 
    by auto => />; smt(fsize_set).
  by proc; wp.
conseq eqv_fszq (: Counting_RO2.q = 0 ==> Counting_RO2.q <= q2); 1,2: by smt(). 
by apply (A_find_qs2 (FinEagerRO1.FinRO) (FullRO2.LRO)).
qed. 


(* 
  Step (5) (Final):
  Show bound on CR-ROM-x2-OT by combining previously obtained results.
*)
(**
  Bounds success probability of any adversary playing in CR-ROM-x2-OT
  by `(q2 + 1) * p_max dout`. Here, q2 is the number of
  queries to the first and second random oracle, respecively, and 
  `p_max dout` is the maximum probability assigned to a single 
  value by distribution `dout` (indeed, if dout is the usual uniform 
  distribution, this is simply 1 / |out_t|).
**)
lemma Bnd_CRROMx2_OT &m (a' : aux_t) :
  Pr[CR_ROM_x2_OT(RO1_Default, RO2_Default, A).main(a') @ &m : res] 
  <=
  (q2 + 1)%r * p_max dout.
proof.
have ->: 
  Pr[CR_ROM_x2_OT(RO1_Default, RO2_Default, A).main(a') @ &m : res]
  =
  Pr[CR_ROM_x2_OT_Eager1.main(a') @ &m : res].
+ byequiv (: ={glob A, arg} ==> _) => //.
  transitivity CR_ROM_x2_OT_I(FullRO1.LRO).main
               (={glob A, arg} ==> ={res})
               (={glob A, arg} ==> ={res}) => //; 1: smt().
  + by apply Eqv_CRROMx2OT_I.
  transitivity CR_ROM_x2_OT_I(FinEagerRO1.FinRO).main
               (={glob A, arg} ==> ={res})
               (={glob A, arg} ==> ={res}) => //; 1: smt().
  + by apply Eqv_CRROMx2OTI_Main_LRO_FinRO.
  by apply Eqv_CRROMx2OTI_Eager1.
rewrite fromintD RField.mulrDl /=.
byphoare (: arg = a' ==> _) => //.
proc.
seq 1 : (   g a CR_ROM_x2_OT_Eager1.x \in FullRO2.RO.m 
         /\ FullRO1.RO.m.[f a CR_ROM_x2_OT_Eager1.x] = FullRO2.RO.m.[g a CR_ROM_x2_OT_Eager1.x])
        (q2%r * p_max dout) 
        1%r 
        1%r 
        (p_max dout) 
        (forall x, x \in FullRO1.RO.m /\ a = a') => //.
+ inline advcr init sample get.        
  call (: true) => //. 
  wp.
  while (   (forall x, ! (x \in l) <=> x \in FullRO1.RO.m)   
         /\ l = drop (card - size l) enum).
  + auto => /> &m0 mdef eql nemptyl r0 r0in.
    split => [hlnin | hlin]. 
    + split => [x1 |]; 2: smt(behead_drop).
      move: (mdef x1); rewrite -{1}(head_behead _ (witness) nemptyl) /= negb_or mem_set => <-. 
      by split => [/# | [// |]]; smt(uniq_drop enum_uniq).
    split => [x1 |]; 2: smt(behead_drop).
    move: (mdef x1); rewrite -{1}(head_behead _ (witness) nemptyl)/= negb_or => <-. 
    by split; smt(uniq_drop enum_uniq). 
  wp; skip => />.
  by split; smt(mem_empty fsize_empty enumP).
+ call (:     arg = a'
          ==>
            g a' CR_ROM_x2_OT_Eager1.x \in FullRO2.RO.m 
         /\ FullRO1.RO.m.[f a' CR_ROM_x2_OT_Eager1.x] = FullRO2.RO.m.[g a' CR_ROM_x2_OT_Eager1.x]) => //.
  bypr => &m0 ->.
  have ->:
    Pr[CR_ROM_x2_OT_Eager1.advcr(a') @ &m0 :
          g a' CR_ROM_x2_OT_Eager1.x \in FullRO2.RO.m 
       /\ FullRO1.RO.m.[f a' CR_ROM_x2_OT_Eager1.x] = FullRO2.RO.m.[g a' CR_ROM_x2_OT_Eager1.x]]
    = 
    Pr[CR_ROM_x2_OT_Eager1.advcr(a') @ &m0 :
          fsize FullRO2.RO.m <= q2 
       /\ g a' CR_ROM_x2_OT_Eager1.x \in FullRO2.RO.m 
       /\ FullRO1.RO.m.[f a' CR_ROM_x2_OT_Eager1.x] = FullRO2.RO.m.[g a' CR_ROM_x2_OT_Eager1.x]].
  + byequiv=> //.
    proc.
    call (:     ={glob A, glob FullRO1.RO, glob FullRO2.RO, arg} /\ FullRO2.RO.m{2} = empty
            ==>
                fsize FullRO2.RO.m{2} <= q2 /\ ={res, glob FullRO1.RO, glob FullRO2.RO}).
    + conseq (: ={glob A, glob FullRO1.RO, glob FullRO2.RO, arg} ==> ={res, glob FullRO1.RO, glob FullRO2.RO}) 
             _ 
             A_find_qs2_RO1Eager => //; 1: smt(fsize_empty). 
      by proc (={glob FullRO1.RO, glob FullRO2.RO}) => //; proc; auto. 
    inline init sample get. 
    by wp; while (={l, FullRO1.RO.m}); auto. 
  by apply (Bnd_CRROMx2Eager1V_CR_RS &m0).  
sp 1; if => //. 
+ rnd; skip => /> &m0 axin nand ganin. 
  rewrite (mu_eq _ _ (pred1 (oget FullRO1.RO.m{m0}.[f a' CR_ROM_x2_OT_Eager1.x{m0}]))); smt(pmax_upper_bound).
wp; conseq (: _ ==> false); 1: smt(). 
by hoare; 1: smt(pmax_ge0).
qed.

end section.

end OT.

(* 
  One output, One function version (of CR-ROM-x2):
  Adversary asked to provide single output x such that 
  RO1(f a x) collides with RO2(x) for some fixed, known g and a.
  Note that this is a special case of the OT version where we take 
  f to be the identity function (which is injective).   
*) 
abstract theory OO.
(*
  Again, we assume that the input type to the first oracle, in_t1,
  is finite.
*)
require import FinType.
clone import FinType as FinIn1 with 
  type t <= in_t1.

(* Additional auxiliary input to function mapping between random oracle inputs *)
type aux_t.

(* Function mapping between random oracle inputs*)
op f : aux_t -> in_t2 -> in_t1. 


(* Security *)
(* Collision resistance between two random oracles (CR-ROM-x2), OO version *)
(** Adversary class for CR-ROM-x2-OO **)
module type Adv_CRROMx2_OO (RO1 : RandomOracle1) (RO2 : RandomOracle2) = { 
  proc find(a : aux_t) : in_t2
}.

(** CR-ROM-x2-OO security game **)
module CR_ROM_x2_OO (RO1 : RandomOracle1i) (RO2 : RandomOracle2i) (A : Adv_CRROMx2_OO) = {
  proc main(a : aux_t) : bool = {
    var x : in_t2;
    var y1, y2 : out_t;
    
    RO1.init();
    RO2.init();
        
    x <@ A(RO1, RO2).find(a);
    
    y1 <@ RO1.get(f a x);
    y2 <@ RO2.get(x);
    
    return y1 = y2; 
  }
}.



section.
(* Clone and import results from OT theory *) 
local clone import OT with 
  theory FinIn1 <- FinIn1,
  
  type aux_t <- aux_t,
  type s_t <- in_t2,
    op f <- f,
    op g <- fun (a : aux_t) (x : in_t2) => x 
    
  proof *.

(* Declare arbitrary adversary against CR-ROM-x2-OO *)
declare module A <: Adv_CRROMx2_OO { -RO1_Default, -RO2_Default, -Counting_RO1, -Counting_RO2 }.

(* By assumption, the adversary's finding procedure terminates (given that its oracles terminate) *)
declare axiom A_find_ll (RO1 <: RandomOracle1{-A}) (RO2 <: RandomOracle2{-A}) :
  islossless RO1.get => islossless RO2.get => islossless A(RO1, RO2).find.

(* 
  By assumption, the number of adversary queries (to the second oracle) is bounded 
  (by some non-negative constant)
*)
declare op q2 : { int | 0 <= q2 } as ge0_q2.
declare axiom A_find_qs2 (RO1 <: RandomOracle1{-A, -Counting_RO2}) (RO2 <: RandomOracle2{-A, -Counting_RO2}) :
  hoare[A(RO1, Counting_RO2(RO2)).find : Counting_RO2.q = 0 ==> Counting_RO2.q <= q2].

(* 
  Step (First and final):
  Show bound on CR-ROM-x2-OO by reusing result from OT variant.
*)
(**
  Bounds success probability of any adversary playing in CR-ROM-x2-OO
  by `(q2 + 1) * p_max dout`. Here, q2 is the number of
  queries to the first and second random oracle, respecively, and 
  `p_max dout` is the maximum probability assigned to a single 
  value by distribution `dout` (indeed, if dout is the usual uniform 
  distribution, this is simply 1 / |out_t|).
**)
lemma Bnd_CRROMx2_OO &m (a' : aux_t) :
  Pr[CR_ROM_x2_OO(RO1_Default, RO2_Default, A).main(a') @ &m : res] 
  <=
  (q2 + 1)%r * p_max dout.
proof.
have ->:
  Pr[CR_ROM_x2_OO(RO1_Default, RO2_Default, A).main(a') @ &m : res]
  =
  Pr[CR_ROM_x2_OT(RO1_Default, RO2_Default, A).main(a') @ &m : res]. 
+ by byequiv=> //; sim. 
by apply (Bnd_CRROMx2_OT _ A  A_find_ll q2 ge0_q2 A_find_qs2 &m a') => /#. 
qed.

end section.

end OO.
