(*^
  This library generically defines Key Encapsulation Mechanisms (KEMs)
  and their properties (both correctness and security).
  For convenience, it also provides some sensible defaults, particularly for oracles.
  Most of the content is based on relevant literature.
  More precisely, (almost) all of the content is extracted from 
  one or more of the following papers (in no particular order):
  - [Design and Analysis of Practical Public-Key Encryption Schemes Secure against Adaptive Chosen Ciphertext Attack](https://eprint.iacr.org/2001/108)
  - [On the Equivalence of Several Security Notions of Key Encapsulation Mechanism](https://eprint.iacr.org/2006/268)
  - [KEM/DEM: Necessary and Sufficient Conditions for Secure Hybrid Encryption](https://eprint.iacr.org/2006/265)
  - [Anonymous, Robust Post-Quantum Public Key Encryption](https://eprint.iacr.org/2021/708)
  - [Keeping Up with the KEMs: Stronger Security Notions for KEMs and Automated Analysis of KEM-based Protocols](https://eprint.iacr.org/2023/1933)
  - [Unbindable Kemmy Schmidt: ML-KEM is neither MAL-BIND-K-CT nor MAL-BIND-K-PK](https://eprint.iacr.org/2024/523)
  - [On the Complete Non-Malleability of the Fujisaki-Okamoto Transform](https://eprint.iacr.org/2022/1654)
    (TODO: Add complete non-malleability)
^*)

(* Require/Import libraries *)
require import AllCore List DBool.


(* Types *)
(** Public keys (asymmetric) **)
type pk_t.

(** Secret keys (asymmetric) **)
type sk_t.

(** Shared/session keys (symmetric) **)
type key_t.

(** Ciphertexts/Encapsulations **)
type ctxt_t.


(* Schemes *)
(** KEM (interface) **)
module type Scheme = {
  proc keygen() : pk_t * sk_t
  proc encaps(pk : pk_t) : key_t * ctxt_t
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option 
}.


(* Correctness*)
(** Correctness program/game **)
module Correctness (S : Scheme) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k : key_t;
    var c : ctxt_t;
    var k' : key_t option;
    
    (pk, sk) <@ S.keygen();
    (k, c) <@ S.encaps(pk);
    k' <@ S.decaps(sk, c);
    
    return k' = Some k;
  }
}.


(* Security *)
(* Attacker capabilities/models *)
(* 
  Chosen-Plaintext Attacks (CPA).
  The adversary is given the considered public key and, hence, 
  is able to produce encapsulations, i.e., (symmetric) key/ciphertext pairs. 
  (Typically, this means the adversary can construct ciphertexts
   corresponding to chosen (symmetric) keys.)
*)

(* 
  non-adaptive Chosen-Ciphertext Attacks (CCA1)
  The adversary is given the considered public key and access to a decryption oracle
  *before* the stage in which it is expected to distinguish/return a break.
  Hence, the adversary is able to produce encapsulations
  *and* query for decryptions of chosen ciphertexts.
*)
(* Oracles *)
(** Interface for oracles employed in CCA1 security games **)
module type Oracles_CCA1i = {
  proc init(sk_init : sk_t) : unit
  proc decaps(c : ctxt_t) : key_t option
}.

(** 
  A default implementation for the oracles employed in CCA1 security games 
  (as well as the first stage of CCA2 games).
**)
module O_CCA1_Default (S : Scheme) : Oracles_CCA1i = {
  var sk : sk_t
  var qs : (ctxt_t * key_t option) list
  
  proc init(sk_init : sk_t) = {
    sk <- sk_init;
    qs <- [];
  }
  
  proc decaps(c : ctxt_t) : key_t option = {
    var k : key_t option;
    
    k <@ S.decaps(sk, c);
    
    qs <- rcons qs (c, k);
    
    return k;
  }
}.

(** 
  A duplication of the default implementation for the oracles employed in CCA1 security games 
  (as well as the first stage of CCA2 games). May be useful for security notions considering two
  such (sets of) oracles.
**)
module O_CCA1_DDefault (S : Scheme) : Oracles_CCA1i = {
  var sk : sk_t
  var qs : (ctxt_t * key_t option) list
  
  proc init(sk_init : sk_t) = {
    sk <- sk_init;
    qs <- [];
  }
  
  proc decaps(c : ctxt_t) : key_t option = {
    var k : key_t option;
    
    k <@ S.decaps(sk, c);
    
    qs <- rcons qs (c, k);
    
    return k;
  }
}.


(* 
  adaptive Chosen-Ciphertext Attacks (Traditional: CCA2, Modern : CCA)
  The adversary is given the considered public key and access to a decryption oracle throughout.  
  Hence, the adversary is able to produce encapsulations
  *and* query for decryptions of chosen ciphertexts (potentially barring ciphertexts
  that are part of the challenge).
  Traditionally, this was analogous to CCA2 security for PKE schemes, meaning there were
  two adversary stages: one before receiving the challenge (given a public key and access to a 
  non-restricted decapsulation oracle), and one after receiving the challenge (given access to a
  restricted decapsulation oracle, i.e., one that prohibited querying the challenge).
  Over time, the formalization shifted toward only considering the second adversary stage 
  (provding the public key(s) to this stage as well).
  Here, we denote the traditional one by CCA2 (as we do for PKE schemes), and the modern one by CCA.
*)
(** Interface for oracles employed in CCA2 (CCA) security games **)
module type Oracles_CCA2i = {
  proc init(sk_init : sk_t, c'_init : ctxt_t) : unit
  proc decaps(c : ctxt_t) : key_t option
}.

(** A default implementation for the oracles employed in (the second stage of) CCA2 (CCA) security games **)
module O_CCA2_Default (S : Scheme) : Oracles_CCA2i = {
  var sk : sk_t
  var c' : ctxt_t 
  var qs : (ctxt_t * key_t option) list
  
  proc init(sk_init : sk_t, c'_init : ctxt_t) = {
    sk <- sk_init;
    c' <- c'_init;
    qs <- [];
  }
  
  proc decaps(c : ctxt_t) : key_t option = {
    var k : key_t option;
    
    if (c <> c') {
      k <@ S.decaps(sk, c);
    } else {
      k <- None;
    }
    
    qs <- rcons qs (c, k);
        
    return k;
  }
}.

(** 
  A duplication of the default implementation for the oracles employed in 
  (the second stage of) CCA2 (CCA) security games. May be useful for security notions 
  considering two such (sets of) oracles.
**)
module O_CCA2_DDefault (S : Scheme) : Oracles_CCA2i = {
  var sk : sk_t
  var c' : ctxt_t 
  var qs : (ctxt_t * key_t option) list
  
  proc init(sk_init : sk_t, c'_init : ctxt_t) = {
    sk <- sk_init;
    c' <- c'_init;
    qs <- [];
  }
  
  proc decaps(c : ctxt_t) : key_t option = {
    var k : key_t option;
    
    if (c <> c') {
      k <@ S.decaps(sk, c);
    } else {
      k <- None;
    }
    
    qs <- rcons qs (c, k);
        
    return k;
  }
}.


(**
  Interface for oracles given to the adversary in any CCA security games 
  (i.e., CCA1, traditional CCA2, and modern CCA2) 
**)
module type Oracles_CCA = {
  include Oracles_CCA2i [-init]
}.


(* 
  One-Wayness (OW).
  The adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(*
  One-Wayness under Chosen-Plaintext Attacks (OW-CPA).
  In a CPA setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CPA **)
module type Adv_OWCPA = {
  proc find(pk : pk_t, c : ctxt_t) : key_t 
}.

(** OW-CPA security game **)
module OW_CPA (S : Scheme, A : Adv_OWCPA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    
    k' <@ A.find(pk, c);
    
    return k' = k; 
  }
}.


(*
  One-Wayness under non-adaptive Chosen-Ciphertext Attacks (OW-CCA1).
  In a CCA1 setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CCA1 **)
module type Adv_OWCCA1 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit { O.decaps } 
  proc find(c : ctxt_t) : key_t { }
}.

(** OW-CCA1 security game **)
module OW_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_OWCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    
    k' <@ A(O).find(c);
    
    return k' = k; 
  }
}.


(*
  One-Wayness under (traditional) adaptive Chosen-Ciphertext Attacks (OW-CCA2).
  In a (traditional) CCA2 setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CCA2 **)
module type Adv_OWCCA2 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit
  proc find(c : ctxt_t) : key_t
}.

(** OW-CCA2 security game **)
module OW_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_OWCCA2) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    O2.init(sk, c);
    
    k' <@ A(O2).find(c);
    
    return k' = k; 
  }
}.


(*
  One-Wayness under (modern) adaptive Chosen-Ciphertext Attacks (OW-CCA).
  In a (modern) CCA2 setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CCA (i.e., modern OW-CCA2) **)
module type Adv_OWCCA (O : Oracles_CCA) = { 
  proc find(pk : pk_t, c : ctxt_t) : key_t
}.

(** OW-CCA (i.e., modern OW-CCA2) security game **)
module OW_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_OWCCA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    O.init(sk, c);
    
    k' <@ A(O).find(pk, c);
    
    return k' = k; 
  }
}.


(**
  (ciphertext) INDistinguishability (IND). 
  The adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random.
**)
abstract theory IND.
(* Distributions *)
(** (Sub-)Distribution over (symmetric) keys (may depend on public key) **)
(** 
  Dependence on public key may be used to, e.g., model cases where the key space
  depends on the public key (like in the case of RSA). Instead of having the actual type
  change depending on the public key (which, at the time of writing, is not possible in EC).
**)
op dkeym : pk_t -> key_t distr.


(*
  (ciphertext) INDistinguishability under Chosen-Plaintext Attacks (IND-CPA).
  In a CPA setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkeym).
*)
(** Adversary class considered for IND-CPA **)
module type Adv_INDCPA = { 
  proc distinguish(pk : pk_t, k : key_t, c : ctxt_t) : bool 
}.

(** IND-CPA security game (sampled bit) **)
module IND_CPA (S : Scheme, A : Adv_INDCPA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    b <$ {0,1};
    
    b' <@ A.distinguish(pk, if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CPA security game (provided bit) **)
module IND_CPA_P (S : Scheme, A : Adv_INDCPA) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    b' <@ A.distinguish(pk, if b then k' else k, c);
    
    return b'; 
  }
}.


(*
  (ciphertext) INDistinguishability under non-adaptive Chosen-Ciphertext Attacks (IND-CCA1).
  In a CCA1 setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkeym).
*)
(** Adversary class considered for IND-CCA1 **)
module type Adv_INDCCA1 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit { O.decaps } 
  proc distinguish(k : key_t, c : ctxt_t) : bool { }
}.

(** IND-CCA1 security game (sampled bit) **)
module IND_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_INDCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    b <$ {0,1};
    
    b' <@ A(O).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CCA1 security game (provided bit) **)
module IND_CCA1_P (S : Scheme, O : Oracles_CCA1i, A : Adv_INDCCA1) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    b' <@ A(O).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.


(*
  (ciphertext) INDistinguishability under (traditional) adaptive Chosen-Ciphertext Attacks (IND-CCA2).
  In a (traditional) CCA2 setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkeym).
*)
(** Adversary class considered for IND-CCA2 **)
module type Adv_INDCCA2 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit
  proc distinguish(k : key_t, c : ctxt_t) : bool
}.

(** IND-CCA2 security game (sampled bit) **)
module IND_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_INDCCA2) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O2.init(sk, c);
    
    b <$ {0,1};
    
    b' <@ A(O2).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CCA2 security game (provided bit) **)
module IND_CCA2_P (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_INDCCA2) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O2.init(sk, c);
    
    b' <@ A(O2).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.


(*
  (ciphertext) INDistinguishability under (modern) adaptive Chosen-Ciphertext Attacks (IND-CCA2).
  In a (modern) CCA2 setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkeym).
*)
(** Adversary class considered for IND-CCA (i.e., modern IND-CCA2) **)
module type Adv_INDCCA (O : Oracles_CCA) = {
  proc distinguish(pk : pk_t, k : key_t, c : ctxt_t) : bool
}.

(** IND-CCA (i.e., modern IND-CCA2) security game (sampled bit) **)
module IND_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_INDCCA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O.init(sk, c);
    
    b <$ {0,1};
    
    b' <@ A(O).distinguish(pk, if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CCA (i.e., modern IND-CCA2) security game (provided bit) **)
module IND_CCA_P (S : Scheme, O : Oracles_CCA2i, A : Adv_INDCCA) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O.init(sk, c);
    
    b' <@ A(O).distinguish(pk, if b then k' else k, c);
    
    return b' = b; 
  }
}.

end IND.


(** 
  (ciphertext) Non-Malleability (NM).
  Given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
  
  (ciphertext) Strong Non-Malleability (SNM)
  As NM-CPA, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
**)
abstract theory NM.
(* Distributions *)
(** (Sub-)Distribution over (symmetric) keys (may depend on public key) **)
(** 
  Dependence on public key may be used to, e.g., model cases where the key space
  depends on the public key (like in the case of RSA). Instead of having the actual type
  change depending on the public key (which, at the time of writing, is not possible in EC).
**)
op dkeym : pk_t -> key_t distr.

(*
  (ciphertext) Non-Malleability under Chosen-Plaintext Attacks (NM-CPA).
  In a CPA setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CPA **)
module type Adv_NMCPA = {
  proc find(pk : pk_t, c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** NM-CPA security game (sampled bit) **)
module NM_CPA (S : Scheme, A : Adv_NMCPA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    (rel, cl) <@ A.find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CPA security game (provided bit) **)
module NM_CPA_P (S : Scheme, A : Adv_NMCPA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    (rel, cl) <@ A.find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under Chosen-Plaintext Attacks (SNM-CPA).
  As NM-CPA, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CPA **)
module type Adv_SNMCPA = {
  proc find(pk : pk_t, c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** SNM-CPA security game (sampled bit) **)
module SNM_CPA (S : Scheme, A : Adv_SNMCPA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    o <$ {0,1};
    (rel, cl) <@ A.find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CPA security game (provided bit) **)
module SNM_CPA_P (S : Scheme, A : Adv_SNMCPA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    o <$ {0,1};
    (rel, cl) <@ A.find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.


(*
  (ciphertext) Non-Malleability under non-adaptive Chosen-Ciphertext Attacks (NM-CCA1).
  In a CCA1 setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CCA1 **)
module type Adv_NMCCA1 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit { O.decaps }
  proc find(c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list { }
}.

(** NM-CCA1 security game (sampled bit) **)
module NM_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_NMCCA1) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    (rel, cl) <@ A(O).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CCA1 security game (provided bit) **)
module NM_CCA1_P (S : Scheme, O : Oracles_CCA1i, A : Adv_NMCCA1) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    
    (rel, cl) <@ A(O).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under non-adaptive Chosen-Ciphertext Attacks (SNM-CCA1).
  As NM-CCA1, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CCA1 **)
module type Adv_SNMCCA1 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit { O.decaps }
  proc find(c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list { }
}.

(** SNM-CCA1 security game (sanmpled bit) **)
module SNM_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_SNMCCA1) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
        
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;

    o <$ {0,1};
    (rel, cl) <@ A(O).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CCA1 security game (provided bit) **)
module SNM_CCA1_P (S : Scheme, O : Oracles_CCA1i, A : Adv_SNMCCA1) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
        
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;

    o <$ {0,1};
    (rel, cl) <@ A(O).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }

    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.


(*
  (ciphertext) Non-Malleability under (traditional) adaptive Chosen-Ciphertext Attacks (NM-CCA2).
  In a (traditional) CCA2 setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CCA2 **)
module type Adv_NMCCA2 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit
  proc find(c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** NM-CCA2 security game (sampled bit) **)
module NM_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_NMCCA2) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O2.init(sk, c);
    
    (rel, cl) <@ A(O2).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CCA2 security game (provided bit) **)
module NM_CCA2_P (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_NMCCA2) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
        
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O2.init(sk, c);
    
    (rel, cl) <@ A(O2).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under (traditional) adaptive Chosen-Ciphertext Attacks (SNM-CCA2).
  As NM-CCA2, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CCA2 **)
module type Adv_SNMCCA2 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit
  proc find(c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** SNM-CCA2 security game **)
module SNM_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_SNMCCA2) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);

    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O2.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O2).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CCA2 security game (provided bit) **)
module SNM_CCA2_P (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_SNMCCA2) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);

    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O2.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O2).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.


(*
  (ciphertext) Non-Malleability under (modern) adaptive Chosen-Ciphertext Attacks (NM-CCA).
  In a (modern) CCA2 setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CCA (i.e., modern NM-CCA2) **)
module type Adv_NMCCA (O : Oracles_CCA) = {
  proc find(pk : pk_t, c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** NM-CCA (i.e., modern NM-CCA2) security game (sampled bit) **)
module NM_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_NMCCA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O.init(sk, c);
    
    (rel, cl) <@ A(O).find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CCA (i.e., modern NM-CCA2) security game (provided bit) **)
module NM_CCA_P (S : Scheme, O : Oracles_CCA2i, A : Adv_NMCCA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
        
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O.init(sk, c);
    
    (rel, cl) <@ A(O).find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under (modern) adaptive Chosen-Ciphertext Attacks (SNM-CCA).
  As NM-CCA, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CCA (i.e., modern SNM-CCA2) **)
module type Adv_SNMCCA (O : Oracles_CCA) = {
  proc find(pk : pk_t, c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** SNM-CCA (i.e., modern SNM-CCA2) security game **)
module SNM_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_SNMCCA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O).find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CCA (i.e., modern SNM-CCA2) security game **)
module SNM_CCA_P (S : Scheme, O : Oracles_CCA2i, A : Adv_SNMCCA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkeym pk;
    O.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O).find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

end NM.


(* 
  ANOnymity (ANO).
  The adversary is given two (honestly generated) public keys and an encapsulation 
  (i.e., ciphertext/key pair), and asked to determine which public key was used to
  create the encapsulation.
  
  Weak ANOnymity (WANO).
  As ANO, but the adversary is only given the ciphertext of the encapsulation 
  (i.e., not the key).
*)
(*
  ANOnymity under Chosen-Plaintext attack (ANO-CPA).
  In a CPA setting, The adversary is given two (honestly generated) public keys 
  and an encapsulation (i.e., key/ciphertext pair), and asked to determine which 
  public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CPA **)
module type Adv_ANOCPA = {
  proc distinguish(pk0 : pk_t, pk1 : pk_t, kc : key_t * ctxt_t) : bool
}.

(** ANO-CPA security game (sampled bit) **)
module ANO_CPA (S : Scheme, A : Adv_ANOCPA) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    b <$ {0,1};
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A.distinguish(pk0, pk1, kc);
    
    return b' = b;
  }
}.

(** ANO-CPA security game (provided bit) **)
module ANO_CPA_P (S : Scheme, A : Adv_ANOCPA) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A.distinguish(pk0, pk1, kc);
    
    return b';
  }
}.

(*
  Weak ANOnymity under Chosen-Plaintext attack (WANO-CPA).
  As ANO-CPA, but the adversary is only given the ciphertext of the encapsulation 
  (i.e., not the key).
*)
(** Adversary class considerd for WANO-CPA **)
module type Adv_WANOCPA = {
  proc distinguish(pk0 : pk_t, pk1 : pk_t, c : ctxt_t) : bool
}.

(** WANO-CPA security game (sampled bit) **)
module WANO_CPA (S : Scheme, A : Adv_WANOCPA) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A.distinguish(pk0, pk1, c);
    
    return b' = b;
  }
}.

(** WANO-CPA security game (provided bit) **)
module WANO_CPA_P (S : Scheme, A : Adv_WANOCPA) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A.distinguish(pk0, pk1, c);
    
    return b' = b;
  }
}.


(*
  ANOnymity under non-adaptive Chosen-Plaintext attack (ANO-CCA1).
  In a CCA1 setting, the adversary is given (in the first stage) two (honestly generated) public keys 
  and (in the second stage) an encapsulation (i.e., key/ciphertext pair), and is 
  asked to determine which public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CCA1 **)
module type Adv_ANOCCA1 (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc scout(pk0 : pk_t, pk1 : pk_t) : unit{ O0.decaps, O1.decaps }
  proc distinguish(kc : key_t * ctxt_t) : bool { }
}.

(** ANO-CCA1 security game (sampled bit) **)
module ANO_CCA1 (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_ANOCCA1) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    A(O0, O1).scout(pk0, pk1);
    
    b <$ {0,1};
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A(O0, O1).distinguish(kc);
    
    return b' = b;
  }
}.

(** ANO-CCA1 security game (provided bit) **)
module ANO_CCA1_P (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_ANOCCA1) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    A(O0, O1).scout(pk0, pk1);
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A(O0, O1).distinguish(kc);
    
    return b';
  }
}.


(*
  Weak ANOnymity under non-adaptive Chosen-Plaintext attack (WANO-CCA1).
  As ANO-CCA1, but the adversary is only given the ciphertext of the encapsulation 
  (i.e., not the key).
*)
(** Adversary class considerd for WANO-CCA1 **)
module type Adv_WANOCCA1 (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc scout(pk0 : pk_t, pk1 : pk_t) : unit{ O0.decaps, O1.decaps }
  proc distinguish(c : ctxt_t) : bool { }
}.

(** WANO-CCA1 security game (sampled bit) **)
module WANO_CCA1 (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_WANOCCA1) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    A(O0, O1).scout(pk0, pk1);
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A(O0, O1).distinguish(c);
    
    return b' = b;
  }
}.

(** WANO-CCA1 security game (provided bit) **)
module WANO_CCA1_P (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_WANOCCA1) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    A(O0, O1).scout(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A(O0, O1).distinguish(c);
    
    return b' = b;
  }
}.


(*
  ANOnymity under (traditional) adaptive Chosen-Plaintext attack (ANO-CCA2).
  In a (traditional) CCA2 setting, the adversary is given (in the first stage) two 
  (honestly generated) public keys and (in the second stage) an encapsulation 
  (i.e., key/ciphertext pair), and is 
  asked to determine which public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CCA2 **)
module type Adv_ANOCCA2 (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc scout(pk0 : pk_t, pk1 : pk_t) : unit
  proc distinguish(kc : key_t * ctxt_t) : bool
}.

(** ANO-CCA2 security game (sampled bit) **)
module ANO_CCA2 (S : Scheme)
                (O01 : Oracles_CCA1i, O11 : Oracles_CCA1i)
                (O02 : Oracles_CCA2i, O12 : Oracles_CCA2i)
                (A : Adv_ANOCCA2) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O01.init(sk0);
    O11.init(sk1);
    
    A(O01, O11).scout(pk0, pk1);
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O02.init(sk0, c);
    O12.init(sk1, c);
    
    b' <@ A(O02, O12).distinguish((k, c));
    
    return b' = b;
  }
}.

(** ANO-CCA2 security game (provided bit) **)
module ANO_CCA2_P (S : Scheme)
                  (O01 : Oracles_CCA1i, O11 : Oracles_CCA1i)
                  (O02 : Oracles_CCA2i, O12 : Oracles_CCA2i)
                  (A : Adv_ANOCCA2) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O01.init(sk0);
    O11.init(sk1);
    
    A(O01, O11).scout(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O02.init(sk0, c);
    O12.init(sk1, c);
    
    b' <@ A(O02, O12).distinguish((k, c));
    
    return b';
  }
}.

(*
  Weak ANOnymity under (traditional) adaptive Chosen-Plaintext attack (WANO-CCA2).
  As ANO-CCA2, but the adversary is only given the ciphertext of the encapsulation 
  (i.e., not the key).
*)
(** Adversary class considerd for WANO-CCA2 **)
module type Adv_WANOCCA2 (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc scout(pk0 : pk_t, pk1 : pk_t) : unit
  proc distinguish(c : ctxt_t) : bool
}.

(** WANO-CCA2 security game (sampled bit) **)
module WANO_CCA2 (S : Scheme)
                 (O01 : Oracles_CCA1i, O11 : Oracles_CCA1i)
                 (O02 : Oracles_CCA2i, O12 : Oracles_CCA2i)
                 (A : Adv_WANOCCA2) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O01.init(sk0);
    O11.init(sk1);
    
    A(O01, O11).scout(pk0, pk1);
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O02.init(sk0, c);
    O12.init(sk1, c);
    
    b' <@ A(O02, O12).distinguish(c);
    
    return b' = b;
  }
}.

(** WANO-CCA2 security game (provided bit) **)
module WANO_CCA2_P (S : Scheme)
                   (O01 : Oracles_CCA1i, O11 : Oracles_CCA1i)
                   (O02 : Oracles_CCA2i, O12 : Oracles_CCA2i)
                   (A : Adv_WANOCCA2) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O01.init(sk0);
    O11.init(sk1);
    
    A(O01, O11).scout(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O02.init(sk0, c);
    O12.init(sk1, c);
    
    b' <@ A(O02, O12).distinguish(c);
    
    return b';
  }
}.


(*
  ANOnymity under (modern) adaptive Chosen-Plaintext attack (ANO-CCA).
  In a (modern) CCA setting, the adversary is given (in the first stage) two 
  (honestly generated) public keys and (in the second stage) an encapsulation 
  (i.e., key/ciphertext pair), and is 
  asked to determine which public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CCA (i.e., modern ANO-CCA2) **)
module type Adv_ANOCCA (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc distinguish(pk0 : pk_t, pk1 : pk_t, kc : key_t * ctxt_t) : bool
}.

(** ANO-CCA (i.e., modern ANO-CCA2) security game (sampled bit) **)
module ANO_CCA (S : Scheme)
               (O0 : Oracles_CCA2i, O1 : Oracles_CCA2i)
               (A : Adv_ANOCCA) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O0.init(sk0, c);
    O1.init(sk1, c);
    
    b' <@ A(O0, O1).distinguish(pk0, pk1, (k, c));
    
    return b' = b;
  }
}.

(** ANO-CCA (i.e., modern ANO-CCA2) security game (provided bit) **)
module ANO_CCA_P (S : Scheme)
                 (O0 : Oracles_CCA2i, O1 : Oracles_CCA2i)
                 (A : Adv_ANOCCA) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O0.init(sk0, c);
    O1.init(sk1, c);
    
    b' <@ A(O0, O1).distinguish(pk0, pk1, (k, c));
    
    return b' = b;
  }
}.

(*
  Weak ANOnymity under (modern) adaptive Chosen-Plaintext attack (WANO-CCA).
  As ANO-CCA2, but the adversary is only given the ciphertext of the encapsulation 
  (i.e., not the key).
*)
(** Adversary class considerd for ANO-CCA (i.e., modern ANO-CCA2) **)
module type Adv_WANOCCA (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc distinguish(pk0 : pk_t, pk1 : pk_t, c : ctxt_t) : bool
}.

(** WANO-CCA (i.e., modern WANO-CCA2) security game (sampled bit) **)
module WANO_CCA (S : Scheme)
                (O0 : Oracles_CCA2i, O1 : Oracles_CCA2i)
                (A : Adv_WANOCCA) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O0.init(sk0, c);
    O1.init(sk1, c);
    
    b' <@ A(O0, O1).distinguish(pk0, pk1, c);
    
    return b' = b;
  }
}.

(** WANO-CCA (i.e., modern WANO-CCA2) security game (provided bit) **)
module WANO_CCA_P (S : Scheme)
                  (O0 : Oracles_CCA2i, O1 : Oracles_CCA2i)
                  (A : Adv_WANOCCA) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O0.init(sk0, c);
    O1.init(sk1, c);
    
    b' <@ A(O0, O1).distinguish(pk0, pk1, c);
    
    return b' = b;
  }
}.


(*
  Strong ROBustness (SROB).
  The adversary is given two (honestly generated) public keys and is asked to
  provide a (single) ciphertext that decapsulates to valid symmetric keys under both 
  of the secret keys (corresponding to the provided public keys).
  
  Weak ROBustness (WROB).
  The adversary is given two (honestly generated) public keys and is asked to choose
  which one to use for encapsulation and which one to use (the corresponding secret key of)
  for decapsulation. Here, the goal is that the decapsulation (with the key appointed for
  decapsulation) of the encapsulation (created with the key appointed for encapsulation) succeeds 
  (i.e., returns a valid symmetric key).
  
  Note, as there is no stage in which the adversary is given a distinct challenge artifact, it does
  not make sense to have different CCA1/CCA2 settings for these properties. Instead,
  we only consider a CPA setting (no decapsulation oracle) and a CCA setting (a decapsulation
  oracle like in CCA1, i.e., no considered challenge).
*)
(*
  Strong ROBustness under Chosen-Plaintext Attacks (SROB-CPA).
  In a CPA setting, the adversary is given two (honestly generated) public keys and is asked to
  provide a (single) ciphertext that decapsulates to valid symmetric keys under both 
  of the secret keys (corresponding to the provided public keys).
*)
(** Adversary class considered for SROB-CPA **)
module type Adv_SROBCPA = {
  proc find(pk0 : pk_t, pk1 : pk_t) : ctxt_t
}.

(** SROB-CPA security game **)
module SROB_CPA (S : Scheme, A : Adv_SROBCPA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k0, k1 : key_t option;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    c <@ A.find(pk0, pk1);
    
    k0 <@ S.decaps(sk0, c);
    k1 <@ S.decaps(sk1, c);
    
    return k0 <> None /\ k1 <> None;
  }
}.

(*
  Weak ROBustness under Chosen-Plaintext Attacks (WROB-CPA).
  In a CPA setting, the adversary is given two (honestly generated) public keys and is asked to choose
  which one to use for encapsulation and which one to use (the corresponding secret key of)
  for decapsulation. Here, the goal is that the decapsulation (with the key appointed for
  decapsulation) of the encapsulation (created with the key appointed for encapsulation) succeeds 
  (i.e., returns a valid symmetric key).
*)
(** Adversary class considered for WROB-CPA **)
module type Adv_WROBCPA = {
  proc choose(pk0 : pk_t, pk1 : pk_t) : bool
}.

(** WROB-CPA security game **)
module WROB_CPA (S : Scheme, A : Adv_WROBCPA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k : key_t;
    var k' : key_t option;
    var b : bool;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();

    b <@ A.choose(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    k' <@ S.decaps(if b then sk0 else sk1, c);
    
    return k' <> None;
  }
}.


(*
  Strong ROBustness under Chosen-Ciphertext Attacks (SROB-CCA).
  In a CCA setting, the adversary is given two (honestly generated) public keys and is asked to
  provide a (single) ciphertext that decapsulates to valid symmetric keys under both 
  of the secret keys (corresponding to the provided public keys).
*)
(** Adversary class considered for SROB-CCA **)
module type Adv_SROBCCA (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc find(pk0 : pk_t, pk1 : pk_t) : ctxt_t
}.

(** SROB-CCA security game **)
module SROB_CCA (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_SROBCCA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k0, k1 : key_t option;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    c <@ A(O0, O1).find(pk0, pk1);
    
    k0 <@ S.decaps(sk0, c);
    k1 <@ S.decaps(sk1, c);
    
    return k0 <> None /\ k1 <> None;
  }
}.

(*
  Weak ROBustness under Chosen-Ciphertext Attacks (WROB-CCA).
  In a CCA setting, the adversary is given two (honestly generated) public keys and is asked to choose
  which one to use for encapsulation and which one to use (the corresponding secret key of)
  for decapsulation. Here, the goal is that the decapsulation (with the key appointed for
  decapsulation) of the encapsulation (created with the key appointed for encapsulation) succeeds 
  (i.e., returns a valid symmetric key).
*)
(** Adversary class considered for WROB-CCA **)
module type Adv_WROBCCA (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc choose(pk0 : pk_t, pk1 : pk_t) : bool
}.

(** WROB-CCA security game **)
module WROB_CCA (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_WROBCCA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k : key_t;
    var k' : key_t option;
    var b : bool;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    b <@ A(O0, O1).choose(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    k' <@ S.decaps(if b then sk0 else sk1, c);
    
    return k' <> None;
  }
}.


(*
  Strong Collision-FReeness (SCFR).
  As SROB, but additionally requires the resulting symmetric keys to be
  equal to eachother (instead of only requiring these keys to be valid).
  
  Weak Collision-FReeness (WCFR).
  As WROB, but additionally requires the resulting symmetric keys to be
  equal to eachother (instead of only requiring the final decapsulated key to be valid).
*)
(*
  Strong Collision-FReeness under Chosen-Plaintext Attacks (SCFR-CPA).
  In a CPA setting, the adversary is given two (honestly generated) public keys and is asked to
  provide a (single) ciphertext that decapsulates to the same valid symmetric key under both 
  of the secret keys (corresponding to the provided public keys).
*)
(** Adversary class considered for SCFR-CPA **)
module type Adv_SCFRCPA = {
  proc find(pk0 : pk_t, pk1 : pk_t) : ctxt_t
}.

(** SCFR-CPA security game **)
module SCFR_CPA (S : Scheme, A : Adv_SCFRCPA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k0, k1 : key_t option;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    c <@ A.find(pk0, pk1);
    
    k0 <@ S.decaps(sk0, c);
    k1 <@ S.decaps(sk1, c);
    
    return k0 <> None /\ k1 <> None /\ k0 = k1;
  }
}.

(*
  Weak Collision-FReeness under Chosen-Plaintext Attacks (WCFR-CPA).
  In a CPA setting, the adversary is given two (honestly generated) public keys and is asked to choose
  which one to use for encapsulation and which one to use (the corresponding secret key of)
  for decapsulation. Here, the goal is that the decapsulation (with the key appointed for
  decapsulation) of the encapsulation (created with the key appointed for encapsulation) returns
  a valid symmetric key that is equal to the encapsulated one.
*)
(** Adversary class considered for WCFR-CPA **)
module type Adv_WCFRCPA = {
  proc choose(pk0 : pk_t, pk1 : pk_t) : bool
}.

(** WCFR-CPA security game **)
module WCFR_CPA (S : Scheme, A : Adv_WCFRCPA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k : key_t;
    var k' : key_t option;
    var b : bool;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();

    b <@ A.choose(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    k' <@ S.decaps(if b then sk0 else sk1, c);
    
    return k' = Some k;
  }
}.


(*
  Strong Collision-FReeness under Chosen-Ciphertext Attacks (SCFR-CCA).
  In a CCA setting, the adversary is given two (honestly generated) public keys and is asked to
  provide a (single) ciphertext that decapsulates to the same valid symmetric key under both 
  of the secret keys (corresponding to the provided public keys).
*)
(** Adversary class considered for SCFR-CCA **)
module type Adv_SCFRCCA (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc find(pk0 : pk_t, pk1 : pk_t) : ctxt_t
}.

(** SCFR-CCA security game **)
module SCFR_CCA (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_SCFRCCA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k0, k1 : key_t option;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    c <@ A(O0, O1).find(pk0, pk1);
    
    k0 <@ S.decaps(sk0, c);
    k1 <@ S.decaps(sk1, c);
    
    return k0 <> None /\ k1 <> None /\ k0 = k1;
  }
}.

(*
  Weak ROBustness under Chosen-Ciphertext Attacks (WCFR-CCA).
  In a CCA setting, the adversary is given two (honestly generated) public keys and is asked to choose
  which one to use for encapsulation and which one to use (the corresponding secret key of)
  for decapsulation. Here, the goal is that the decapsulation (with the key appointed for
  decapsulation) of the encapsulation (created with the key appointed for encapsulation) returns
  a valid symmetric key that is equal to the encapsulated one.
*)
(** Adversary class considered for WCFR-CCA **)
module type Adv_WCFRCCA (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc choose(pk0 : pk_t, pk1 : pk_t) : bool
}.

(** WCFR-CCA security game **)
module WCFR_CCA (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_WCFRCCA) = {
  proc main() : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var k : key_t;
    var k' : key_t option;
    var b : bool;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    b <@ A(O0, O1).choose(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    k' <@ S.decaps(if b then sk0 else sk1, c);
    
    return k' <> Some k;
  }
}.


(*
  BINDing (BIND).
  Intuitively, binding properties capture to which extent certain artifacts (in a 
  a non-failing KEM execution) determine other artifacts (in that same execution).
  That is, informally, an artifact (e.g., symmetric key) binds another artifact (e.g., a ciphertext)
  if seeing a certain value for the symmetric key (without failing) implies that the ciphertext is actually
  the one corresponding to this symmetric key (because it is hard to find another one that decapsulates to the
  same symmetric key without failing).
  Depending on the adversarial model, the artifacts used as input to the KEM's procedures
  are either honestly or maliciously generated.
*)
(* Types *)
(** Binding configurations considered **)
type bindconf = [
    K_Binds_PK
  | K_Binds_CT
  | CT_Binds_K
  | CT_Binds_PK
  | KCT_Binds_PK
  | PKK_Binds_CT
  | PKCT_Binds_K
].


(* Operators *)
(** 
  Checks whether binding configuration considers
  the public key as a binding source element 
**)
op is_pkbc (bc : bindconf) =
  bc = PKK_Binds_CT \/ bc = PKCT_Binds_K.

(** 
  Checks whether the provided values consitute a binding break w.r.t. the
  given binding configuration.
**)
(** 
  Specifically, if the configuration is P_Binds_Q, then the provided values consitute
  a binding break iff the similarly-typed values (for the artifacts) in P are equal 
  *and* there exist similarly-typed values (for the artifacts) in Q that are unequal. 
**)
(**
  Note that this does not include the check concerning the validity of the (symmetric)
  keys (i.e., success of the decapsulations); this is delegated to the security games.
**)
op is_bindbreak (bc : bindconf) (k0 k1 : key_t) (pk0 pk1 : pk_t) (c0 c1 : ctxt_t) =
  with bc = K_Binds_PK => k0 = k1 /\ pk0 <> pk1
  with bc = K_Binds_CT => k0 = k1 /\ c0 <> c1
  with bc = CT_Binds_K => c0 = c1 /\ k0 <> k1  
  with bc = CT_Binds_PK => c0 = c1 /\ pk0 <> pk1
  with bc = KCT_Binds_PK => k0 = k1 /\ c0 = c1 /\ pk0 <> pk1
  with bc = PKK_Binds_CT => pk0 = pk1 /\ k0 = k1 /\ c0 <> c1
  with bc = PKCT_Binds_K => pk0 = pk1 /\ c0 = c1 /\ k0 <> k1.


(* 
  HONestly BINDing (HON-BIND).
  Binding properties where the adversary is given two honestly generated public keys,
  as well as a decapsulation oracle with which it can decapsulate
  w.r.t. the corresponding secret keys.
*)
(** Adversary class considered for HON-BIND **)
module type Adv_HONBIND (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc find(pk0 : pk_t, pk1 : pk_t) : ctxt_t * ctxt_t
}.

(** HON-BIND security game (specific configuration is passed to the procedure) **)
module HON_BIND (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_HONBIND) = {
  proc main(bc : bindconf) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t option;
    var no_fail: bool;
    
    (pk0, sk0) <@ S.keygen();
    
    if (is_pkbc bc) { 
      (pk1, sk1) <- (pk0, sk0);
    } else {
      (pk1, sk1) <@ S.keygen();
    }
    
    O0.init(sk0);
    O1.init(sk1);
    
    (c0, c1) <@ A(O0, O1).find(pk0, pk1);
    
    k0 <@ S.decaps(sk0, c0);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k0 <> None /\ k1 <> None;
    
    return no_fail /\ is_bindbreak bc (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.


(*
  LEAKingly BINDing (LEAK-BIND).
  Binding properties where the adversary is given two
  honestly generated (asymmetric) key pairs.
*)
(** Adversary class considered for LEAK-BIND **)
module type Adv_LEAKBIND= {
  proc find(pk0 : pk_t, sk0 : sk_t, pk1 : pk_t, sk1 : sk_t) : ctxt_t * ctxt_t
}.

(** LEAK-BIND security game (specific configuration is passed to the procedure) **)
module LEAK_BIND (S : Scheme, A : Adv_LEAKBIND) = {
  proc main(bc : bindconf) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t option;
    var no_fail : bool;
    
    (pk0, sk0) <@ S.keygen();
    
    if (is_pkbc bc) { 
      (pk1, sk1) <- (pk0, sk0);
    } else {
      (pk1, sk1) <@ S.keygen();
    }
    
    (c0, c1) <@ A.find(pk0, sk0, pk1, sk1);
    
    k0 <@ S.decaps(sk0, c0);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k0 <> None /\ k1 <> None;
    
    return no_fail /\ is_bindbreak bc (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.


(**
  MALiciously BINDing (MAL-BIND).
  Binding properties where the adversary provides the 
  considered (asymmetric) key material itself.
**)
abstract theory MALBIND.
(* Operators *)
(** Derives (honestly) the public key corresponding to a secret key **)
(** 
  Using this, we can let the adversary (in the MAL-BIND properties) only provide
  the to-be-considered (asymmetric) secret keys, and then honestly compute
  the corresponding public key ourselves. This allows
  us to meaningfully include binding properties involving the public key.
**)
(** 
  Note: for the properties to make sense, this operator 
  should be instantiated to something that actually derives
  public keys from (honestly generated) secret keys for the considered KEM. 
**)
op sk2pk : sk_t -> pk_t.


(* 
  MALiciously BINDing w.r.t. Decapsulation/Decapsulation (MAL-BIND-DD).
  In a MAL-BIND setting, the adversary is asked to provide two ciphertext
  (to be decapsulated) as to induce a binding break (w.r.t. the considered configuration).
*)
(** Adversary class considered for MAL-BIND-DD **)
module type Adv_MALBIND_DD = {
  proc find() : sk_t * sk_t * ctxt_t * ctxt_t
}.

(** MAL-BIND-DD security game (specific configuration is passed to the procedure) **)
module MAL_BIND_DD (S : Scheme, A : Adv_MALBIND_DD) = {
  proc main(bc : bindconf) : bool = {
    var sk0, sk1 : sk_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t option;
    var pk0, pk1 : pk_t;
    var no_fail : bool;
    
    (sk0, sk1, c0, c1) <@ A.find();
    
    pk0 <- sk2pk sk0;
    pk1 <- sk2pk sk1;
    
    k0 <@ S.decaps(sk0, c0);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k0 <> None /\ k1 <> None;
    
    return no_fail /\ is_bindbreak bc (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.


(*
  In the remaining MAL-BIND properties, the adversary is asked to provide 
  the randomness used in encapsulation(s). That is, these properties need 
  to consider "derandomized" encapsulation procedures, taking the randomness 
  as additional input (instead of generating it on the fly).
  To this end, we specify a module type for KEMs that is identical to the 
  original one with an appropriately adjusted encapsulation procedure.
  Be aware that the following properties only make sense for KEMs of which
  the encapsulation procedure actually employs the provided randomness.
  (This is not actually enforced by the module type.)
*)
(* Types *)
(** Randomness (for encapsulation procedure) **)
type rand_t.


(* Module types *)
(** "Derandomized" KEM (interface) **)
module type SchemeDerand = {
  include Scheme [-encaps]
  proc encaps(pk : pk_t, r : rand_t) : key_t * ctxt_t
}.


(*
  MALiciously BINDing w.r.t. Encapsulation/Decapsulation (MAL-BIND-ED)
  In a MAL-BIND setting, the adversary is asked to provide 
  randomness and a ciphertext (to be used in encapsulation and 
  decapsulation, respectively) as to induce a binding break 
  (w.r.t. the considered configuration).
*)
(** Adversary class considered for MAL-BIND-ED **)
module type Adv_MALBIND_ED = {
  proc find() : sk_t * sk_t * rand_t * ctxt_t
}.

(** MAL-BIND-ED security game (specific configuration is passed to the procedure) **)
module MAL_BIND_ED (S : SchemeDerand, A : Adv_MALBIND_ED) = {
  proc main(bc : bindconf) : bool = {
    var sk0, sk1 : sk_t;
    var r : rand_t;
    var c0, c1 : ctxt_t;
    var k0 : key_t;
    var k1 : key_t option;
    var pk0, pk1 : pk_t;
    var no_fail : bool;
    
    (sk0, sk1, r, c1) <@ A.find();
    
    pk0 <- sk2pk sk0;
    pk1 <- sk2pk sk1;
    
    (k0, c0) <@ S.encaps(pk0, r);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k1 <> None;
    
    return no_fail /\ is_bindbreak bc k0 (oget k1) pk0 pk1 c0 c1;
  }
}.


(*
  MALiciously BINDing w.r.t. Encapsulation/Encapsulation (MAL-BIND-EE)
  In a MAL-BIND setting, the adversary is asked to provide
  randomness (to be used in encapsulations) as to induce a binding break 
  (w.r.t. the considered configuration).
*)
(** Adversary class considered for MAL-BIND-EE **)
module type Adv_MALBIND_EE = {
  proc find() : sk_t * sk_t * rand_t * rand_t
}.

(** MAL-BIND-EE security game (specific configuration is passed to the procedure) **)
module MAL_BIND_EE (S : SchemeDerand, A : Adv_MALBIND_EE) = {
  proc main(bc : bindconf) : bool = {
    var sk0, sk1 : sk_t;
    var r0, r1 : rand_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t;
    var pk0, pk1 : pk_t;
    
    (sk0, sk1, r0, r1) <@ A.find();
    
    pk0 <- sk2pk sk0;
    pk1 <- sk2pk sk1;
    
    (k0, c0) <@ S.encaps(pk0, r0);
    (k1, c1) <@ S.encaps(pk1, r1);

    return is_bindbreak bc k0 k1 pk0 pk1 c0 c1;
  }
}.


(*
  MALiciously BINDing w.r.t. any of DD, ED, or EE (MAL-BIND).
  The adversary is asked to choose any of the MAL-BIND scenarios (DD, DE, or EE) 
  and provide values that induce a binding break
  (w.r.t. the considered configuration) for that scenario.
*)
(* Types *)
(** Malicious binding scenarios **)
type malbind_scenario = [
    DECAPS_DECAPS
  | ENCAPS_DECAPS
  | ENCAPS_ENCAPS
].

(* Can potentially reuse things specific to MALBIND scenarios in general MALBIND game by tweaking interfaces, but may hurt readability quite a bit *)
(** Adversary class considered for MAL-BIND **)
module type Adv_MALBIND = {
  proc choose() : malbind_scenario
  proc find_dd() : sk_t * sk_t * ctxt_t * ctxt_t
  proc find_de() : sk_t * sk_t * rand_t * ctxt_t
  proc find_ee() : sk_t * sk_t * rand_t * rand_t
}.

(** MAL-BIND security game (specific configuration is passed to the procedure) **)
module MAL_BIND (S : SchemeDerand, A : Adv_MALBIND) = {
  proc main(bc : bindconf) : bool = {
    var mbs : malbind_scenario;
    var sk0, sk1 : sk_t;
    var r0, r1 : rand_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t;
    var k0o, k1o : key_t option;
    var pk0, pk1 : pk_t;
    var no_fail, is_bb : bool;
        
    mbs <@ A.choose();
    
    if (mbs = DECAPS_DECAPS) {
      (sk0, sk1, c0, c1) <@ A.find_dd();
    
      pk0 <- sk2pk sk0;
      pk1 <- sk2pk sk1;

      k0o <@ S.decaps(sk0, c0);
      k1o <@ S.decaps(sk1, c1);

      no_fail <- k0o <> None /\ k1o <> None;
      is_bb <- is_bindbreak bc (oget k0o) (oget k1o) pk0 pk1 c0 c1;
    } elif (mbs = ENCAPS_DECAPS) {
      (sk0, sk1, r0, c1) <@ A.find_de();

      pk0 <- sk2pk sk0;
      pk1 <- sk2pk sk1;

      (k0, c0) <@ S.encaps(pk0, r0);
      k1o <@ S.decaps(sk1, c1);
      
      no_fail <- k1o <> None;
      is_bb <- is_bindbreak bc k0 (oget k1o) pk0 pk1 c0 c1;
    } else { (* mbs = ENCAPS_ENCAPS *)
      (sk0, sk1, r0, r1) <@ A.find_ee();
    
      pk0 <- sk2pk sk0;
      pk1 <- sk2pk sk1;

      (k0, c0) <@ S.encaps(pk0, r0);
      (k1, c1) <@ S.encaps(pk1, r1);
      
      no_fail <- true;
      is_bb <- is_bindbreak bc k0 k1 pk0 pk1 c0 c1;
    }

    return no_fail /\ is_bb;
  }
}.

end MALBIND.




(** 
  Generic relations between properties of KEMs.
**)
theory Relations.
(* 
  Hierarchy concerning (traditional) CCA2, (traditional) CCA1, and CPA.
  (CCA2 --> CCA1 --> CPA), as well as (modern) CCA and CPA (CCA --> CPA).
*)
(* Security goal: One-wayness *)
(** 
  Equivalence between OW_CCA1 and OW_CCA2 for an OW_CCA1 adversary 
  (shows OW_CCA2 --> OW_CCA1). No reduction needed, because OW_CCA1 adversary satisfies
  interface expected from OW_CCA2 adversaries, but simply does not gain access to
  oracle in second stage.
**)  
equiv Eqv_OWCCA1_OWCCA2 (S <: Scheme{-O_CCA1_Default}) 
                        (A <: Adv_OWCCA1{-O_CCA1_Default, -S}) :
  OW_CCA1(S, O_CCA1_Default(S), A).main ~ OW_CCA2(S, O_CCA1_Default(S), O_CCA2_Default(S), A).main : 
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(** Reduction adversary reducing OW-CCA1 to OW-CPA **)
module (R_OWCCA1_OWCPA (A : Adv_OWCPA) : Adv_OWCCA1) (O : Oracles_CCA) = { 
  var pkc : pk_t
  
  proc scout(pk : pk_t) : unit = {
    pkc <- pk;
  }
  
  proc find(c : ctxt_t) : key_t = {
    var k : key_t;
    
    k <@ A.find(pkc, c);
    
    return k;
  }
}.

(** 
  Equivalence between OW_CPA (for arbitrary adversary) and OW_CCA1 
  (with above reduction adverary) for an OW_CCA1 adversary (shows OW_CCA1 --> OW_CPA).
**)
equiv Eqv_OWCPA_OWCCA1 (S <: Scheme{-R_OWCCA1_OWCPA}) 
                       (A <: Adv_OWCPA{-S}) :
  OW_CPA(S, A).main ~ OW_CCA1(S, O_CCA1_Default(S), R_OWCCA1_OWCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(** Reduction adversary reducing OW-CCA to OW-CPA **)
module (R_OWCCA_OWCPA (A : Adv_OWCPA) : Adv_OWCCA) (O : Oracles_CCA) = { 
  proc find(pk : pk_t, c : ctxt_t) : key_t = {
    var k : key_t;
    
    k <@ A.find(pk, c);
    
    return k;
  }
}.

(** 
  Equivalence between OW_CPA (for arbitrary adversary) and OW_CCA
  (with above reduction adverary) for an OW_CCA adversary (shows OW_CCA --> OW_CPA).
**)
equiv Eqv_OWCPA_OWCCA (S <: Scheme) 
                      (A <: Adv_OWCPA{-S}) :
  OW_CPA(S, A).main ~ OW_CCA(S, O_CCA2_Default(S), R_OWCCA_OWCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(* Security goal: Indistinguishability *)
clone import IND.

(** 
  Equivalence between IND_CCA1 and IND_CCA2 for an IND_CCA1 adversary 
  (shows IND_CCA2 --> IND_CCA1). No reduction needed, because IND_CCA1 adversary satisfies
  interface expected from IND_CCA2 adversaries, but simply does not gain access to
  oracle in second stage.
**)  
equiv Eqv_INDCCA1_INDCCA2 (S <: Scheme{-O_CCA1_Default}) 
                          (A <: Adv_INDCCA1{-O_CCA1_Default, -S}) :
  IND_CCA1(S, O_CCA1_Default(S), A).main ~ IND_CCA2(S, O_CCA1_Default(S), O_CCA2_Default(S), A).main : 
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(** Reduction adversary reducing IND-CCA1 to IND-CPA **)
module (R_INDCCA1_INDCPA (A : Adv_INDCPA) : Adv_INDCCA1) (O : Oracles_CCA) = {
  var pkc : pk_t
  
  proc scout(pk : pk_t) : unit = {
    pkc <- pk;
  }
    
  proc distinguish(k : key_t, c : ctxt_t) : bool = {
    var b : bool;
    
    b <@ A.distinguish(pkc, k, c);
    
    return b;
  }
}.

(** 
  Equivalence between IND_CPA (for arbitrary adversary) and IND_CCA1 
  (with above reduction adverary) for an IND_CCA1 adversary (shows IND_CCA1 --> IND_CPA).
**)
equiv Eqv_INDCPA_INDCCA1 (S <: Scheme{-R_INDCCA1_INDCPA, -O_CCA1_Default}) 
                         (A <: Adv_INDCPA{-R_INDCCA1_INDCPA, -O_CCA1_Default, -S}) :
  IND_CPA(S, A).main ~ IND_CCA1(S, O_CCA1_Default(S), R_INDCCA1_INDCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. 
proc; inline *.
wp; call (: true); wp.
rnd; rnd.
by call (: true); wp; call (: true); skip.
qed.


(** Reduction adversary reducing IND-CCA to IND-CPA **)
module (R_INDCCA_INDCPA (A : Adv_INDCPA) : Adv_INDCCA) (O : Oracles_CCA) = { 
  proc distinguish(pk : pk_t, k : key_t, c : ctxt_t) : bool = {
    var b : bool;
    
    b <@ A.distinguish(pk, k, c);
    
    return b;
  }
}.

(** 
  Equivalence between IND_CPA (for arbitrary adversary) and IND_CCA
  (with above reduction adverary) for an IND_CCA adversary (shows IND_CCA --> IND_CPA).
**)
equiv Eqv_INDCPA_INDCCA (S <: Scheme) 
                        (A <: Adv_INDCPA{-O_CCA2_Default, -S}) :
  IND_CPA(S, A).main ~ IND_CCA(S, O_CCA2_Default(S), R_INDCCA_INDCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. 
proc; inline *.
wp; call (: true); wp.
rnd; wp; rnd.
by call (: true); call (: true); skip.
qed.


(* Security goal: Non-malleability *)
clone import NM.

(** 
  Equivalence between NM_CCA1 and NM_CCA2 for an NM_CCA1 adversary 
  (shows NM_CCA2 --> NM_CCA1). No reduction needed, because NM_CCA1 adversary satisfies
  interface expected from NM_CCA2 adversaries, but simply does not gain access to
  oracle in second stage.
**)  
equiv Eqv_NMCCA1_NMCCA2 (S <: Scheme{-O_CCA1_Default}) 
                        (A <: Adv_NMCCA1{-O_CCA1_Default, -S}) :
  NM_CCA1(S, O_CCA1_Default(S), A).main ~ NM_CCA2(S, O_CCA1_Default(S), O_CCA2_Default(S), A).main : 
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.

(** Reduction adversary reducing NM-CCA1 to NM-CPA **)
module (R_NMCCA1_NMCPA (A : Adv_NMCPA) : Adv_NMCCA1) (O : Oracles_CCA) = {
  var pkc : pk_t
  
  proc scout(pk : pk_t) : unit = {
    pkc <- pk;
  }
    
  proc find(c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list = {
    var rel : (key_t -> key_t option list -> bool);
    var cl : ctxt_t list;
    
    (rel, cl) <@ A.find(pkc, c);
    
    return (rel, cl);
  }
}.

(** 
  Equivalence between NM_CPA (for arbitrary adversary) and NM_CCA1 
  (with above reduction adverary) for an NM_CCA1 adversary (shows NM_CCA1 --> NM_CPA).
**)
equiv Eqv_NMCPA_NMCCA1 (S <: Scheme{-R_NMCCA1_NMCPA}) 
                       (A <: Adv_NMCPA{-S}) :
  NM_CPA(S, A).main ~ NM_CCA1(S, O_CCA1_Default(S), R_NMCCA1_NMCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(** Reduction adversary reducing NM-CCA to NM-CPA **)
module (R_NMCCA_NMCPA (A : Adv_NMCPA) : Adv_NMCCA) (O : Oracles_CCA) = { 
  proc find(pk : pk_t, c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list = {
    var rel : (key_t -> key_t option list -> bool);
    var cl : ctxt_t list;
    
    (rel, cl) <@ A.find(pk, c);
    
    return (rel, cl);
  }
}.

(** 
  Equivalence between NM_CPA (for arbitrary adversary) and NM_CCA
  (with above reduction adverary) for an NM_CCA adversary (shows NM_CCA --> NM_CPA).
**)
equiv Eqv_NMCPA_NMCCA (S <: Scheme) 
                        (A <: Adv_NMCPA{-S}) :
  NM_CPA(S, A).main ~ NM_CCA(S, O_CCA2_Default(S), R_NMCCA_NMCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(** 
  Equivalence between SNM_CCA1 and SNM_CCA2 for an SNM_CCA1 adversary 
  (shows SNM_CCA2 --> SNM_CCA1). No reduction needed, because SNM_CCA1 adversary satisfies
  interface expected from SNM_CCA2 adversaries, but simply does not gain access to
  oracle in second stage.
**)  
equiv Eqv_SNMCCA1_SNMCCA2 (S <: Scheme{-O_CCA1_Default}) 
                          (A <: Adv_SNMCCA1{-O_CCA1_Default, -S}) :
  SNM_CCA1(S, O_CCA1_Default(S), A).main ~ SNM_CCA2(S, O_CCA1_Default(S), O_CCA2_Default(S), A).main : 
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(** Reduction adversary reducing SNM-CCA1 to SNM-CPA **)
module (R_SNMCCA1_SNMCPA (A : Adv_SNMCPA) : Adv_SNMCCA1) (O : Oracles_CCA) = {
  var pkc : pk_t
  
  proc scout(pk : pk_t) : unit = {
    pkc <- pk;
  }
    
  proc find(c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list = {
    var rel : (key_t -> key_t option list -> bool);
    var cl : ctxt_t list;
    
    (rel, cl) <@ A.find(pkc, c, kk);
    
    return (rel, cl);
  }
}.

(** 
  Equivalence between SNM_CPA (for arbitrary adversary) and SNM_CCA1 
  (with above reduction adverary) for an SNM_CCA1 adversary (shows SNM_CCA1 --> SNM_CPA).
**)
equiv Eqv_SNMCPA_SNMCCA1 (S <: Scheme{-O_CCA1_Default, -R_SNMCCA1_SNMCPA}) 
                         (A <: Adv_SNMCPA{-O_CCA1_Default, -R_SNMCCA1_SNMCPA, -S}) :
  SNM_CPA(S, A).main ~ SNM_CCA1(S, O_CCA1_Default(S), R_SNMCCA1_SNMCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. 
proc; inline *. 
seq 5 12 : (={glob S, sk, k, c, k'} /\ rel{1} = rel0{2} /\ cl{1} = cl0{2}); 2: by sim. 
call (: true); wp. 
rnd; rnd.
by call (: true); wp; call (: true); skip. 
qed.


(** Reduction adversary reducing SNM-CCA to SNM-CPA **)
module (R_SNMCCA_SNMCPA (A : Adv_SNMCPA) : Adv_SNMCCA) (O : Oracles_CCA) = { 
  proc find(pk : pk_t, c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list = {
    var rel : (key_t -> key_t option list -> bool);
    var cl : ctxt_t list;
    
    (rel, cl) <@ A.find(pk, c, kk);
    
    return (rel, cl);
  }
}.

(** 
  Equivalence between SNM_CPA (for arbitrary adversary) and SNM_CCA
  (with above reduction adverary) for an SNM_CCA adversary (shows SNM_CCA --> SNM_CPA).
**)
equiv Eqv_SNMCPA_SNMCCA (S <: Scheme{-O_CCA2_Default}) 
                        (A <: Adv_SNMCPA{-O_CCA2_Default, -S}) :
  SNM_CPA(S, A).main ~ SNM_CCA(S, O_CCA2_Default(S), R_SNMCCA_SNMCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof.
proc; inline *. 
seq 5 13 : (={glob S, sk, k, c, k'} /\ rel{1} = rel0{2} /\ cl{1} = cl0{2}); 2: by sim. 
call (: true); wp. 
rnd; wp; rnd.
by call (: true); call (: true); skip. 
qed. 


(* Security goal: Anonymity (Key-indistinguishability) *)
(** 
  Equivalence between ANO_CCA1 and ANO_CCA2 for an ANO_CCA1 adversary 
  (shows ANO_CCA2 --> ANO_CCA1). No reduction needed, because ANO_CCA1 adversary satisfies
  interface expected from ANO_CCA2 adversaries, but simply does not gain access to
  oracle in second stage.
**)  
equiv Eqv_ANOCCA1_ANOCCA2 (S <: Scheme{-O_CCA1_Default, -O_CCA1_DDefault}) 
                          (A <: Adv_ANOCCA1{-O_CCA1_Default, -O_CCA1_DDefault, -O_CCA2_Default, -O_CCA2_DDefault, -S}) :
  ANO_CCA1(S, O_CCA1_Default(S), O_CCA1_DDefault(S), A).main 
  ~ 
  ANO_CCA2(S, O_CCA1_Default(S), O_CCA1_DDefault(S), O_CCA2_Default(S), O_CCA2_DDefault(S), A).main : 
    ={glob S, glob A} ==> ={res}.
proof. 
proc; inline *.
call (: true); wp; call (: true); rnd.
call (: ={glob S, glob O_CCA1_Default, glob O_CCA1_DDefault}); 1,2: by sim.
by wp; call (: true); call (: true); skip => /> b _ -[]. 
qed.


(** Reduction adversary reducing ANO-CCA1 to ANO-CPA **)
module (R_ANOCCA1_ANOCPA (A : Adv_ANOCPA) : Adv_ANOCCA1) (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  var pkc0, pkc1 : pk_t
  
  proc scout(pk0 : pk_t, pk1 : pk_t) : unit = {
    pkc0 <- pk0;
    pkc1 <- pk1;
  }
    
  proc distinguish(kc : key_t * ctxt_t) : bool = {
    var b : bool;
    
    b <@ A.distinguish(pkc0, pkc1, kc);
    
    return b;
  }
}.

(** 
  Equivalence between ANO_CPA (for arbitrary adversary) and ANO_CCA1 
  (with above reduction adverary) for an ANO_CCA1 adversary (shows ANO_CCA1 --> ANO_CPA).
**)
equiv Eqv_ANOCPA_ANOCCA1 (S <: Scheme{-R_ANOCCA1_ANOCPA}) 
                       (A <: Adv_ANOCPA{-S}) :
  ANO_CPA(S, A).main ~ ANO_CCA1(S, O_CCA1_Default(S), O_CCA1_DDefault(S), R_ANOCCA1_ANOCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. by proc; inline *; sim. qed.


(** Reduction adversary reducing ANO-CCA to ANO-CPA **)
module (R_ANOCCA_ANOCPA (A : Adv_ANOCPA) : Adv_ANOCCA) (O0 : Oracles_CCA, O1 : Oracles_CCA) = { 
  proc distinguish(pk0 : pk_t, pk1 : pk_t, kc : key_t * ctxt_t) : bool = {
    var b : bool;
    
    b <@ A.distinguish(pk0, pk1, kc);
    
    return b;
  }
}.

(** 
  Equivalence between ANO_CPA (for arbitrary adversary) and ANO_CCA
  (with above reduction adverary) for an ANO_CCA adversary (shows ANO_CCA --> ANO_CPA).
**)
equiv Eqv_ANOCPA_ANOCCA (S <: Scheme) 
                        (A <: Adv_ANOCPA{-O_CCA2_Default, -O_CCA2_DDefault, -S}) :
  ANO_CPA(S, A).main ~ ANO_CCA(S, O_CCA2_Default(S), O_CCA2_DDefault(S), R_ANOCCA_ANOCPA(A)).main :
    ={glob S, glob A} ==> ={res}.
proof. 
proc; inline *. 
wp; call (: true); wp; call (: true).
by rnd; call (: true); call (: true); skip => /> b _ -[]. 
qed. 


end Relations.
