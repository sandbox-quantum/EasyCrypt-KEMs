(*^
  This library generically defines Key Encapsulation Mechanisms (KEMs)
  and their properties (both correctness and security).
  For convenience, it also provides some sensible defaults, particularly for oracles.
  Most of the content is based on relevant literature.
  More precisely, (almost) all of the content is extracted from 
  one or more of the following papers (in no particular order):
  - [Design and Analysis of Practical Public-Key Encryption Schemes Secure against Adaptive Chosen Ciphertext Attack](https://eprint.iacr.org/2001/108)
  - [On the Equivalence of Several Security Notions of Key Encapsulation Mechanism](https://eprint.iacr.org/2006/268)
  - [KEM/DEM: Necessary and Sufficient Conditions for Secure Hybrid Encryption](https://eprint.iacr.org/2006/265)
  - [Keeping Up with the KEMs: Stronger Security Notions for KEMs and Automated Analysis of KEM-based Protocols](https://eprint.iacr.org/2023/1933)
  - [Unbindable Kemmy Schmidt: ML-KEM is neither MAL-BIND-K-CT nor MAL-BIND-K-PK](https://eprint.iacr.org/2024/523)
  - [On the Complete Non-Malleability of the Fujisaki-Okamoto Transform](https://eprint.iacr.org/2022/1654)
    (TODO: Add complete non-malleability)
^*)

(* Require/Import libraries *)
require import AllCore List DBool.


(* Types *)
(** Public keys (asymmetric) **)
type pk_t.

(** Secret keys (asymmetric) **)
type sk_t.

(** Shared/session keys (symmetric) **)
type key_t.

(** Ciphertexts/Encapsulations **)
type ctxt_t.


(* Schemes *)
(** KEM (interface) **)
module type Scheme = {
  proc keygen() : pk_t * sk_t
  proc encaps(pk : pk_t) : key_t * ctxt_t
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option 
}.


(* Correctness*)
(** Correctness program/game **)
module Correctness (S : Scheme) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k : key_t;
    var c : ctxt_t;
    var k' : key_t option;
    
    (pk, sk) <@ S.keygen();
    (k, c) <@ S.encaps(pk);
    k' <@ S.decaps(sk, c);
    
    return k' = Some k;
  }
}.


(* Security *)
(* Attacker capabilities/models *)
(* 
  Chosen-Plaintext Attacks (CPA).
  The adversary is given the considered public key and, hence, 
  is able to produce encapsulations, i.e., (symmetric) key/ciphertext pairs. 
  (Typically, this means the adversary can construct ciphertexts
   corresponding to chosen (symmetric) keys.)
*)

(* 
  non-adaptive Chosen-Ciphertext Attacks (CCA1)
  The adversary is given the considered public key and access to a decryption oracle
  *before* the stage in which it is expected to distinguish/return a break.
  Hence, the adversary is able to produce encapsulations
  *and* query for decryptions of chosen ciphertexts.
*)
(* Oracles *)
(** Interface for oracles employed in CCA1 security games **)
module type Oracles_CCA1i = {
  proc init(sk_init : sk_t) : unit
  proc decaps(c : ctxt_t) : key_t option
}.

(** A default implementation for the oracles employed in CCA1 security games **)
module O_CCA1_Default (S : Scheme) : Oracles_CCA1i = {
  var sk : sk_t
  var qs : (ctxt_t * key_t option) list
  
  proc init(sk_init : sk_t) = {
    sk <- sk_init;
    qs <- [];
  }
  
  proc decaps(c : ctxt_t) : key_t option = {
    var k : key_t option;
    
    k <@ S.decaps(sk, c);
    
    qs <- rcons qs (c, k);
    
    return k;
  }
}.

(* 
  adaptive Chosen-Ciphertext Attacks (Traditional: CCA2, Modern : CCA)
  The adversary is given the considered public key and access to a decryption oracle throughout.  
  Hence, the adversary is able to produce encapsulations
  *and* query for decryptions of chosen ciphertexts (potentially barring ciphertexts
  that are part of the challenge).
  Traditionally, this was analogous to CCA2 security for PKE schemes, meaning there were
  two adversary stages: one before receiving the challenge (given a public key and access to a 
  non-restricted decapsulation oracle), and one after receiving the challenge (given access to a
  restricted decapsulation oracle, i.e., one that prohibited querying the challenge).
  Over time, the formalization shifted toward only considering the second adversary stage 
  (provding the public key(s) to this stage as well).
  Here, we denote the traditional one by CCA2 (as we do for PKE schemes), and the modern one by CCA.
*)
(** Interface for oracles employed in CCA2 (CCA) security games **)
module type Oracles_CCA2i = {
  proc init(sk_init : sk_t, c'_init : ctxt_t) : unit
  proc decaps(c : ctxt_t) : key_t option
}.

(** A default implementation for the oracles employed in (the second stage of) CCA2 (CCA) security games **)
module O_CCA2_Default (S : Scheme) : Oracles_CCA2i = {
  var sk : sk_t
  var c' : ctxt_t 
  var qs : (ctxt_t * key_t option) list
  
  proc init(sk_init : sk_t, c'_init : ctxt_t) = {
    sk <- sk_init;
    c' <- c'_init;
    qs <- [];
  }
  
  proc decaps(c : ctxt_t) : key_t option = {
    var k : key_t option;
    
    if (c <> c') {
      k <@ S.decaps(sk, c);
    } else {
      k <- None;
    }
    
    qs <- rcons qs (c, k);
        
    return k;
  }
}.

(**
  Interface for oracles given to the adversary in any CCA security games 
  (i.e., CCA1, traditional CCA2, and modern CCA2) 
**)
module type Oracles_CCA = {
  include Oracles_CCA2i [-init]
}.


(* 
  One-Wayness (OW).
  The adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(*
  One-Wayness under Chosen-Plaintext Attacks (OW-CPA).
  In a CPA setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CPA **)
module type Adv_OWCPA = {
  proc find(pk : pk_t, c : ctxt_t) : key_t 
}.

(** OW-CPA security game **)
module OW_CPA (S : Scheme, A : Adv_OWCPA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    
    k' <@ A.find(pk, c);
    
    return k' = k; 
  }
}.


(*
  One-Wayness under non-adaptive Chosen-Ciphertext Attacks (OW-CCA1).
  In a CCA1 setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CCA1 **)
module type Adv_OWCCA1 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit { O.decaps } 
  proc find(c : ctxt_t) : key_t { }
}.

(** OW-CCA1 security game **)
module OW_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_OWCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    
    k' <@ A(O).find(c);
    
    return k' = k; 
  }
}.


(*
  One-Wayness under (traditional) adaptive Chosen-Ciphertext Attacks (OW-CCA2).
  In a (traditional) CCA2 setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CCA2 **)
module type Adv_OWCCA2 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit
  proc find(c : ctxt_t) : key_t
}.

(** OW-CCA2 security game **)
module OW_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_OWCCA2) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    O2.init(sk, c);
    
    k' <@ A(O2).find(c);
    
    return k' = k; 
  }
}.


(*
  One-Wayness under (modern) adaptive Chosen-Ciphertext Attacks (OW-CCA).
  In a (modern) CCA2 setting, the adversary is asked to produce the (symmetric) key
  encapsulated by a given ciphertext.
*)
(** Adversary class considered for OW-CCA (i.e., modern OW-CCA2) **)
module type Adv_OWCCA (O : Oracles_CCA) = { 
  proc find(pk : pk_t, c : ctxt_t) : key_t
}.

(** OW-CCA (i.e., modern OW-CCA2) security game **)
module OW_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_OWCCA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    O.init(sk, c);
    
    k' <@ A(O).find(pk, c);
    
    return k' = k; 
  }
}.


(**
  (ciphertext) INDistinguishability (IND). 
  The adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkey).
**)
abstract theory IND.
(* Distributions *)
(** (Sub-)Distribution over (symmetric) keys **)
op dkey : key_t distr.


(*
  (ciphertext) INDistinguishability under Chosen-Plaintext Attacks (IND-CPA).
  In a CPA setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkey).
*)
(** Adversary class considered for IND-CPA **)
module type Adv_INDCPA = { 
  proc distinguish(pk : pk_t, k : key_t, c : ctxt_t) : bool 
}.

(** IND-CPA security game (sampled bit) **)
module IND_CPA (S : Scheme, A : Adv_INDCPA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    b <$ {0,1};
    
    b' <@ A.distinguish(pk, if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CPA security game (provided bit) **)
module IND_CPA_P (S : Scheme, A : Adv_INDCPA) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    b' <@ A.distinguish(pk, if b then k' else k, c);
    
    return b'; 
  }
}.


(*
  (ciphertext) INDistinguishability under non-adaptive Chosen-Ciphertext Attacks (IND-CCA1).
  In a CCA1 setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkey).
*)
(** Adversary class considered for IND-CCA1 **)
module type Adv_INDCCA1 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit { O.decaps } 
  proc distinguish(k : key_t, c : ctxt_t) : bool { }
}.

(** IND-CCA1 security game (sampled bit) **)
module IND_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_INDCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    b <$ {0,1};
    
    b' <@ A(O).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CCA1 security game (provided bit) **)
module IND_CCA1_P (S : Scheme, O : Oracles_CCA1i, A : Adv_INDCCA1) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    b' <@ A(O).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.


(*
  (ciphertext) INDistinguishability under (traditional) adaptive Chosen-Ciphertext Attacks (IND-CCA2).
  In a (traditional) CCA2 setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkey).
*)
(** Adversary class considered for IND-CCA2 **)
module type Adv_INDCCA2 (O : Oracles_CCA) = { 
  proc scout(pk : pk_t) : unit
  proc distinguish(k : key_t, c : ctxt_t) : bool
}.

(** IND-CCA2 security game (sampled bit) **)
module IND_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_INDCCA2) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O2.init(sk, c);
    
    b <$ {0,1};
    
    b' <@ A(O2).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CCA2 security game (provided bit) **)
module IND_CCA2_P (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_INDCCA2) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O2.init(sk, c);
    
    b' <@ A(O2).distinguish(if b then k' else k, c);
    
    return b' = b; 
  }
}.


(*
  (ciphertext) INDistinguishability under (modern) adaptive Chosen-Ciphertext Attacks (IND-CCA2).
  In a (modern) CCA2 setting, the adversary is asked to determine whether a given
  (symmetric) key is (1) encapsulated by a given ciphertext or (2) independently
  sampled at random (from dkey).
*)
(** Adversary class considered for IND-CCA (i.e., modern IND-CCA2) **)
module type Adv_INDCCA (O : Oracles_CCA) = {
  proc distinguish(pk : pk_t, k : key_t, c : ctxt_t) : bool
}.

(** IND-CCA (i.e., modern IND-CCA2) security game (sampled bit) **)
module IND_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_INDCCA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O.init(sk, c);
    
    b <$ {0,1};
    
    b' <@ A(O).distinguish(pk, if b then k' else k, c);
    
    return b' = b; 
  }
}.

(** IND-CCA (i.e., modern IND-CCA2) security game (provided bit) **)
module IND_CCA_P (S : Scheme, O : Oracles_CCA2i, A : Adv_INDCCA) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var k, k' : key_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O.init(sk, c);
    
    b' <@ A(O).distinguish(pk, if b then k' else k, c);
    
    return b' = b; 
  }
}.

end IND.


(** 
  (ciphertext) Non-Malleability (NM).
  Given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
  
  (ciphertext) Strong Non-Malleability (SNM)
  As NM-CPA, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
**)
abstract theory NM.
(* Distributions *)
(** (Sub-)Distribution over (symmetric) keys **)
op dkey : key_t distr.

(*
  (ciphertext) Non-Malleability under Chosen-Plaintext Attacks (NM-CPA).
  In a CPA setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CPA **)
module type Adv_NMCPA = {
  proc find(pk : pk_t, c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** NM-CPA security game (sampled bit) **)
module NM_CPA (S : Scheme, A : Adv_NMCPA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    (rel, cl) <@ A.find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CPA security game (provided bit) **)
module NM_CPA_P (S : Scheme, A : Adv_NMCPA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    (rel, cl) <@ A.find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under Chosen-Plaintext Attacks (SNM-CPA).
  As NM-CPA, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CPA **)
module type Adv_SNMCPA = {
  proc find(pk : pk_t, c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** SNM-CPA security game (sampled bit) **)
module SNM_CPA (S : Scheme, A : Adv_SNMCPA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    o <$ {0,1};
    (rel, cl) <@ A.find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CPA security game (provided bit) **)
module SNM_CPA_P (S : Scheme, A : Adv_SNMCPA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    o <$ {0,1};
    (rel, cl) <@ A.find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.


(*
  (ciphertext) Non-Malleability under non-adaptive Chosen-Ciphertext Attacks (NM-CCA1).
  In a CCA1 setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CCA1 **)
module type Adv_NMCCA1 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit { O.decaps }
  proc find(c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list { }
}.

(** NM-CCA1 security game (sampled bit) **)
module NM_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_NMCCA1) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    (rel, cl) <@ A(O).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CCA1 security game (provided bit) **)
module NM_CCA1_P (S : Scheme, O : Oracles_CCA1i, A : Adv_NMCCA1) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    
    (rel, cl) <@ A(O).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under non-adaptive Chosen-Ciphertext Attacks (SNM-CCA1).
  As NM-CCA1, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CCA1 **)
module type Adv_SNMCCA1 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit { O.decaps }
  proc find(c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list { }
}.

(** SNM-CCA1 security game (sanmpled bit) **)
module SNM_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_SNMCCA1) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
        
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;

    o <$ {0,1};
    (rel, cl) <@ A(O).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CCA1 security game (provided bit) **)
module SNM_CCA1_P (S : Scheme, O : Oracles_CCA1i, A : Adv_SNMCCA1) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
        
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;

    o <$ {0,1};
    (rel, cl) <@ A(O).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }

    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.


(*
  (ciphertext) Non-Malleability under (traditional) adaptive Chosen-Ciphertext Attacks (NM-CCA2).
  In a (traditional) CCA2 setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CCA2 **)
module type Adv_NMCCA2 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit
  proc find(c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** NM-CCA2 security game (sampled bit) **)
module NM_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_NMCCA2) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O2.init(sk, c);
    
    (rel, cl) <@ A(O2).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CCA2 security game (provided bit) **)
module NM_CCA2_P (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_NMCCA2) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
        
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O2.init(sk, c);
    
    (rel, cl) <@ A(O2).find(c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under (traditional) adaptive Chosen-Ciphertext Attacks (SNM-CCA2).
  As NM-CCA2, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CCA2 **)
module type Adv_SNMCCA2 (O : Oracles_CCA) = {
  proc scout(pk : pk_t) : unit
  proc find(c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** SNM-CCA2 security game **)
module SNM_CCA2 (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_SNMCCA2) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);

    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O2.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O2).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CCA2 security game (provided bit) **)
module SNM_CCA2_P (S : Scheme, O1 : Oracles_CCA1i, O2 : Oracles_CCA2i, A : Adv_SNMCCA2) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);

    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O2.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O2).find(c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.


(*
  (ciphertext) Non-Malleability under (modern) adaptive Chosen-Ciphertext Attacks (NM-CCA).
  In a (modern) CCA2 setting, given a ciphertext (encapsulating some key K), the adversary is 
  asked to provide a relation R and a list of ciphertexts such that the (symmetric) keys 
  resulting from decapsulating the ciphertexts (in the list) are related (through R) with
  K (significantly) more often than with a (symmetric) key that is independently sampled
  at random.
*)
(** Adversary class considered for NM-CCA (i.e., modern NM-CCA2) **)
module type Adv_NMCCA (O : Oracles_CCA) = {
  proc find(pk : pk_t, c : ctxt_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** NM-CCA (i.e., modern NM-CCA2) security game (sampled bit) **)
module NM_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_NMCCA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O.init(sk, c);
    
    (rel, cl) <@ A(O).find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** NM-CCA (i.e., modern NM-CCA2) security game (provided bit) **)
module NM_CCA_P (S : Scheme, O : Oracles_CCA2i, A : Adv_NMCCA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
        
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O.init(sk, c);
    
    (rel, cl) <@ A(O).find(pk, c);
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(*
  (ciphertext) Strong Non-Malleability under (modern) adaptive Chosen-Ciphertext Attacks (SNM-CCA).
  As NM-CCA, but the adversary is additionally given a pair of (symmetric) keys of
  which one is independently sampled at random, and the other is the one
  encapsulated by the given ciphertext. (The order in which they appear in the pair
  is (uniformly) random).
*)
(** Adversary class considered for SNM-CCA (i.e., modern SNM-CCA2) **)
module type Adv_SNMCCA (O : Oracles_CCA) = {
  proc find(pk : pk_t, c : ctxt_t, kk : key_t * key_t) : (key_t -> key_t option list -> bool) * ctxt_t list
}.

(** SNM-CCA (i.e., modern SNM-CCA2) security game **)
module SNM_CCA (S : Scheme, O : Oracles_CCA2i, A : Adv_SNMCCA) = {
  proc main() = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var b, o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O).find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    b <$ {0,1};
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

(** SNM-CCA (i.e., modern SNM-CCA2) security game **)
module SNM_CCA_P (S : Scheme, O : Oracles_CCA2i, A : Adv_SNMCCA) = {
  proc main(b : bool) = {
    var pk : pk_t;
    var sk : sk_t;
    var k, k' : key_t;
    var c : ctxt_t;
    var rel : key_t -> key_t option list -> bool;
    var cl : ctxt_t list;
    var ko : key_t option;
    var kol : key_t option list;
    var o : bool;
    
    (pk, sk) <@ S.keygen();
    
    (k, c) <@ S.encaps(pk);
    k' <$ dkey;
    O.init(sk, c);

    o <$ {0,1};
    (rel, cl) <@ A(O).find(pk, c, if o then (k', k) else (k, k'));
    
    kol <- [];
    while (size kol < size cl) {
      ko <@ S.decaps(sk, nth witness cl (size kol));
      kol <- rcons kol ko;
    }
    
    return !(c \in cl) /\ rel (if b then k' else k) kol;
  }
}.

end NM.


(* 
  ANOnymity (ANO).
  The adversary is given two (honestly generated) public keys and an encapsulation 
  (i.e., ciphertext/key pair), and asked to determine which public key was used to
  create the encapsulation.
*)
(*
  ANOnymity under Chosen-Plaintext attack (ANO-CPA).
  In a CPA setting, The adversary is given two (honestly generated) public keys 
  and an encapsulation (i.e., key/ciphertext pair), and asked to determine which 
  public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CPA **)
module type Adv_ANOCPA = {
  proc distinguish(pk0 : pk_t, pk1 : pk_t, kc : key_t * ctxt_t) : bool
}.

(** ANO-CPA security game (sampled bit) **)
module ANO_CPA (S : Scheme, A : Adv_ANOCPA) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    b <$ {0,1};
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A.distinguish(pk0, pk1, kc);
    
    return b' = b;
  }
}.

(** ANO-CPA security game (provided bit) **)
module ANO_CPA_P (S : Scheme, A : Adv_ANOCPA) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A.distinguish(pk0, pk1, kc);
    
    return b';
  }
}.


(*
  ANOnymity under non-adaptive Chosen-Plaintext attack (ANO-CCA1).
  In a CCA1 setting, the adversary is given (in the first stage) two (honestly generated) public keys 
  and (in the second stage) an encapsulation (i.e., key/ciphertext pair), and is 
  asked to determine which public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CCA1 **)
module type Adv_ANOCCA1 (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc scout(pk0 : pk_t, pk1 : pk_t) : unit{ O0.decaps, O1.decaps }
  proc distinguish(kc : key_t * ctxt_t) : bool { }
}.

(** ANO-CCA1 security game (sampled bit) **)
module ANO_CCA1 (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_ANOCCA1) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var c : ctxt_t;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    A(O0, O1).scout(pk0, pk1);
    
    b <$ {0,1};
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A(O0, O1).distinguish(kc);
    
    return b' = b;
  }
}.

(** ANO-CCA1 security game (provided bit) **)
module ANO_CCA1_P (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_ANOCCA1) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var c : ctxt_t;
    var kc : key_t * ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O0.init(sk0);
    O1.init(sk1);
    
    A(O0, O1).scout(pk0, pk1);
    
    kc <@ S.encaps(if b then pk1 else pk0);
    
    b' <@ A(O0, O1).distinguish(kc);
    
    return b';
  }
}.


(*
  ANOnymity under (traditional) adaptive Chosen-Plaintext attack (ANO-CCA2).
  In a (traditional) CCA2 setting, the adversary is given (in the first stage) two 
  (honestly generated) public keys and (in the second stage) an encapsulation 
  (i.e., key/ciphertext pair), and is 
  asked to determine which public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CCA2 **)
module type Adv_ANOCCA2 (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc scout(pk0 : pk_t, pk1 : pk_t) : unit
  proc distinguish(kc : key_t * ctxt_t) : bool
}.

(** ANO-CCA2 security game (sampled bit) **)
module ANO_CCA2 (S : Scheme)
                (O01 : Oracles_CCA1i, O11 : Oracles_CCA1i)
                (O02 : Oracles_CCA2i, O12 : Oracles_CCA2i)
                (A : Adv_ANOCCA2) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O01.init(sk0);
    O11.init(sk1);
    
    A(O01, O11).scout(pk0, pk1);
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O02.init(sk0, c);
    O12.init(sk1, c);
    
    b' <@ A(O02, O12).distinguish((k, c));
    
    return b' = b;
  }
}.

(** ANO-CCA2 security game (provided bit) **)
module ANO_CCA2_P (S : Scheme)
                  (O01 : Oracles_CCA1i, O11 : Oracles_CCA1i)
                  (O02 : Oracles_CCA2i, O12 : Oracles_CCA2i)
                  (A : Adv_ANOCCA2) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    O01.init(sk0);
    O11.init(sk1);
    
    A(O01, O11).scout(pk0, pk1);
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O02.init(sk0, c);
    O12.init(sk1, c);
    
    b' <@ A(O02, O12).distinguish((k, c));
    
    return b';
  }
}.


(*
  ANOnymity under (modern) adaptive Chosen-Plaintext attack (ANO-CCA).
  In a (modern) CCA setting, the adversary is given (in the first stage) two 
  (honestly generated) public keys and (in the second stage) an encapsulation 
  (i.e., key/ciphertext pair), and is 
  asked to determine which public key was used to create the encapsulation.
*)
(** Adversary class considerd for ANO-CCA (i.e., modern ANO-CCA2) **)
module type Adv_ANOCCA (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc distinguish(pk0 : pk_t, pk1 : pk_t, kc : key_t * ctxt_t) : bool
}.

(** ANO-CCA (i.e., modern ANO-CCA2) security game (sampled bit) **)
module ANO_CCA (S : Scheme)
               (O0 : Oracles_CCA2i, O1 : Oracles_CCA2i)
               (A : Adv_ANOCCA) = {
  proc main() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b, b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    b <$ {0,1};
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O0.init(sk0, c);
    O1.init(sk1, c);
    
    b' <@ A(O0, O1).distinguish(pk0, pk1, (k, c));
    
    return b' = b;
  }
}.

(** ANO-CCA (i.e., modern ANO-CCA2) security game (provided bit) **)
module ANO_CCA_P (S : Scheme)
                 (O0 : Oracles_CCA2i, O1 : Oracles_CCA2i)
                 (A : Adv_ANOCCA) = {
  proc main(b : bool) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var b' : bool;
    var k : key_t;
    var c : ctxt_t;
    
    (pk0, sk0) <@ S.keygen();
    (pk1, sk1) <@ S.keygen();
    
    (k, c) <@ S.encaps(if b then pk1 else pk0);
    O0.init(sk0, c);
    O1.init(sk1, c);
    
    b' <@ A(O0, O1).distinguish(pk0, pk1, (k, c));
    
    return b' = b;
  }
}.


(*
  BINDing (BIND).
  Intuitively, binding properties capture to which extent certain artifacts (in a 
  a non-failing KEM execution) uniquely determine other artifacts (in that same execution). 
  That is, given the values of certain artifacts (e.g., the public key and ciphertext) produced
  by honest execution of the KEM, it is hard to find different
  values for some other artifact (e.g., the symmetric key) that would all
  result in non-failing executions. Here, "non-failing" refers to the fact that the decapsulations
  do not fail (and, hence, return a proper (symmetric) key).
  For example, if a particular KEM has the property that "the ciphertext binds 
  the (symmetric) key", this means that whenever a particular ciphertext C is created
  with this KEM, it is hard to find different symmetric keys K0 and K1 such that C can
  (validly) decapsulate to K0 *and* K1 (under different secret keys).
*)
(* Types *)
(** Binding configurations considered **)
type bindconf = [
    K_Binds_PK
  | K_Binds_CT
  | CT_Binds_K
  | CT_Binds_PK
  | KCT_Binds_PK
  | PKK_Binds_CT
  | PKCT_Binds_K
].


(* Operators *)
(** 
  Checks whether binding configuration considers
  the public key as a binding source element 
**)
op is_pkbc (bc : bindconf) =
  bc = PKK_Binds_CT \/ bc = PKCT_Binds_K.

(** 
  Checks whether the provided values consitute a binding break w.r.t. the
  given binding configuration.
**)
(** 
  Specifically, if the configuration is P_Binds_Q, then the provided values consitute
  a binding break iff the similarly-typed values (for the artifacts) in P are equal 
  *and* there exist similarly-typed values (for the artifacts) in Q that are unequal. 
**)
(**
  Note that this does not include the check concerning the validity of the (symmetric)
  keys (i.e., success of the decapsulations); this is delegated to the security games.
**)
op is_bindbreak (bc : bindconf) (k0 k1 : key_t) (pk0 pk1 : pk_t) (c0 c1 : ctxt_t) =
  with bc = K_Binds_PK => k0 = k1 /\ pk0 <> pk1
  with bc = K_Binds_CT => k0 = k1 /\ c0 <> c1
  with bc = CT_Binds_K => c0 = c1 /\ k0 <> k1  
  with bc = CT_Binds_PK => c0 = c1 /\ pk0 <> pk1
  with bc = KCT_Binds_PK => k0 = k1 /\ c0 = c1 /\ pk0 <> pk1
  with bc = PKK_Binds_CT => pk0 = pk1 /\ k0 = k1 /\ c0 <> c1
  with bc = PKCT_Binds_K => pk0 = pk1 /\ c0 = c1 /\ k0 <> k1.


(* 
  HONestly BINDing (HON-BIND).
  Binding properties where the adversary is given two honestly generated public keys,
  as well as a decapsulation oracle with which it can decapsulate
  w.r.t. the corresponding secret keys.
*)
(** Adversary class considered for HON-BIND **)
module type Adv_HONBIND (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc find(pk0 : pk_t, pk1 : pk_t) : ctxt_t * ctxt_t
}.

(** HON-BIND security game (specific configuration is passed to the procedure) **)
module HON_BIND (S : Scheme, O0 : Oracles_CCA1i, O1 : Oracles_CCA1i, A : Adv_HONBIND) = {
  proc main(bc : bindconf) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t option;
    var no_fail: bool;
    
    (pk0, sk0) <@ S.keygen();
    
    if (is_pkbc bc) { 
      (pk1, sk1) <- (pk0, sk0);
    } else {
      (pk1, sk1) <@ S.keygen();
    }
    
    O0.init(sk0);
    O1.init(sk1);
    
    (c0, c1) <@ A(O0, O1).find(pk0, pk1);
    
    k0 <@ S.decaps(sk0, c0);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k0 <> None /\ k1 <> None;
    
    return no_fail /\ is_bindbreak bc (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.


(*
  LEAKingly BINDing (LEAK-BIND).
  Binding properties where the adversary is given two
  honestly generated (asymmetric) key pairs.
*)
(** Adversary class considered for LEAK-BIND **)
module type Adv_LEAKBIND= {
  proc find(pk0 : pk_t, sk0 : sk_t, pk1 : pk_t, sk1 : sk_t) : ctxt_t * ctxt_t
}.

(** LEAK-BIND security game (specific configuration is passed to the procedure) **)
module LEAK_BIND (S : Scheme, A : Adv_LEAKBIND) = {
  proc main(bc : bindconf) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t option;
    var no_fail : bool;
    
    (pk0, sk0) <@ S.keygen();
    
    if (is_pkbc bc) { 
      (pk1, sk1) <- (pk0, sk0);
    } else {
      (pk1, sk1) <@ S.keygen();
    }
    
    (c0, c1) <@ A.find(pk0, sk0, pk1, sk1);
    
    k0 <@ S.decaps(sk0, c0);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k0 <> None /\ k1 <> None;
    
    return no_fail /\ is_bindbreak bc (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.


(*
  TODO:
  Want to split Decaps/Decaps, Encaps/Decaps, Encaps/Encaps cases?
  Seems cleaner (also because it seems to model slightly different scenarios?)
  However, can combine if better.
*)
(**
  MALiciously BINDing (MAL-BIND).
  Binding properties where the adversary provides the 
  considered (asymmetric) key material itself.
**)
abstract theory MALBIND.
(* Operators *)
(** Derives (honestly) the public key corresponding to a secret key **)
(** 
  Using this, we can let the adversary (in the MAL-BIND properties) only provide
  the to-be-considered (asymmetric) secret keys, and then honestly compute
  the corresponding public key ourselves. This allows
  us to meaningfully include binding properties involving the public key.
**)
(** 
  Note: for the properties to make sense, this operator 
  should be instantiated to something that actually derives
  public keys from (honestly generated) secret keys for the considered KEM. 
**)
op sk2pk : sk_t -> pk_t.


(* 
  MALiciously BINDing w.r.t. Decapsulation/Decapsulation (MAL-BIND-DD).
  In a MAL-BIND setting, the adversary is asked to provide two ciphertext
  (to be decapsulated) as to induce a binding break (w.r.t. the considered configuration).
*)
(** Adversary class considered for MAL-BIND-DD **)
module type Adv_MALBIND_DD = {
  proc find() : sk_t * sk_t * ctxt_t * ctxt_t
}.

(** MAL-BIND-DD security game (specific configuration is passed to the procedure) **)
module MAL_BIND_DD (S : Scheme, A : Adv_MALBIND_DD) = {
  proc main(bc : bindconf) : bool = {
    var sk0, sk1 : sk_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t option;
    var pk0, pk1 : pk_t;
    var no_fail : bool;
    
    (sk0, sk1, c0, c1) <@ A.find();
    
    pk0 <- sk2pk sk0;
    pk1 <- sk2pk sk1;
    
    k0 <@ S.decaps(sk0, c0);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k0 <> None /\ k1 <> None;
    
    return no_fail /\ is_bindbreak bc (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.


(*
  In the remaining MAL-BIND properties, the adversary is asked to provide 
  the randomness used in encapsulation(s). That is, these properties need 
  to consider "derandomized" encapsulation procedures, taking the randomness 
  as additional input (instead of generating it on the fly).
  To this end, we specify a module type for KEMs that is identical to the 
  original one with an appropriately adjusted encapsulation procedure.
  Be aware that the following properties only make sense for KEMs of which
  the encapsulation procedure actually employs the provided randomness.
  (This is not actually enforced by the module type.)
*)
(* Types *)
(** Randomness (for encapsulation procedure) **)
type rand_t.


(* Module types *)
(** "Derandomized" KEM (interface) **)
module type SchemeDerand = {
  include Scheme [-encaps]
  proc encaps(pk : pk_t, r : rand_t) : key_t * ctxt_t
}.


(*
  MALiciously BINDing w.r.t. Encapsulation/Decapsulation (MAL-BIND-ED)
  In a MAL-BIND setting, the adversary is asked to provide 
  randomness and a ciphertext (to be used in encapsulation and 
  decapsulation, respectively) as to induce a binding break 
  (w.r.t. the considered configuration).
*)
(** Adversary class considered for MAL-BIND-ED **)
module type Adv_MALBIND_ED = {
  proc find() : sk_t * sk_t * rand_t * ctxt_t
}.

(** MAL-BIND-ED security game (specific configuration is passed to the procedure) **)
module MAL_BIND_ED (S : SchemeDerand, A : Adv_MALBIND_ED) = {
  proc main(bc : bindconf) : bool = {
    var sk0, sk1 : sk_t;
    var r : rand_t;
    var c0, c1 : ctxt_t;
    var k0 : key_t;
    var k1 : key_t option;
    var pk0, pk1 : pk_t;
    var no_fail : bool;
    
    (sk0, sk1, r, c1) <@ A.find();
    
    pk0 <- sk2pk sk0;
    pk1 <- sk2pk sk1;
    
    (k0, c0) <@ S.encaps(pk0, r);
    k1 <@ S.decaps(sk1, c1);
    
    no_fail <- k1 <> None;
    
    return no_fail /\ is_bindbreak bc k0 (oget k1) pk0 pk1 c0 c1;
  }
}.


(*
  MALiciously BINDing w.r.t. Encapsulation/Encapsulation (MAL-BIND-EE)
  In a MAL-BIND setting, the adversary is asked to provide
  randomness (to be used in encapsulations) as to induce a binding break 
  (w.r.t. the considered configuration).
*)
(** Adversary class considered for MAL-BIND-EE **)
module type Adv_MALBIND_EE = {
  proc find() : sk_t * sk_t * rand_t * rand_t
}.

(** MAL-BIND-EE security game (specific configuration is passed to the procedure) **)
module MAL_BIND_EE (S : SchemeDerand, A : Adv_MALBIND_EE) = {
  proc main(bc : bindconf) : bool = {
    var sk0, sk1 : sk_t;
    var r0, r1 : rand_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t;
    var pk0, pk1 : pk_t;
    
    (sk0, sk1, r0, r1) <@ A.find();
    
    pk0 <- sk2pk sk0;
    pk1 <- sk2pk sk1;
    
    (k0, c0) <@ S.encaps(pk0, r0);
    (k1, c1) <@ S.encaps(pk1, r1);

    return is_bindbreak bc k0 k1 pk0 pk1 c0 c1;
  }
}.

end MALBIND.
