(*^ 
  Binding security for (very) high-level specification of ML-KEM.
  Specification considered here abstracts away from any algebraic
  structure used in the construction, particularly 
  viewing the PKE procedures as abstract (black box) operators.
  To be instantiated and linked to lower-level specification
  and, in turn, implementation.
^*)
(* Require/Import *)
require import AllCore Distr PROM FMap.
require (*--*) ROM ROMx2.
require (*--*) DMap DProd.
require (*--*) HashFunctions KeyedHashFunctions KeyEncapsulationMechanismsROMx2.


(* Types *)
(* General *)
(** Randomness ("seeds") **)
type rand_t.


(* Underlying PKE scheme (K-PKE) *)
(** Public keys **)
type pk_t_pke.

(** Secret keys **)
type sk_t_pke.

(** Plaintexts of underlying PKE scheme **)
type ptxt_t = rand_t.

(** Ciphertexts **)
type ctxt_t_pke.


(* KEM (ML-KEM) *)
(** Public keys **)
type pk_t = pk_t_pke.

(** Secret keys  **)
type sk_t = sk_t_pke * pk_t * rand_t * rand_t.

(** Shared/session keys (symmetric) **)
type key_t = rand_t.

(** Ciphertexts/Encapsulations **)
type ctxt_t = ctxt_t_pke.


(* Operators *)
(** Hash function G, used to compute shared key and randomness **)
op G : ptxt_t * rand_t -> key_t * rand_t.

(** Hash function H, used to hash public keys **)
op H : pk_t -> rand_t.

(** Hash function J ("keyed"), used to compute implicit rejection key **)
op J : rand_t -> ctxt_t -> key_t.

(** Operator capturing "derandomized" key generation of underlying PKE scheme **)
op kg : rand_t -> pk_t_pke * sk_t_pke.

(** Operator capturing "derandomized" encryption function of underlying PKE scheme **)
op enc : rand_t -> pk_t_pke -> ptxt_t -> ctxt_t_pke.

(** Operator capturing decryption function of underlying PKE scheme **)
(**
  By design, the underlying PKE scheme never returns a failure, 
  so we refrain from using option monad as output.
**)
op dec : sk_t_pke -> ctxt_t_pke -> ptxt_t.


(* Distributions *)
(** Proper, full, and uniform distribution over randomness **)
op [lossless full uniform] drand : rand_t distr.

(** Proper, full, and uniform distribution over (shared) keys **)
op [lossless full uniform] dkey : key_t distr.

(** Proper, full, and uniform distribution over pairs of (shared) keys and randomness **) 
op [lossless full uniform] dkeyrand : (key_t * rand_t) distr.

(** `dkeyrand` is equal to the product distribution of dkey and drand **)
lemma dkeyrand_dprod : dkeyrand = dkey `*` drand.
proof. 
rewrite &(eq_funi_ll) ?is_full_funiform ?(dkeyrand_ll, dkeyrand_fu, dkeyrand_uni).
+ by rewrite dprod_fu_auto ?(dkey_fu, drand_fu) /=. 
+ by rewrite dprod_uni 1,2:(dkey_uni, drand_uni). 
by rewrite dprod_ll_auto 1,2:(dkey_ll, drand_ll). 
qed.

(** Distribution representing key generation of underlying PKE scheme **)
op dkg : (pk_t_pke * sk_t_pke) distr = dmap drand kg.

(** `dkg` is a proper distribution **)
lemma dkg_ll : is_lossless dkg.
proof. by rewrite dmap_ll drand_ll. qed.


(* Clones/imports *)
(* 
  Definitions and properties for KEMs (in the ROM with 2 ROs) 
  with types as required for ML-KEM 
*)
clone import KeyEncapsulationMechanismsROMx2 as KEMsROMx2 with
  type pk_t <- pk_t,
  type sk_t <- sk_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t,
  
  type in_t <- ptxt_t * rand_t, 
  type out_t <- key_t * rand_t,
  type in_t2 <- rand_t * ctxt_t,
  type out_t2 <- key_t
  
  proof *.

(* Single RO and non-ROM KEM definitions consistent with above instantiation *) 
import KEMsROM KEMs.


(* Schemes (standard model) *)
(** K-PKE, PKE scheme underlying ML-KEM **)
(** 
  As per FIPS 203, we specify the PKE in a derandomized manner.
  That is, any procedure using randomness (i.e., key generation and encryption)
  takes it as input rather than sampling it itself. This also means
  it does not adhere to the regular syntax of a PKE scheme. 
**)  
(**
  Further, this is a (very) high-level specification, essentially abstracting
  away all algebraic structure and modeling the procedures as simple operators 
  (which is possible because all randomness is taken as input)
**)
module K_PKE_HL = {
  proc keygen(d : rand_t) : pk_t_pke * sk_t_pke = {
    return kg d;
  }
  
  proc enc(pk : pk_t_pke, p : ptxt_t, r : rand_t) : ctxt_t_pke = {
    return enc r pk p;
  }
  
  proc dec(sk : sk_t_pke, c : ctxt_t_pke) : ptxt_t = {
    return dec sk c;
  } 
}.


(**
  ML-KEM in the standard model.
  Closely follows FIPS 203 (without accounting for sampling failures, so 
  the "internal" ML-KEM procedures are most relevant). 
**)
module ML_KEM_HL : Scheme = { 
  proc keygen() : pk_t * sk_t = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var d, z : rand_t;
    var pk : pk_t;
    var sk : sk_t;
    
    d <$ drand;
    z <$ drand;
    
    (pk_pke, sk_pke) <@ K_PKE_HL.keygen(d);
    
    pk <- pk_pke;
    sk <- (sk_pke, pk, H pk, z);
    
    return (pk, sk);
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    var c : ctxt_t_pke;
    
    p <$ drand;
    (k, r) <- G (p, (H pk));
    
    c <@ K_PKE_HL.enc(pk, p, r);

    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    var c' : ctxt_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <@ K_PKE_HL.dec(sk_pke, c);
    
    (k', r') <- G (p', h);
    k_ <- J z c;
    
    c' <@ K_PKE_HL.enc(pk_pke, p', r');
    
    if (c <> c') {
      k' <- k_;
    }
    
    return Some k';
  }
}.



(**
  ML-KEM in the ROM, where only the G (i.e., the function for generating
  the shared key and randomness for encryption) is modeled as a RO.
  Closely follows FIPS 203 (without accounting for sampling failures, so 
  the "internal" ML-KEM procedures are most relevant). 
**)
module (ML_KEM_HL_ROM_G : Scheme_ROM) (G_RO : RandomOracle) = { 
  proc keygen() : pk_t * sk_t = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var d, z : rand_t;
    var pk : pk_t;
    var sk : sk_t;
    
    d <$ drand;
    z <$ drand;
    
    (pk_pke, sk_pke) <@ K_PKE_HL.keygen(d);
    
    pk <- pk_pke;
    sk <- (sk_pke, pk, H pk, z);
    
    return (pk, sk);
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    var c : ctxt_t_pke;
    
    p <$ drand;
    (k, r) <@ G_RO.get((p, (H pk)));
    
    c <@ K_PKE_HL.enc(pk, p, r);

    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    var c' : ctxt_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <@ K_PKE_HL.dec(sk_pke, c);
    
    (k', r') <@ G_RO.get((p', h));
    k_ <- J z c;
    
    c' <@ K_PKE_HL.enc(pk_pke, p', r');
    
    if (c <> c') {
      k' <- k_;
    }
    
    return Some k';
  }
}.



(**
  ML-KEM in the ROM, where both G (i.e., the function used to generate
  the shared key and randomness for encryption) and J (i.e., the function used to
  generate the implicit rejection key) are modeled as RO.
  Closely follows FIPS 203 (without accounting for sampling failures, so 
  the "internal" ML-KEM procedures are most relevant). 
**)
module (ML_KEM_HL_ROM_JG : Scheme_ROMx2) (J_RO : RandomOracle2) (G_RO : RandomOracle) = { 
  proc keygen() : pk_t * sk_t = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var d, z : rand_t;
    var pk : pk_t;
    var sk : sk_t;
    
    d <$ drand;
    z <$ drand;
    
    (pk_pke, sk_pke) <@ K_PKE_HL.keygen(d);
    
    pk <- pk_pke;
    sk <- (sk_pke, pk, H pk, z);
    
    return (pk, sk);
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    var c : ctxt_t_pke;
    
    p <$ drand;
    (k, r) <@ G_RO.get((p, (H pk)));
    
    c <@ K_PKE_HL.enc(pk, p, r);

    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    var c' : ctxt_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <@ K_PKE_HL.dec(sk_pke, c);
    
    (k', r') <@ G_RO.get((p', h));
    k_ <@ J_RO.get((z, c));
    
    c' <@ K_PKE_HL.enc(pk_pke, p', r');
    
    if (c <> c') {
      k' <- k_;
    }
    
    return Some k';
  }
}.


(* Alternative specifications (to facilitate proofs) *)
(** 
  Trimmed version of ML_KEM_HL_ROM_JG (e.g., inlined procedures, less variables).
  Equivalent to the standard version above (as shown in the corresponding lemmas).
**)
(**
  Besides inlining and removing variables, the sampling of randomness followed by the "derandomized" 
  key generation is replaced by directly sampling from the appropriate distribution (dkg). 
**)
module (ML_KEM_HL_ROM_JG_Trim : Scheme_ROMx2) (J_RO : RandomOracle2) (G_RO : RandomOracle) = {
  proc keygen() : pk_t * sk_t = {
    var z : rand_t;
    var sk_pke : sk_t_pke;
    var pk : pk_t;
        
    z <$ drand;
    (pk, sk_pke) <$ dkg;
    
    return (pk, (sk_pke, pk, H pk, z));
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    
    p <$ drand;
    (k, r) <@ G_RO.get((p, H pk));
     
    return (k, enc r pk p);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <- dec sk_pke c;
    
    (k', r') <@ G_RO.get((p', h));
    k_ <@ J_RO.get((z, c));
    
    return Some (if c <> enc r' pk_pke p' then k_ else k');
  }
}.


section.

(* Auxiliary clone for proving sampling equivalence *)
local clone DMap.DMapSampling as DMS with
  type t1 <- rand_t,
  type t2 <- pk_t_pke * sk_t_pke
  
  proof *.

(**
  Equivalence between key generation procedures of ML_KEM_HL_ROM_JG 
  and ML_KEM_HL_ROM_JG_Trim, for any instantiation of the oracles
**)    
equiv Eqv_ML_KEM_HL_ROM_JG_Trim_Keygen (J_RO <: RandomOracle2) (G_RO <: RandomOracle) :
  ML_KEM_HL_ROM_JG(J_RO, G_RO).keygen ~ ML_KEM_HL_ROM_JG_Trim(J_RO, G_RO).keygen : 
    true ==> ={res}.
proof. 
proc.
inline K_PKE_HL.keygen; swap{1} 1 1.
wp.
transitivity{2} { z <$ drand; (pk, sk_pke) <@ DMS.S.sample(drand, kg); } 
                (    true 
                 ==> 
                     let tpl = kg d{1} in 
                       (tpl.`1, (tpl.`2, tpl.`1, H tpl.`1, z{1})) 
                       = 
                       (pk{2}, (sk_pke{2}, pk{2}, H pk{2}, z{2}))) 
                (true ==> ={z, pk, sk_pke}) => //.
+ rewrite equiv[{2} 2 DMS.sample].
  inline{2} DMS.S.map.
  by wp; rnd; wp; rnd; skip.
inline{1} DMS.S.sample.
by wp; rnd; wp; rnd. 
qed.

end section.

(** 
  Equivalence between encapsulation procedures of ML_KEM_HL_ROM_JG 
  and ML_KEM_HL_ROM_JG_Trim, for any instantiation of the oracles
**) 
equiv Eqv_ML_KEM_HL_ROM_JG_Trim_Encaps (J_RO <: RandomOracle2) (G_RO <: RandomOracle) :
  ML_KEM_HL_ROM_JG(J_RO, G_RO).encaps ~ ML_KEM_HL_ROM_JG_Trim(J_RO, G_RO).encaps : 
    ={glob G_RO, arg} ==> ={glob G_RO, res}.
proof.
proc.
inline K_PKE_HL.enc.
by wp; sim.
qed.

(** 
  Equivalence between decapsulations procedures of ML_KEM_HL_ROM_JG 
  and ML_KEM_HL_ROM_JG_Trim
**)  
equiv Eqv_ML_KEM_HL_ROM_JG_Trim_Decaps (J_RO <: RandomOracle2) (G_RO <: RandomOracle{-J_RO}) :
  ML_KEM_HL_ROM_JG(J_RO, G_RO).decaps ~ ML_KEM_HL_ROM_JG_Trim(J_RO, G_RO).decaps : 
    ={glob G_RO, glob J_RO, arg} ==> ={glob G_RO, glob J_RO, res}.
proof.
proc.
inline K_PKE_HL.enc K_PKE_HL.dec.
by wp; call(: true); call(: true); wp.
qed.



(* Default definitions and properties for G as a random oracle *)
clone import FullRO as ROM_G with
  type in_t <- ptxt_t * rand_t,
  type out_t <- key_t * rand_t,
  
    op dout <- fun _ => dkeyrand
    
  proof *.

(* Default definitions and properties for J as a random oracle *)
clone import FullRO as ROM_J with
  type in_t <- rand_t * ctxt_t,
  type out_t <- key_t,
  
    op dout <- fun _ => dkey
    
  proof *.

(** Alias for default random oracle implementation for G **)
module G_RO = ROM_G.LRO.

(** Alias for default random oracle implementation for J **)
module J_RO = ROM_J.LRO. 


(* Reductions *)


section MLKEM_LEAKBINDKPK_ROMx2.

declare module A <: Adv_LEAKBIND_ROMx2 {-G_RO, -J_RO}.



(*
  Split sampling (of pairs) in G_RO
  two independent samplings of each element
*)
local module G_RO_SSample = {
  import var ROM_G.RO
  include G_RO [-get]
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    k <$ dkey;
    r <$ drand;
    if (ph \notin m) {
      m.[ph] <- (k, r); 
    }
    
    return oget m.[ph];
  }
}.


local clone DProd.ProdSampling as DKR with
  type t1 <- key_t,
  type t2 <- rand_t
  
  proof *.

local equiv Eqv_GRO_GROSS_Get :
  G_RO.get ~ G_RO_SSample.get : ={glob G_RO, arg} ==> ={glob G_RO, res}.
proof.
proc. 
wp; conseq (: _ ==> r{1} = (k, r){2}) => //.
transitivity{1} { r <@ DKR.S.sample(dkey, drand); } 
                (true ==> ={r})
                (true ==> r{1} = (k, r){2}) => //.
+ inline{2} DKR.S.sample; auto => />. 
  by rewrite dkeyrand_dprod.
transitivity{1} { r <@ DKR.S.sample2(dkey, drand); } 
                (true ==> ={r})
                (true ==> r{1} = (k, r){2}) => //.
+ by call (DKR.sample_sample2).
by inline{1} DKR.S.sample2; auto.
qed.  


(* 
  Alternative version of LEAK-BIND-K-PK property 
  for ML-KEM in ROM (with G modeled as a random oracle)
  with (non-RO) concrete procedures inlined, several variables 
  moved to the module level, and extraneous variables removed.
*)
local module LEAK_BINDKPK_MLKEM_ROM_JG = {
  var pk_pke0, pk_pke1 : pk_t_pke
  var sk_pke0, sk_pke1 : sk_t_pke
  var c0, c1 : ctxt_t
  var h0, h1, z0, z1, r0', r1' : rand_t
  var p0', p1' : ptxt_t 
  var k0', k1', k0_, k1_ : key_t
  var k0, k1 : key_t option
  
  proc main(bc : bindconf) : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    
    J_RO.init();
    G_RO_SSample.init();
             
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    (c0, c1) <@ A(J_RO, G_RO_SSample).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;
    (k0', r0') <@ G_RO_SSample.get((p0', H pk0));
    k0_ <@ J_RO.get((z0, c0));
    k0 <- Some (if c0 <> enc r0' pk_pke0 p0' then k0_ else k0');
    
    p1' <- dec sk_pke1 c1;
    (k1', r1') <@ G_RO_SSample.get((p1', H pk1));
    k1_ <@ J_RO.get((z1, c1));
    k1 <- Some (if c1 <> enc r1' pk_pke1 p1' then k1_ else k1');
          
    return is_bindbreak K_Binds_PK (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.

local lemma EqPr_LEAKBINDROMJG_KPK &m :
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG, A).main(K_Binds_PK) @ &m : res]
  =
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : res].
proof.
have ->:
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG, A).main(K_Binds_PK) @ &m : res]
  =
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG_Trim, A).main(K_Binds_PK) @ &m : res].
+ byequiv => //.
  proc.
  inline main init. 
  seq 5 5 : (   #pre 
             /\ ={glob J_RO, glob G_RO, pk0, sk0, bc0, bc1} 
             /\ bc0{1} = bc{1}
             /\ bc1{1} = bc{1}).
  + sp; rewrite equiv[{1} 1 (Eqv_ML_KEM_HL_ROM_JG_Trim_Keygen J_RO G_RO)]. 
    by call (: true); 1: auto.
  rcondf{1} ^if; 2: rcondt{1} ^if; 1,2: by auto. 
  rcondf{2} ^if; 2: rcondt{2} ^if; 1,2: by auto. 
  wp; do 2! call (Eqv_ML_KEM_HL_ROM_JG_Trim_Decaps J_RO G_RO).
  call (: ={glob J_RO, glob G_RO}); 1,2: by sim.
  by call (Eqv_ML_KEM_HL_ROM_JG_Trim_Keygen J_RO G_RO).
byequiv => //.
proc.
inline main init.
seq 5 6 : (   #pre 
           /\ ={glob J_RO, glob G_RO, sk0, pk0}
           /\ pk0{1} = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{2}
           /\ sk0{1}.`1 = LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0{2}
           /\ sk0{1}.`2 = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{2}
           /\ sk0{1}.`3 = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{2}
           /\ sk0{1}.`4 = LEAK_BINDKPK_MLKEM_ROM_JG.z0{2}
           /\ bc0{1} = bc{2}
           /\ bc1{1} = bc{2}).
+ by inline *; auto.
rcondf{1} ^if; 2: rcondt{1} ^if; 1,2: by auto. 
inline{1} decaps keygen.
wp; call (: ={glob J_RO}); 1: by auto. 
call Eqv_GRO_GROSS_Get.
wp; call (: ={glob J_RO}); 1: by auto.
call Eqv_GRO_GROSS_Get.
wp; call (: ={glob J_RO, glob G_RO}). 
+ by conseq Eqv_GRO_GROSS_Get.
+ by proc; auto.
by auto.
qed.

local lemma Bnd_LEAKBINDROMJG_KPK_CD &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : res]
  <=
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1' ]
  +
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : 
      LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1_ ]
  +
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
      LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1' ]  
  +
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : 
      LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1_ ].
proof.
rewrite -?RField.addrA.
rewrite Pr[mu_split (   LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1 
                     /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1')] StdOrder.RealOrder.ler_add.
+ by rewrite Pr[mu_sub].
rewrite Pr[mu_split (LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1_)] StdOrder.RealOrder.ler_add.
+ by rewrite Pr[mu_sub].
rewrite Pr[mu_split (LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1')] StdOrder.RealOrder.ler_add.
+ by rewrite Pr[mu_sub]. 
rewrite Pr[mu_split (LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1_)].
rewrite -(RField.addr0 Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1_]) StdOrder.RealOrder.ler_add.  
+ by rewrite Pr[mu_sub].
byphoare => //; hoare.
proc. 
inline get.
wp; rnd; wp; rnd; rnd; wp. 
conseq (:     _ 
          ==> 
              pk0 = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0
           /\ pk1 = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1) => [/# |]. 
inline init.
by auto; call (: true) => //; auto.
qed.


(* Case 1: k0' = k1' (i.e., first parts of G collide) *)
local clone ROMx2 as ROM_GkGk with
  type in_t1 <- ptxt_t,
  type in_t2 <- ptxt_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.


local module GW12 (RO1 : ROM_GkGk.RandomOracle1) (RO2 : ROM_GkGk.RandomOracle2) : RandomOracle = {
  var h0, h1 : rand_t 
  var m1, m2 : (ptxt_t, key_t * rand_t) fmap
  var mr : (ptxt_t * rand_t, key_t * rand_t) fmap
  
  proc init(h0_init : rand_t, h1_init : rand_t) : unit = {
    h0 <- h0_init;
    h1 <- h1_init;
    m1 <- empty;
    m2 <- empty;
    mr <- empty;
  }
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    if (ph.`2 = h0) { 
      r <$ drand;
      if (ph.`1 \notin m1) {
        k <@ RO1.get(ph.`1);
        m1.[ph.`1] <- (k, r); 
      }
      (k, r) <- oget m1.[ph.`1];  
    } elif (ph.`2 = h1) {
      r <$ drand;
      if (ph.`1 \notin m2) {
        k <@ RO2.get(ph.`1);
        m2.[ph.`1] <- (k, r); 
      }
      (k, r) <- oget m2.[ph.`1];
    } else { (* ph.`2 <> h0 /\ ph.`2 <> h1 *)
      k <$ dkey;
      r <$ drand;
      if (ph \notin mr) {
        mr.[ph] <- (k, r);
      }
      (k, r) <- oget mr.[ph];
    }
    
    return (k, r);
  }
}.
  
  
local module (R_CRROMx2GG_LEAKBINDKCT : ROM_GkGk.Adv_CRROMx2) 
             (RO1 : ROM_GkGk.RandomOracle1) (RO2 : ROM_GkGk.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : ptxt_t * ptxt_t = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    J_RO.init();
    
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    GW12(RO1, RO2).init(H pk0, H pk1);
    
    (c0, c1) <@ A(J_RO, GW12(RO1, RO2)).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;    
    p1' <- dec sk_pke1 c1;
    
    return (p0', p1');
  }
}.

local lemma Bnd_GGcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1' ]
  <=
  p_max (dmap dkg (fun (kp : pk_t_pke * sk_t_pke) => H kp.`1))
  +
  Pr[ROM_GkGk.CR_ROM_x2(ROM_GkGk.RO1_Default, ROM_GkGk.RO2_Default, R_CRROMx2GG_LEAKBINDKCT).main() @ &m : res].
proof.
rewrite Pr[mu_split H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1] StdOrder.RealOrder.ler_add.
+ byphoare => //. 
  proc.
  swap 4 -3; swap 8 -6.
  seq 2 : (H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1)
          (p_max (dmap dkg (fun (kp : pk_t_pke * sk_t_pke) => H kp.`1)))
          1%r
          _
          0%r => //.
  + rnd (fun (kp : pk_t_pke * sk_t_pke) => H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 = H kp.`1).
    rnd; skip => /> kp kpin.
    pose fnc := (fun (kp : _ * _) => _ = Top.H kp.`1). 
    rewrite (: fnc = (pred1 (H kp.`1) \o (H \o fst))) 1:/#. 
    by rewrite -dmapE /(\o) /=; smt(pmax_upper_bound).
  by hoare; conseq (: _ ==> true) => // /#.
by admit.
qed.


(* Case 2: k0' = k1_ (i.e., first part of G collides with J) *)
local clone ROMx2 as ROM_GkJ with
  type in_t1 <- ptxt_t,
  type in_t2 <- ctxt_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.


local module GW1 (RO1 : ROM_GkJ.RandomOracle1) : RandomOracle = {
  var h0 : rand_t 
  var m1 : (ptxt_t, key_t * rand_t) fmap
  var mr : (ptxt_t * rand_t, key_t * rand_t) fmap
  
  proc init(h0_init : rand_t) : unit = {
    h0 <- h0_init;
    m1 <- empty;
    mr <- empty;
  }
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    if (ph.`2 = h0) { 
      r <$ drand;
      if (ph.`1 \notin m1) {
        k <@ RO1.get(ph.`1);
        m1.[ph.`1] <- (k, r); 
      }
      (k, r) <- oget m1.[ph.`1];  
    } else { (* ph.`2 <> h0 *)
      k <$ dkey;
      r <$ drand;
      if (ph \notin mr) {
        mr.[ph] <- (k, r);
      }
      (k, r) <- oget mr.[ph];
    }
    
    return (k, r);
  }
}.

local module JW2 (RO2 : ROM_GkJ.RandomOracle2) : RandomOracle2 = {
  var z1 : rand_t 
  var m1 : (ctxt_t, key_t) fmap
  var mr : (rand_t * ctxt_t, key_t) fmap
  
  proc init(z1_init : rand_t) : unit = {
    z1 <- z1_init;
    m1 <- empty;
    mr <- empty;
  }
  
  proc get(zc : rand_t * ctxt_t) : key_t = { 
    var k : key_t;
    var r : rand_t;
    
    if (zc.`1 = z1) { 
      if (zc.`2 \notin m1) {
        k <@ RO2.get(zc.`2);
        m1.[zc.`2] <- k; 
      }
      k <- oget m1.[zc.`2];  
    } else { (* zc.`1 <> z1 *)
      k <$ dkey;
      if (zc \notin mr) {
        mr.[zc] <- k;
      }
      k <- oget mr.[zc];
    }
    
    return k;
  }
}.

  
local module (R_CRROMx2GJ_LEAKBINDKCT : ROM_GkJ.Adv_CRROMx2) 
             (RO1 : ROM_GkJ.RandomOracle1) (RO2 : ROM_GkJ.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : ptxt_t * ctxt_t = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    GW1(RO1).init(H pk0);
    JW2(RO2).init(z1);
    
    (c0, c1) <@ A(JW2(RO2), GW1(RO1)).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;
    
    return (p0', c1);
  }
}.

local lemma Bnd_GJcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
       LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1_ ]
  <=
  Pr[ROM_GkJ.CR_ROM_x2(ROM_GkJ.RO1_Default, ROM_GkJ.RO2_Default, R_CRROMx2GJ_LEAKBINDKCT).main() @ &m : res].
proof.
admit.
qed.



(* Case 3: k0_ = k1' (i.e., J collides with first part of G) *)
local clone ROMx2 as ROM_JGk with
  type in_t1 <- ctxt_t,
  type in_t2 <- ptxt_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.

local module JW1 (RO1 : ROM_JGk.RandomOracle1) : RandomOracle2 = {
  var z0 : rand_t 
  var m1 : (ctxt_t, key_t) fmap
  var mr : (rand_t * ctxt_t, key_t) fmap
  
  proc init(z0_init : rand_t) : unit = {
    z0 <- z0_init;
    m1 <- empty;
    mr <- empty;
  }
  
  proc get(zc : rand_t * ctxt_t) : key_t = { 
    var k : key_t;
    var r : rand_t;
    
    if (zc.`1 = z0) { 
      if (zc.`2 \notin m1) {
        k <@ RO1.get(zc.`2);
        m1.[zc.`2] <- k; 
      }
      k <- oget m1.[zc.`2];  
    } else { (* zc.`1 <> z1 *)
      k <$ dkey;
      if (zc \notin mr) {
        mr.[zc] <- k;
      }
      k <- oget mr.[zc];
    }
    
    return k;
  }
}.

local module GW2 (RO2 : ROM_JGk.RandomOracle2) : RandomOracle = {
  var h1 : rand_t 
  var m2 : (ptxt_t, key_t * rand_t) fmap
  var mr : (ptxt_t * rand_t, key_t * rand_t) fmap
  
  proc init(h1_init : rand_t) : unit = {
    h1 <- h1_init;
    m2 <- empty;
    mr <- empty;
  }
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    if (ph.`2 = h1) { 
      r <$ drand;
      if (ph.`1 \notin m2) {
        k <@ RO2.get(ph.`1);
        m2.[ph.`1] <- (k, r); 
      }
      (k, r) <- oget m2.[ph.`1];  
    } else { (* ph.`2 <> h0 *)
      k <$ dkey;
      r <$ drand;
      if (ph \notin mr) {
        mr.[ph] <- (k, r);
      }
      (k, r) <- oget mr.[ph];
    }
    
    return (k, r);
  }
}.

  
local module (R_CRROMx2JG_LEAKBINDKCT : ROM_JGk.Adv_CRROMx2) 
             (RO1 : ROM_JGk.RandomOracle1) (RO2 : ROM_JGk.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : ctxt_t * ptxt_t = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    JW1(RO1).init(z0);
    GW2(RO2).init(H pk1);
    
    (c0, c1) <@ A(JW1(RO1), GW2(RO2)).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p1' <- dec sk_pke1 c1;
    
    return (c0, p1');
  }
}.

local lemma Bnd_JGcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
       LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1' ]
  <=
  Pr[ROM_JGk.CR_ROM_x2(ROM_JGk.RO1_Default, ROM_JGk.RO2_Default, R_CRROMx2JG_LEAKBINDKCT).main() @ &m : res].
proof.
admit.
qed.


(* Case 4: k0_ = k1_ (i.e., J collides with J) *)
local clone ROMx2 as ROM_JJ with
  type in_t1 <- ctxt_t,
  type in_t2 <- ctxt_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.


local module JW12 (RO1 : ROM_JJ.RandomOracle1) (RO2 : ROM_JJ.RandomOracle2) : RandomOracle2 = {
  var z0, z1 : rand_t 
  var m1, m2 : (ctxt_t, key_t) fmap
  var mr : (rand_t * ctxt_t, key_t) fmap
  
  proc init(z0_init : rand_t, z1_init : rand_t) : unit = {
    z0 <- z0_init;
    z1 <- z1_init;
    m1 <- empty;
    m2 <- empty;
    mr <- empty;
  }
  
  proc get(rc : rand_t * ctxt_t) : key_t = { 
    var k : key_t;
    
    if (rc.`1 = z0) { 
      if (rc.`2 \notin m1) {
        k <@ RO1.get(rc.`2);
        m1.[rc.`2] <- k; 
      }
      k <- oget m1.[rc.`2];  
    } elif (rc.`1 = z1) {
      if (rc.`2 \notin m2) {
        k <@ RO2.get(rc.`2);
        m2.[rc.`2] <- k; 
      }
      k <- oget m2.[rc.`2];
    } else { (* ph.`2 <> h0 /\ ph.`2 <> h1 *)
      k <$ dkey;
      if (rc \notin mr) {
        mr.[rc] <- k;
      }
      k <- oget mr.[rc];
    }
    
    return k;
  }
}.
  
  
local module (R_CRROMx2JJ_LEAKBINDKCT : ROM_JJ.Adv_CRROMx2) 
             (RO1 : ROM_JJ.RandomOracle1) (RO2 : ROM_JJ.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : ctxt_t * ctxt_t = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  

    G_RO.init();
        
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    JW12(RO1, RO2).init(z0, z1);
    
    (c0, c1) <@ A(JW12(RO1, RO2), G_RO).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    return (c0, c1);
  }
}.

local lemma Bnd_JJcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1' ]
  <=
  p_max drand
  +
  Pr[ROM_JJ.CR_ROM_x2(ROM_JJ.RO1_Default, ROM_JJ.RO2_Default, R_CRROMx2JJ_LEAKBINDKCT).main() @ &m : res].
proof.
rewrite Pr[mu_split LEAK_BINDKPK_MLKEM_ROM_JG.z0 = LEAK_BINDKPK_MLKEM_ROM_JG.z1] StdOrder.RealOrder.ler_add.
+ byphoare => //.
  proc.
  swap 3 -2; swap 7 -5.
  seq 2 : (LEAK_BINDKPK_MLKEM_ROM_JG.z0 = LEAK_BINDKPK_MLKEM_ROM_JG.z1)
          (p_max drand)
          1%r
          _
          0%r => //.
  + by rnd; rnd; skip => />; smt(pmax_upper_bound).
  by hoare; conseq (: _ ==> true) => // /#.
by admit.
qed.


(*
  Split get procedure of G_RO_SSample into
  two get procedures samplings (each sampling one part of the pair)
*)
local module G_RO_SGet = {
  import var ROM_G.RO
  var mk : (ptxt_t * rand_t, key_t) fmap
  var mr : (ptxt_t * rand_t, rand_t) fmap
  
  proc getk(ph : ptxt_t * rand_t) : rand_t = { 
    var k : key_t;
    
    k <$ dkey;
    if (ph \notin mk) {
      mk.[ph] <- k; 
    }
    
    return oget mk.[ph];
  }
  
  proc getr(ph : ptxt_t * rand_t) : rand_t = { 
    var r : rand_t;
    
    r <$ drand;
    if (ph \notin mr) {
      mr.[ph] <- r; 
    }
    
    return oget mr.[ph];
  }
  
  proc get = getk
}.



(* 
  Alternative version of LEAK-BIND-K-PK property 
  for ML-KEM in ROM (with G and J modeled as a random oracle)
  with (non-RO) concrete procedures inlined, several variables 
  moved to the module level, and extraneous variables removed.
*)
local module LEAK_BINDKPK_MLKEM_ROM_JG = {
  var pk_pke0, pk_pke1 : pk_t_pke
  var sk_pke0, sk_pke1 : sk_t_pke
  var c0, c1 : ctxt_t
  var h0, h1, z0, z1, r0', r1' : rand_t
  var p0', p1' : ptxt_t 
  var k0', k1', k0_, k1_ : key_t
  var k0, k1 : key_t option
  
  proc main(bc : bindconf) : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    
    J_RO.init();
    G_RO_SSample.init();
             
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    (c0, c1) <@ A(J_RO, G_RO_SSample).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;
    (k0', r0') <@ G_RO_SSample.get((p0', H pk0));
    k0_ <@ J_RO.get((z0, c0));
    k0 <- Some (if c0 <> enc r0' pk_pke0 p0' then k0_ else k0');
    
    p1' <- dec sk_pke1 c1;
    (k1', r1') <@ G_RO_SSample.get((p1', H pk1));
    k1_ <@ J_RO.get((z1, c1));
    k1 <- Some (if c1 <> enc r1' pk_pke1 p1' then k1_ else k1');
          
    return is_bindbreak K_Binds_PK (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.



end section MLKEM_LEAKBINDKPK_ROMx2.
