(*^ 
  Binding security for (very) high-level specification of ML-KEM.
  Specification considered here abstracts away from any algebraic
  structure used in the construction, particularly 
  viewing the PKE procedures as abstract (black box) operators.
  To be instantiated and linked to lower-level specification
  and, in turn, implementation.
^*)
(* Require/Import *)
require import AllCore Distr PROM FMap.
require (*--*) DMap DProd.
require (*--*) ROMx2 KeyEncapsulationMechanismsROMx2.


(* Types *)
(* General *)
(** Randomness ("seeds") **)
type rand_t.


(* Underlying PKE scheme (K-PKE) *)
(** Public keys **)
type pk_t_pke.

(** Secret keys **)
type sk_t_pke.

(** Plaintexts of underlying PKE scheme **)
type ptxt_t = rand_t.

(** Ciphertexts **)
type ctxt_t_pke.


(* KEM (ML-KEM) *)
(** Public keys **)
type pk_t = pk_t_pke.

(** Secret keys  **)
type sk_t = sk_t_pke * pk_t * rand_t * rand_t.

(** Shared/session keys (symmetric) **)
type key_t = rand_t.

(** Ciphertexts/Encapsulations **)
type ctxt_t = ctxt_t_pke.


(* Operators *)
(** Hash function G, used to compute shared key and randomness **)
op G : ptxt_t * rand_t -> key_t * rand_t.

(** Hash function H, used to hash public keys **)
op H : pk_t -> rand_t.

(** Hash function J ("keyed"), used to compute implicit rejection key **)
op J : rand_t -> ctxt_t -> key_t.

(** Operator capturing "derandomized" key generation of underlying PKE scheme **)
op kg : rand_t -> pk_t_pke * sk_t_pke.

(** Operator capturing "derandomized" encryption function of underlying PKE scheme **)
op enc : rand_t -> pk_t_pke -> ptxt_t -> ctxt_t_pke.

(** Operator capturing decryption function of underlying PKE scheme **)
(**
  By design, the underlying PKE scheme never returns a failure, 
  so we refrain from using option monad as output.
**)
op dec : sk_t_pke -> ctxt_t_pke -> ptxt_t.


(* Distributions *)
(** Proper, full, and uniform distribution over randomness **)
op [lossless full uniform] drand : rand_t distr.

(** Proper, full, and uniform distribution over (shared) keys **)
op [lossless full uniform] dkey : key_t distr.

(** Proper, full, and uniform distribution over pairs of (shared) keys and randomness **) 
op [lossless full uniform] dkeyrand : (key_t * rand_t) distr.

(** `dkeyrand` is equal to the product distribution of dkey and drand **)
lemma dkeyrand_dprod : dkeyrand = dkey `*` drand.
proof. 
rewrite &(eq_funi_ll) ?is_full_funiform ?(dkeyrand_ll, dkeyrand_fu, dkeyrand_uni).
+ by rewrite dprod_fu_auto ?(dkey_fu, drand_fu) /=. 
+ by rewrite dprod_uni 1,2:(dkey_uni, drand_uni). 
by rewrite dprod_ll_auto 1,2:(dkey_ll, drand_ll). 
qed.

(** Distribution representing key generation of underlying PKE scheme **)
op dkg : (pk_t_pke * sk_t_pke) distr = dmap drand kg.

(** `dkg` is a proper distribution **)
lemma dkg_ll : is_lossless dkg.
proof. by rewrite dmap_ll drand_ll. qed.


(* Clones/imports *)
(* 
  Definitions and properties for KEMs (in the ROM with 2 ROs) 
  with types as required for ML-KEM 
*)
clone import KeyEncapsulationMechanismsROMx2 as KEMsROMx2 with
  type pk_t <- pk_t,
  type sk_t <- sk_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t,
  
  type in_t <- ptxt_t * rand_t, 
  type out_t <- key_t * rand_t,
  type in_t2 <- rand_t * ctxt_t,
  type out_t2 <- key_t
  
  proof *.

(* Single RO and non-ROM KEM definitions consistent with above instantiation *) 
import KEMsROM KEMs.


(* Schemes (standard model) *)
(** K-PKE, PKE scheme underlying ML-KEM **)
(** 
  As per FIPS 203, we specify the PKE in a derandomized manner.
  That is, any procedure using randomness (i.e., key generation and encryption)
  takes it as input rather than sampling it itself. This also means
  it does not adhere to the regular syntax of a PKE scheme. 
**)  
(**
  Further, this is a (very) high-level specification, essentially abstracting
  away all algebraic structure and modeling the procedures as simple operators 
  (which is possible because all randomness is taken as input)
**)
module K_PKE_HL = {
  proc keygen(d : rand_t) : pk_t_pke * sk_t_pke = {
    return kg d;
  }
  
  proc enc(pk : pk_t_pke, p : ptxt_t, r : rand_t) : ctxt_t_pke = {
    return enc r pk p;
  }
  
  proc dec(sk : sk_t_pke, c : ctxt_t_pke) : ptxt_t = {
    return dec sk c;
  } 
}.


(**
  ML-KEM in the standard model.
  Closely follows FIPS 203 (without accounting for sampling failures, so 
  the "internal" ML-KEM procedures are most relevant). 
**)
module ML_KEM_HL : Scheme = { 
  proc keygen() : pk_t * sk_t = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var d, z : rand_t;
    var pk : pk_t;
    var sk : sk_t;
    
    d <$ drand;
    z <$ drand;
    
    (pk_pke, sk_pke) <@ K_PKE_HL.keygen(d);
    
    pk <- pk_pke;
    sk <- (sk_pke, pk, H pk, z);
    
    return (pk, sk);
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    var c : ctxt_t_pke;
    
    p <$ drand;
    (k, r) <- G (p, H pk);
    
    c <@ K_PKE_HL.enc(pk, p, r);

    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    var c' : ctxt_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <@ K_PKE_HL.dec(sk_pke, c);
    
    (k', r') <- G (p', h);
    k_ <- J z c;
    
    c' <@ K_PKE_HL.enc(pk_pke, p', r');
    
    if (c <> c') {
      k' <- k_;
    }
    
    return Some k';
  }
}.



(**
  ML-KEM in the ROM, where only the G (i.e., the function for generating
  the shared key and randomness for encryption) is modeled as a RO.
  Closely follows FIPS 203 (without accounting for sampling failures, so 
  the "internal" ML-KEM procedures are most relevant). 
**)
module (ML_KEM_HL_ROM_G : Scheme_ROM) (G_RO : RandomOracle) = { 
  proc keygen() : pk_t * sk_t = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var d, z : rand_t;
    var pk : pk_t;
    var sk : sk_t;
    
    d <$ drand;
    z <$ drand;
    
    (pk_pke, sk_pke) <@ K_PKE_HL.keygen(d);
    
    pk <- pk_pke;
    sk <- (sk_pke, pk, H pk, z);
    
    return (pk, sk);
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    var c : ctxt_t_pke;
    
    p <$ drand;
    (k, r) <@ G_RO.get((p, (H pk)));
    
    c <@ K_PKE_HL.enc(pk, p, r);

    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    var c' : ctxt_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <@ K_PKE_HL.dec(sk_pke, c);
    
    (k', r') <@ G_RO.get((p', h));
    k_ <- J z c;
    
    c' <@ K_PKE_HL.enc(pk_pke, p', r');
    
    if (c <> c') {
      k' <- k_;
    }
    
    return Some k';
  }
}.



(**
  ML-KEM in the ROM, where both G (i.e., the function used to generate
  the shared key and randomness for encryption) and J (i.e., the function used to
  generate the implicit rejection key) are modeled as RO.
  Closely follows FIPS 203 (without accounting for sampling failures, so 
  the "internal" ML-KEM procedures are most relevant). 
**)
module (ML_KEM_HL_ROM_JG : Scheme_ROMx2) (J_RO : RandomOracle2) (G_RO : RandomOracle) = { 
  proc keygen() : pk_t * sk_t = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var d, z : rand_t;
    var pk : pk_t;
    var sk : sk_t;
    
    d <$ drand;
    z <$ drand;
    
    (pk_pke, sk_pke) <@ K_PKE_HL.keygen(d);
    
    pk <- pk_pke;
    sk <- (sk_pke, pk, H pk, z);
    
    return (pk, sk);
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    var c : ctxt_t_pke;
    
    p <$ drand;
    (k, r) <@ G_RO.get((p, (H pk)));
    
    c <@ K_PKE_HL.enc(pk, p, r);

    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    var c' : ctxt_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <@ K_PKE_HL.dec(sk_pke, c);
    
    (k', r') <@ G_RO.get((p', h));
    k_ <@ J_RO.get((z, c));
    
    c' <@ K_PKE_HL.enc(pk_pke, p', r');
    
    if (c <> c') {
      k' <- k_;
    }
    
    return Some k';
  }
}.


(* Alternative specifications (to facilitate proofs) *)
(** 
  Trimmed version of ML_KEM_HL_ROM_JG (e.g., inlined procedures, less variables).
  Equivalent to the standard version above (as shown in the corresponding lemmas).
**)
(**
  Besides inlining and removing variables, the sampling of randomness followed by the "derandomized" 
  key generation is replaced by directly sampling from the appropriate distribution (dkg). 
**)
module (ML_KEM_HL_ROM_JG_Trim : Scheme_ROMx2) (J_RO : RandomOracle2) (G_RO : RandomOracle) = {
  proc keygen() : pk_t * sk_t = {
    var z : rand_t;
    var sk_pke : sk_t_pke;
    var pk : pk_t;
        
    z <$ drand;
    (pk, sk_pke) <$ dkg;
    
    return (pk, (sk_pke, pk, H pk, z));
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p, r : rand_t; 
    var k : key_t;
    
    p <$ drand;
    (k, r) <@ G_RO.get((p, H pk));
     
    return (k, enc r pk p);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var p' : ptxt_t;
    var k', k_ : key_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    p' <- dec sk_pke c;
    
    (k', r') <@ G_RO.get((p', h));
    k_ <@ J_RO.get((z, c));
    
    return Some (if c <> enc r' pk_pke p' then k_ else k');
  }
}.


section.

(* Auxiliary clone for proving sampling equivalence *)
local clone DMap.DMapSampling as DMS with
  type t1 <- rand_t,
  type t2 <- pk_t_pke * sk_t_pke
  
  proof *.

(**
  Equivalence between key generation procedures of ML_KEM_HL_ROM_JG 
  and ML_KEM_HL_ROM_JG_Trim, for any instantiation of the oracles
**)    
equiv Eqv_ML_KEM_HL_ROM_JG_Trim_Keygen (J_RO <: RandomOracle2) (G_RO <: RandomOracle) :
  ML_KEM_HL_ROM_JG(J_RO, G_RO).keygen ~ ML_KEM_HL_ROM_JG_Trim(J_RO, G_RO).keygen : 
    true ==> ={res}.
proof. 
proc.
inline K_PKE_HL.keygen; swap{1} 1 1.
wp.
transitivity{2} { z <$ drand; (pk, sk_pke) <@ DMS.S.sample(drand, kg); } 
                (    true 
                 ==> 
                     let tpl = kg d{1} in 
                       (tpl.`1, (tpl.`2, tpl.`1, H tpl.`1, z{1})) 
                       = 
                       (pk{2}, (sk_pke{2}, pk{2}, H pk{2}, z{2}))) 
                (true ==> ={z, pk, sk_pke}) => //.
+ rewrite equiv[{2} 2 DMS.sample].
  inline{2} DMS.S.map.
  by wp; rnd; wp; rnd; skip.
inline{1} DMS.S.sample.
by wp; rnd; wp; rnd. 
qed.

end section.

(** 
  Equivalence between encapsulation procedures of ML_KEM_HL_ROM_JG 
  and ML_KEM_HL_ROM_JG_Trim, for any instantiation of the oracles
**) 
equiv Eqv_ML_KEM_HL_ROM_JG_Trim_Encaps (J_RO <: RandomOracle2) (G_RO <: RandomOracle) :
  ML_KEM_HL_ROM_JG(J_RO, G_RO).encaps ~ ML_KEM_HL_ROM_JG_Trim(J_RO, G_RO).encaps : 
    ={glob G_RO, arg} ==> ={glob G_RO, res}.
proof.
proc.
inline K_PKE_HL.enc.
by wp; sim.
qed.

(** 
  Equivalence between decapsulations procedures of ML_KEM_HL_ROM_JG 
  and ML_KEM_HL_ROM_JG_Trim
**)  
equiv Eqv_ML_KEM_HL_ROM_JG_Trim_Decaps (J_RO <: RandomOracle2) (G_RO <: RandomOracle{-J_RO}) :
  ML_KEM_HL_ROM_JG(J_RO, G_RO).decaps ~ ML_KEM_HL_ROM_JG_Trim(J_RO, G_RO).decaps : 
    ={glob G_RO, glob J_RO, arg} ==> ={glob G_RO, glob J_RO, res}.
proof.
proc.
inline K_PKE_HL.enc K_PKE_HL.dec.
by wp; call(: true); call(: true); wp.
qed.



(* Default definitions and properties for G as a random oracle *)
clone import FullRO as ROM_G with
  type in_t <- ptxt_t * rand_t,
  type out_t <- key_t * rand_t,
  
    op dout <- fun _ => dkeyrand
    
  proof *.

(* Default definitions and properties for J as a random oracle *)
clone import FullRO as ROM_J with
  type in_t <- rand_t * ctxt_t,
  type out_t <- key_t,
  
    op dout <- fun _ => dkey
    
  proof *.


(** Counting wrapper for first/G (type of) oracle **)
module Counting_RO1 (RO1 : RandomOracle) : RandomOracle = {
  var q : int
    
  proc get(x : ptxt_t * rand_t) : key_t * rand_t = {
    var y : key_t * rand_t;
    
    y <@ RO1.get(x);
    
    q <- q + 1;
        
    return y;
  }
}.

(** Counting wrapper for second J (type of) oracle **)
module Counting_RO2 (RO2 : RandomOracle2) : RandomOracle2 = {
  var q : int

  proc get(x : rand_t * ctxt_t) : key_t = {
    var y : key_t;
    
    y <@ RO2.get(x);
    
    q <- q + 1;
        
    return y;
  }
}.



(** Alias for default random oracle implementation for G **)
module G_RO = ROM_G.LRO.

(** Alias for default random oracle implementation for J **)
module J_RO = ROM_J.LRO. 


section MLKEMHL_LEAKBINDKPK_ROMx2.

declare module A <: Adv_LEAKBIND_ROMx2 {-G_RO, -J_RO, -Counting_RO1, -Counting_RO2}.

(* By assumption, the adversary's finding procedure terminates (given that its oracles terminate) *)
declare axiom A_find_ll (RO1 <: RandomOracle{-A}) (RO2 <: RandomOracle2{-A}) :
  islossless RO1.get => islossless RO2.get => islossless A(RO2, RO1).find.

(* 
  By assumption, the number of adversary queries is bounded 
  (by some non-negative constants).
*)
declare op qG : { int | 0 <= qG } as ge0_qG.
declare axiom A_find_qG (RO1 <: RandomOracle{-A, -Counting_RO1}) (RO2 <: RandomOracle2{-A, -Counting_RO1, -RO1}) :
  hoare[A(RO2, Counting_RO1(RO1)).find : Counting_RO1.q = 0 ==> Counting_RO1.q <= qG].

declare op qJ : { int | 0 <= qJ } as ge0_qJ.
declare axiom A_find_qJ (RO1 <: RandomOracle{-A, -Counting_RO2}) (RO2 <: RandomOracle2{-A, -Counting_RO2, -RO1}) :
  hoare[A(Counting_RO2(RO2), RO1).find : Counting_RO2.q = 0 ==> Counting_RO2.q <= qJ].

(** Total number of queries **)
op q = qG + qJ.


(*
  Split sampling (of pairs) in G_RO
  two independent samplings of each element
*)
local module G_RO_SSample = {
  import var ROM_G.RO
  include G_RO [-get]
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    k <$ dkey;
    r <$ drand;
    if (ph \notin m) {
      m.[ph] <- (k, r); 
    }
    
    return oget m.[ph];
  }
}.


local clone DProd.ProdSampling as DKR with
  type t1 <- key_t,
  type t2 <- rand_t
  
  proof *.

local equiv Eqv_GRO_GROSS_Get :
  G_RO.get ~ G_RO_SSample.get : ={glob G_RO, arg} ==> ={glob G_RO, res}.
proof.
proc. 
wp; conseq (: _ ==> r{1} = (k, r){2}) => //.
transitivity{1} { r <@ DKR.S.sample(dkey, drand); } 
                (true ==> ={r})
                (true ==> r{1} = (k, r){2}) => //.
+ inline{2} DKR.S.sample; auto => />. 
  by rewrite dkeyrand_dprod.
transitivity{1} { r <@ DKR.S.sample2(dkey, drand); } 
                (true ==> ={r})
                (true ==> r{1} = (k, r){2}) => //.
+ by call (DKR.sample_sample2).
by inline{1} DKR.S.sample2; auto.
qed.  


(* 
  Alternative version of LEAK-BIND-K-PK property 
  for ML-KEM in ROM (with J and G modeled as a random oracle)
  with (non-RO) concrete procedures inlined, several variables 
  moved to the module level, and extraneous variables removed.
*)
local module LEAK_BINDKPK_MLKEM_ROM_JG = {
  var pk_pke0, pk_pke1 : pk_t_pke
  var sk_pke0, sk_pke1 : sk_t_pke
  var c0, c1 : ctxt_t
  var h0, h1, z0, z1, r0', r1' : rand_t
  var p0', p1' : ptxt_t 
  var k0', k1', k0_, k1_ : key_t
  var k0, k1 : key_t option
  
  proc main(bc : bindconf) : bool = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    
    J_RO.init();
    G_RO_SSample.init();
             
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    (c0, c1) <@ A(J_RO, G_RO_SSample).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;
    (k0', r0') <@ G_RO_SSample.get((p0', H pk0));
    k0_ <@ J_RO.get((z0, c0));
    k0 <- Some (if c0 <> enc r0' pk_pke0 p0' then k0_ else k0');
    
    p1' <- dec sk_pke1 c1;
    (k1', r1') <@ G_RO_SSample.get((p1', H pk1));
    k1_ <@ J_RO.get((z1, c1));
    k1 <- Some (if c1 <> enc r1' pk_pke1 p1' then k1_ else k1');
          
    return is_bindbreak K_Binds_PK (oget k0) (oget k1) pk0 pk1 c0 c1;
  }
}.


local lemma EqPr_LEAKBINDROMJG_KPK &m :
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG, A).main(K_Binds_PK) @ &m : res]
  =
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : res].
proof.
have ->:
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG, A).main(K_Binds_PK) @ &m : res]
  =
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG_Trim, A).main(K_Binds_PK) @ &m : res].
+ byequiv => //.
  proc.
  inline main init. 
  seq 5 5 : (   #pre 
             /\ ={glob J_RO, glob G_RO, pk0, sk0, bc0, bc1} 
             /\ bc0{1} = bc{1}
             /\ bc1{1} = bc{1}).
  + sp; rewrite equiv[{1} 1 (Eqv_ML_KEM_HL_ROM_JG_Trim_Keygen J_RO G_RO)]. 
    by call (: true); 1: auto.
  rcondf{1} ^if; 2: rcondt{1} ^if; 1,2: by auto. 
  rcondf{2} ^if; 2: rcondt{2} ^if; 1,2: by auto. 
  wp; do 2! call (Eqv_ML_KEM_HL_ROM_JG_Trim_Decaps J_RO G_RO).
  call (: ={glob J_RO, glob G_RO}); 1,2: by sim.
  by call (Eqv_ML_KEM_HL_ROM_JG_Trim_Keygen J_RO G_RO).
byequiv => //.
proc.
inline main init.
seq 5 6 : (   #pre 
           /\ ={glob J_RO, glob G_RO, sk0, pk0}
           /\ pk0{1} = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{2}
           /\ sk0{1}.`1 = LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0{2}
           /\ sk0{1}.`2 = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{2}
           /\ sk0{1}.`3 = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{2}
           /\ sk0{1}.`4 = LEAK_BINDKPK_MLKEM_ROM_JG.z0{2}
           /\ bc0{1} = bc{2}
           /\ bc1{1} = bc{2}).
+ by inline *; auto.
rcondf{1} ^if; 2: rcondt{1} ^if; 1,2: by auto. 
inline{1} decaps keygen.
wp; call (: ={glob J_RO}); 1: by auto. 
call Eqv_GRO_GROSS_Get.
wp; call (: ={glob J_RO}); 1: by auto.
call Eqv_GRO_GROSS_Get.
wp; call (: ={glob J_RO, glob G_RO}). 
+ by conseq Eqv_GRO_GROSS_Get.
+ by proc; auto.
by auto.
qed.

local lemma Bnd_LEAKBINDROMJG_KPK_CD &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : res]
  <=
  p_max drand
  +
  p_max (dmap dkg (fun (kp : pk_t_pke * sk_t_pke) => H kp.`1))
  +
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1']
  +
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : 
         LEAK_BINDKPK_MLKEM_ROM_JG.z0 <> LEAK_BINDKPK_MLKEM_ROM_JG.z1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1_]
  +
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1']  
  +
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : 
         LEAK_BINDKPK_MLKEM_ROM_JG.z0 <> LEAK_BINDKPK_MLKEM_ROM_JG.z1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1_].
proof.
rewrite -?RField.addrA Pr[mu_split LEAK_BINDKPK_MLKEM_ROM_JG.z0 = LEAK_BINDKPK_MLKEM_ROM_JG.z1] StdOrder.RealOrder.ler_add.
+ byphoare => //.
  proc.
  swap 3 -2; swap 7 -5.
  seq 2 : (LEAK_BINDKPK_MLKEM_ROM_JG.z0 = LEAK_BINDKPK_MLKEM_ROM_JG.z1)
          (p_max drand)
          1%r
          _
          0%r => //.
  + by rnd; rnd; skip => />; smt(pmax_upper_bound).
  by hoare; conseq (: _ ==> true) => // /#.
rewrite Pr[mu_split H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1] StdOrder.RealOrder.ler_add.
+ byphoare => //. 
  proc.
  swap 4 -3; swap 8 -6.
  seq 2 : (H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1)
          (p_max (dmap dkg (fun (kp : pk_t_pke * sk_t_pke) => H kp.`1)))
          1%r
          _
          0%r => //.
  + rnd (fun (kp : pk_t_pke * sk_t_pke) => H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 = H kp.`1).
    rnd; skip => /> kp kpin.
    pose fnc := (fun (kp : _ * _) => _ = Top.H kp.`1). 
    rewrite (: fnc = (pred1 (H kp.`1) \o (H \o fst))) 1:/#. 
    by rewrite -dmapE /(\o) /=; smt(pmax_upper_bound).
  by hoare; conseq (: _ ==> true) => // /#.
rewrite Pr[mu_split (   H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
                     /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1')] StdOrder.RealOrder.ler_add.
+ by rewrite Pr[mu_sub].
rewrite Pr[mu_split (   LEAK_BINDKPK_MLKEM_ROM_JG.z0 <> LEAK_BINDKPK_MLKEM_ROM_JG.z1
                     /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1_)] StdOrder.RealOrder.ler_add.
+ by rewrite Pr[mu_sub].
rewrite Pr[mu_split (   H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
                     /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1')] StdOrder.RealOrder.ler_add.
+ by rewrite Pr[mu_sub]. 
rewrite Pr[mu_split (   LEAK_BINDKPK_MLKEM_ROM_JG.z0 <> LEAK_BINDKPK_MLKEM_ROM_JG.z1
                     /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1_)].
rewrite -(RField.addr0 Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m : 
              LEAK_BINDKPK_MLKEM_ROM_JG.z0 <> LEAK_BINDKPK_MLKEM_ROM_JG.z1
           /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1_]) StdOrder.RealOrder.ler_add.
+ by rewrite Pr[mu_sub].
byphoare => //; hoare.
proc. 
inline get.
wp; rnd; wp; rnd; rnd; wp. 
conseq (:     _ 
          ==> 
              pk0 = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0
           /\ pk1 = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1) => [/# |]. 
inline init.
by auto; call (: true) => //; auto.
qed.


(* Case 1: k0' = k1' (i.e., first parts of G collide) *)
local clone ROMx2 as ROM_GkGk with
  type in_t1 <- ptxt_t,
  type in_t2 <- ptxt_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.


local module GW12 (RO1 : ROM_GkGk.RandomOracle1) (RO2 : ROM_GkGk.RandomOracle2) : RandomOracle = {
  var h0, h1 : rand_t 
  var m1, m2 : (ptxt_t, key_t * rand_t) fmap
  var mr : (ptxt_t * rand_t, key_t * rand_t) fmap
  
  proc init(h0_init : rand_t, h1_init : rand_t) : unit = {
    h0 <- h0_init;
    h1 <- h1_init;
    m1 <- empty;
    m2 <- empty;
    mr <- empty;
  }
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    if (ph.`2 = h0) { 
      r <$ drand;
      if (ph.`1 \notin m1) {
        k <@ RO1.get(ph.`1);
        m1.[ph.`1] <- (k, r); 
      }
      (k, r) <- oget m1.[ph.`1];  
    } elif (ph.`2 = h1) {
      r <$ drand;
      if (ph.`1 \notin m2) {
        k <@ RO2.get(ph.`1);
        m2.[ph.`1] <- (k, r); 
      }
      (k, r) <- oget m2.[ph.`1];
    } else { (* ph.`2 <> h0 /\ ph.`2 <> h1 *)
      k <$ dkey;
      r <$ drand;
      if (ph \notin mr) {
        mr.[ph] <- (k, r);
      }
      (k, r) <- oget mr.[ph];
    }
    
    return (k, r);
  }
}.
  
  
local module (R_CRROMx2GkGk_LEAKBINDKCT : ROM_GkGk.Adv_CRROMx2) 
             (RO1 : ROM_GkGk.RandomOracle1) (RO2 : ROM_GkGk.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : ptxt_t * ptxt_t = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    J_RO.init();
    
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    GW12(RO1, RO2).init(H pk0, H pk1);
    
    (c0, c1) <@ A(J_RO, GW12(RO1, RO2)).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;    
    p1' <- dec sk_pke1 c1;
    
    return (p0', p1');
  }
}.


local lemma Bnd_GkGkcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1']
  <=
  Pr[ROM_GkGk.CR_ROM_x2(ROM_GkGk.RO1_Default, ROM_GkGk.RO2_Default, R_CRROMx2GkGk_LEAKBINDKCT).main() @ &m : res].
proof.
byequiv => //.
proc.
swap{1} [14..15] 2.
seq 15 11 : #post; 2: by inline; auto. 
inline{2} 3.
swap{1} 4 -3; swap{1} 8 -6. 
swap{2} 5 -4; swap{2} 9 -7.
seq 2 2 : (   #pre 
           /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1}
           /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1}). 
+ by rnd; rnd.
case (H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1} = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}).
+ conseq (: _ ==> true) => //.
  inline.
  swap{1} 13 -1; swap{1} 19 -6.
  auto. 
  call{1} (A_find_ll G_RO_SSample J_RO).
  + by proc; auto => />; smt(dkey_ll drand_ll).
  + by proc; auto => />; smt(dkey_ll).
  call{2} (A_find_ll (GW12(ROM_GkGk.RO1_Default, ROM_GkGk.RO2_Default)) J_RO).
  + proc; inline.
    if => //.
    + seq 1 : true 1%r 1%r 0%r 0%r => //.
      + by rnd; skip; smt(drand_ll).
      + by if; auto => />; smt(dkey_ll).
      if => //.
      + seq 1 : true 1%r 1%r 0%r 0%r => //.
        + by rnd; skip; smt(drand_ll).
        + by if; auto => />; smt(dkey_ll).
        by auto => />; smt(dkey_ll drand_ll).
  + by proc; auto => />; smt(dkey_ll).
  by auto.
inline get.
seq 9 11 : (   ={LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1}
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1}
             /\ H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1} <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}
             /\ pk0{1} = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1}
             /\ pk1{1} = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}
             /\ (forall (p : ptxt_t),
                   (p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1}) \in ROM_G.RO.m{1} 
                   <=> 
                   p \in ROM_GkGk.RO1_Default.m{2})
             /\ (forall (p : ptxt_t), p \in ROM_GkGk.RO1_Default.m{2} => 
                   (oget ROM_G.RO.m{1}.[(p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1})]).`1
                   =
                   oget ROM_GkGk.RO1_Default.m{2}.[p])
             /\ (forall (p : ptxt_t),
                   (p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}) \in ROM_G.RO.m{1} 
                   <=> 
                   p \in ROM_GkGk.RO2_Default.m{2})
             /\ (forall (p : ptxt_t), p \in ROM_GkGk.RO2_Default.m{2} =>
                    (oget ROM_G.RO.m{1}.[(p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1})]).`1
                    =
                    oget ROM_GkGk.RO2_Default.m{2}.[p])). 
+ call (:   ={ROM_J.RO.m}
         /\ H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1} <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}
         /\ GW12.h0{2} = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1}
         /\ GW12.h1{2} = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}
         /\ dom GW12.m1{2} = dom ROM_GkGk.RO1_Default.m{2}
         /\ dom GW12.m2{2} = dom ROM_GkGk.RO2_Default.m{2}
         /\ (forall (p : ptxt_t), p \in GW12.m1{2} => 
               (oget GW12.m1{2}.[p]).`1 = oget ROM_GkGk.RO1_Default.m{2}.[p])
         /\ (forall (p : ptxt_t), p \in GW12.m2{2} => 
               (oget GW12.m2{2}.[p]).`1 = oget ROM_GkGk.RO2_Default.m{2}.[p])
         /\ (forall (p : ptxt_t),
                (p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1}) \in ROM_G.RO.m{1} 
                <=> 
                p \in ROM_GkGk.RO1_Default.m{2})
          /\ (forall (p : ptxt_t), p \in GW12.m1{2} => 
                oget ROM_G.RO.m{1}.[(p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1})]
                =
                oget GW12.m1{2}.[p])
          /\ (forall (p : ptxt_t),
                (p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}) \in ROM_G.RO.m{1} 
                <=> 
                p \in ROM_GkGk.RO2_Default.m{2})
          /\ (forall (p : ptxt_t), p \in GW12.m2{2} => 
                 oget ROM_G.RO.m{1}.[(p, H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1})]
                 =
                 oget GW12.m2{2}.[p])
          /\ (forall (p : ptxt_t) (h : rand_t), (p, h) \in GW12.mr{2} =>
                h <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1} /\ h <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1})
          /\ (forall (p : ptxt_t) (h : rand_t), 
                h <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1} /\ h <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1} => 
                  ((p, h) \in ROM_G.RO.m{1} <=> (p, h) \in GW12.mr{2}))
          /\ (forall (p : ptxt_t) (h : rand_t), (p, h) \in GW12.mr{2} =>
                 oget ROM_G.RO.m{1}.[(p, h)] = oget GW12.mr{2}.[(p, h)])).
  + proc.
    if{2}.
    + case (ph{2}.`1 \notin GW12.m1{2}).
      + rcondt{1} ^if; 1: by auto => /> /#. 
        inline get.
        rcondt{2} ^if; 1: by auto.
        rcondt{2} ^if; 1: by auto => /> /#. 
        swap{1} 1 1; wp; rnd; wp; rnd; skip => />; smt(get_setE domE).                
      rcondf{2} ^if; 1: by auto. 
      case (ph{2}.`2 = GW12.h1{2}).
      + rcondt{1} ^if; 1: by auto => /> /#. 
        by wp; rnd; rnd{1}; skip => />; smt(get_setE).
      rcondf{1} ^if; 1: by auto => /> /#.
      by wp; rnd; rnd{1}; skip => />; smt(get_setE).
    if{2}.
    + case (ph{2}.`1 \notin GW12.m2{2}).
      + rcondt{1} ^if; 1: by auto => /> /#. 
        inline get.
        rcondt{2} ^if; 1: by auto.
        rcondt{2} ^if; 1: by auto => /> /#.
        by swap{1} 1 1; wp; rnd; wp; rnd; skip => />; smt(get_setE domE).
      rcondf{2} ^if; 1: by auto.
      rcondf{1} ^if; 1: by auto => /> /#.
      by wp; rnd; rnd{1}; skip => />; smt(get_setE).
    by wp; rnd; rnd; skip => />; smt(get_setE).
  + by proc; auto. 
  inline init.
  by auto => />; smt(mem_empty).   
wp; rnd{1}; rnd.  
wp; rnd{1}; rnd.
by wp; skip => />; smt(get_setE).
qed.


(* Case 2: k0' = k1_ (i.e., first part of G collides with J) *)
local clone ROMx2 as ROM_GkJ with
  type in_t1 <- ptxt_t * rand_t,
  type in_t2 <- rand_t * ctxt_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.


local module GW1 (RO1 : ROM_GkJ.RandomOracle1) : RandomOracle = {
  import var ROM_G.RO
  include G_RO [-get]
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    r <$ drand;
    k <@ RO1.get(ph);
    if (ph \notin m) {
      m.[ph] <- (k, r); 
    }

    return oget m.[ph];
  }
}.

local module (R_CRROMx2GkJ_LEAKBINDKCT : ROM_GkJ.Adv_CRROMx2) 
             (RO1 : ROM_GkJ.RandomOracle1) (RO2 : ROM_GkJ.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : (ptxt_t * rand_t) * (rand_t * ctxt_t) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  

    GW1(RO1).init();
            
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
        
    (c0, c1) <@ A(RO2, GW1(RO1)).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;
    
    return ((p0', H pk0), (z1, c1));
  }
}.


local lemma Bnd_GkJcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         LEAK_BINDKPK_MLKEM_ROM_JG.z0 <> LEAK_BINDKPK_MLKEM_ROM_JG.z1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0' = LEAK_BINDKPK_MLKEM_ROM_JG.k1_]
  <=
  Pr[ROM_GkJ.CR_ROM_x2(ROM_GkJ.RO1_Default, ROM_GkJ.RO2_Default, R_CRROMx2GkJ_LEAKBINDKCT).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{2} 3.
swap{1} 3 -2; swap{2} 4 -3.
swap{1} 7 -5; swap{2} 8 -6.
seq 2 2 : (#pre /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.z0, LEAK_BINDKPK_MLKEM_ROM_JG.z1}); 1: by auto.
case (LEAK_BINDKPK_MLKEM_ROM_JG.z0{1} = LEAK_BINDKPK_MLKEM_ROM_JG.z1{1}).
+ conseq (: _ ==> true) => //.
  inline.
  do 2! (wp; rnd{1}; rnd{2}).
  rnd{1}.
  do 3! (wp; rnd{1}). 
  wp. 
  call{1} (A_find_ll G_RO_SSample J_RO).
  + by proc; auto => />; smt(dkey_ll drand_ll).
  + by proc; auto => />; smt(dkey_ll).
  call{2} (A_find_ll (GW1(ROM_GkJ.RO1_Default)) (ROM_GkJ.RO2_Default)).
  + proc; inline.
    by auto; smt(dkey_ll drand_ll).
  + by proc; auto => />; smt(dkey_ll).
  by auto.
seq 9 10 : (   ={pk0}
            /\ LEAK_BINDKPK_MLKEM_ROM_JG.z0{1} <> LEAK_BINDKPK_MLKEM_ROM_JG.z1{1}
            /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.z0, LEAK_BINDKPK_MLKEM_ROM_JG.z1}
            /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}
            /\ ROM_J.RO.m{1} = ROM_GkJ.RO2_Default.m{2}
            /\ dom ROM_G.RO.m{1} = dom ROM_GkJ.RO1_Default.m{2}
            /\ (forall (ph : ptxt_t * rand_t), ph \in ROM_G.RO.m{1} =>
                   (oget ROM_G.RO.m{1}.[ph]).`1 = oget ROM_GkJ.RO1_Default.m{2}.[ph])).
call (:   ={ROM_G.RO.m}
       /\ ROM_J.RO.m{1} = ROM_GkJ.RO2_Default.m{2}
       /\ dom ROM_G.RO.m{1} = dom ROM_GkJ.RO1_Default.m{2}
       /\ (forall (ph : ptxt_t * rand_t), ph \in ROM_G.RO.m{1} =>
              (oget ROM_G.RO.m{1}.[ph]).`1 = oget ROM_GkJ.RO1_Default.m{2}.[ph])).
+ proc.
  inline{2} get.
  swap{1} 1 1.
  by auto => />; smt(get_setE).
+ by proc; auto.
+ by inline init; auto => />; smt(mem_empty). 
swap{1} 7 -3; swap{1} 2 1.
seq 4 4 : #post; 2: by inline; auto.
inline get.
wp; rnd; wp; rnd{1}; rnd. 
by wp; rnd{1}; wp; skip => />; smt(get_setE).
qed.


(* Case 3: k0_ = k1' (i.e., J collides with first part of G) *)
local clone ROMx2 as ROM_JGk with
  type in_t1 <- rand_t * ctxt_t,
  type in_t2 <- ptxt_t * rand_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.

local module GW2 (RO2 : ROM_JGk.RandomOracle2) : RandomOracle = {
  import var ROM_G.RO
  include G_RO [-get]
  
  proc get(ph : ptxt_t * rand_t) : key_t * rand_t = { 
    var k : key_t;
    var r : rand_t;
    
    r <$ drand;
    k <@ RO2.get(ph);
    if (ph \notin m) {
      m.[ph] <- (k, r); 
    }

    return oget m.[ph];
  }
}.

local module (R_CRROMx2JGk_LEAKBINDKCT : ROM_JGk.Adv_CRROMx2) 
             (RO1 : ROM_JGk.RandomOracle1) (RO2 : ROM_JGk.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : (rand_t * ctxt_t) * (ptxt_t * rand_t) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  

    GW2(RO2).init();
            
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
        
    (c0, c1) <@ A(RO1, GW2(RO2)).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p1' <- dec sk_pke1 c1;
    
    return ((z0, c0), (p1', H pk1));
  }
}.


local lemma Bnd_JGkcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0 <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1']
  <=
  Pr[ROM_JGk.CR_ROM_x2(ROM_JGk.RO1_Default, ROM_JGk.RO2_Default, R_CRROMx2JGk_LEAKBINDKCT).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{2} 3.
swap{1} 4 -3; swap{2} 5 -4.
swap{1} 8 -6; swap{2} 9 -7.
seq 2 2 : (   #pre 
           /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1}
           /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1}); 1: by auto.
case (H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1} = H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}).
+ conseq (: _ ==> true) => //.
  inline.
  do 2! (wp; rnd{1}; rnd{2}).
  rnd{1}.
  do 3! (wp; rnd{1}). 
  wp. 
  call{1} (A_find_ll G_RO_SSample J_RO).
  + by proc; auto => />; smt(dkey_ll drand_ll).
  + by proc; auto => />; smt(dkey_ll).
  call{2} (A_find_ll (GW2(ROM_JGk.RO2_Default)) (ROM_JGk.RO1_Default)).
  + proc; inline.
    by auto; smt(dkey_ll drand_ll).
  + by proc; auto => />; smt(dkey_ll).
  by auto.
seq 9 10 : (   ={pk0, pk1}
            /\ pk0{1} = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1}
            /\ pk1{1} = LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}
            /\ H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke0{1} <> H LEAK_BINDKPK_MLKEM_ROM_JG.pk_pke1{1}
            /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1, LEAK_BINDKPK_MLKEM_ROM_JG.z0}
            /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}
            /\ ROM_J.RO.m{1} = ROM_JGk.RO1_Default.m{2}
            /\ dom ROM_G.RO.m{1} = dom ROM_JGk.RO2_Default.m{2}
            /\ (forall (ph : ptxt_t * rand_t), ph \in ROM_G.RO.m{1} =>
                   (oget ROM_G.RO.m{1}.[ph]).`1 = oget ROM_JGk.RO2_Default.m{2}.[ph])).
call (:   ={ROM_G.RO.m}
       /\ ROM_J.RO.m{1} = ROM_JGk.RO1_Default.m{2}
       /\ dom ROM_G.RO.m{1} = dom ROM_JGk.RO2_Default.m{2}
       /\ (forall (ph : ptxt_t * rand_t), ph \in ROM_G.RO.m{1} =>
             (oget ROM_G.RO.m{1}.[ph]).`1 = oget ROM_JGk.RO2_Default.m{2}.[ph])).             
+ proc.
  inline{2} get.
  swap{1} 1 1.
  auto => />; smt(get_setE).
+ by proc; auto.
+ by inline init; auto => />; smt(mem_empty). 
swap{1} 4 3.
seq 5 4 : #post; 2: by inline; auto.
inline get.
wp; rnd{1}; rnd; wp; rnd.
by wp; rnd{1}; rnd{1}; wp; skip => /> &1 &2 *; smt(get_setE).
qed.


(* Case 4: k0_ = k1_ (i.e., J collides with J) *)
local clone ROMx2 as ROM_JJ with
  type in_t1 <- ctxt_t,
  type in_t2 <- ctxt_t,
  type out_t <- key_t,
  
    op dout <- dkey
    
  proof *.
  realize dout_ll by exact: dkey_ll.


local module JW12 (RO1 : ROM_JJ.RandomOracle1) (RO2 : ROM_JJ.RandomOracle2) : RandomOracle2 = {
  var z0, z1 : rand_t 
  var mr : (rand_t * ctxt_t, key_t) fmap
  
  proc init(z0_init : rand_t, z1_init : rand_t) : unit = {
    z0 <- z0_init;
    z1 <- z1_init;
    mr <- empty;
  }
  
  proc get(rc : rand_t * ctxt_t) : key_t = { 
    var k : key_t;
    
    if (rc.`1 = z0) { 
      k <@ RO1.get(rc.`2);
    } elif (rc.`1 = z1) {
      k <@ RO2.get(rc.`2);
    } else { (* rc.`1 <> z0 /\ rc.`1 <> z1 *)
      k <$ dkey;
      if (rc \notin mr) {
        mr.[rc] <- k;
      }
      k <- oget mr.[rc];
    }
    
    return k;
  }
}.
  
  
local module (R_CRROMx2JJ_LEAKBINDKCT : ROM_JJ.Adv_CRROMx2) 
             (RO1 : ROM_JJ.RandomOracle1) (RO2 : ROM_JJ.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : ctxt_t * ctxt_t = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  

    G_RO.init();
        
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    JW12(RO1, RO2).init(z0, z1);
    
    (c0, c1) <@ A(JW12(RO1, RO2), G_RO_SSample).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    return (c0, c1);
  }
}.

local lemma Bnd_JJcoll_CRROMx2 &m :
  Pr[LEAK_BINDKPK_MLKEM_ROM_JG.main(K_Binds_PK) @ &m :
         LEAK_BINDKPK_MLKEM_ROM_JG.z0 <> LEAK_BINDKPK_MLKEM_ROM_JG.z1
      /\ LEAK_BINDKPK_MLKEM_ROM_JG.k0_ = LEAK_BINDKPK_MLKEM_ROM_JG.k1_]
  <=
  Pr[ROM_JJ.CR_ROM_x2(ROM_JJ.RO1_Default, ROM_JJ.RO2_Default, R_CRROMx2JJ_LEAKBINDKCT).main() @ &m : res].
proof.
byequiv => //.
proc.
swap{1} 18 -3.
swap{1} [14..15] -2.
seq 13 5 : #post; 2: by inline; auto. 
inline{2} 3.
swap{1} 3 -2; swap{2} 4 -3.  
swap{1} 7 -5; swap{2} 8 -6.
seq 2 2 : (   #pre 
           /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.z0, LEAK_BINDKPK_MLKEM_ROM_JG.z1}). 
+ by rnd; rnd.
case (LEAK_BINDKPK_MLKEM_ROM_JG.z0{1} = LEAK_BINDKPK_MLKEM_ROM_JG.z1{1}).
+ conseq (: _ ==> true) => //.
  inline.
  auto.
  call{1} (A_find_ll G_RO_SSample J_RO).
  + by proc; auto => />; smt(dkey_ll drand_ll).
  + by proc; auto => />; smt(dkey_ll).
  call{2} (A_find_ll G_RO_SSample (JW12(ROM_JJ.RO1_Default, ROM_JJ.RO2_Default))).
  + proc; inline. 
    by auto => />; smt(dkey_ll drand_ll).
  + proc.
    inline get.
    by if; 2: if; auto => />; smt(dkey_ll). 
  by auto.
inline get.
seq 9 11 : (    ={LEAK_BINDKPK_MLKEM_ROM_JG.z0, LEAK_BINDKPK_MLKEM_ROM_JG.z1}
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}
             /\ LEAK_BINDKPK_MLKEM_ROM_JG.z0{1} <> LEAK_BINDKPK_MLKEM_ROM_JG.z1{1}
             /\ (forall (c : ctxt_t),
                   ROM_J.RO.m{1}.[(LEAK_BINDKPK_MLKEM_ROM_JG.z0{1}, c)]
                   =
                   ROM_JJ.RO1_Default.m{2}.[c])
             /\ (forall (c : ctxt_t),
                   ROM_J.RO.m{1}.[(LEAK_BINDKPK_MLKEM_ROM_JG.z1{1}, c)]
                   =
                   ROM_JJ.RO2_Default.m{2}.[c])).
+ call (:   ={ROM_G.RO.m, LEAK_BINDKPK_MLKEM_ROM_JG.z0, LEAK_BINDKPK_MLKEM_ROM_JG.z1}
         /\ JW12.z0{2} = LEAK_BINDKPK_MLKEM_ROM_JG.z0{1}
         /\ JW12.z1{2} = LEAK_BINDKPK_MLKEM_ROM_JG.z1{1}
         /\ JW12.z0{2} <> JW12.z1{2}
         /\ (forall (c : ctxt_t), ROM_J.RO.m{1}.[(JW12.z0{2}, c)] = ROM_JJ.RO1_Default.m{2}.[c])
         /\ (forall (c : ctxt_t), ROM_J.RO.m{1}.[(JW12.z1{2}, c)] = ROM_JJ.RO2_Default.m{2}.[c])
         /\ (forall (z : rand_t) (c : ctxt_t), z <> JW12.z0{2} /\ z <> JW12.z1{2} =>
               ROM_J.RO.m{1}.[(z, c)] = JW12.mr{2}.[(z, c)])).
  + by proc; auto.
  + proc.
    inline get.
    if{2}.
    + case (rc{2}.`2 \notin ROM_JJ.RO1_Default.m{2}).
      + rcondt{1} ^if; 1: by auto => /> /#.
        rcondt{2} ^if; 1: by auto.
        by auto => />; smt(get_setE).
      rcondf{1} ^if; 1: by auto => /> /#.
      rcondf{2} ^if; 1: by auto.
      by auto => />; smt(get_setE).
    if{2}.
    + case (rc{2}.`2 \notin ROM_JJ.RO2_Default.m{2}).
      + rcondt{1} ^if; 1: by auto => /> /#.
        rcondt{2} ^if; 1: by auto.
        by auto => />; smt(get_setE).
      rcondf{1} ^if; 1: by auto => /> /#.
      rcondf{2} ^if; 1: by auto.
      by auto => />; smt(get_setE).
    by auto => />; smt(get_setE).
  inline init.
  by auto => />; smt(mem_empty).
wp; rnd; wp; rnd. 
by wp; skip => />; smt(get_setE).
qed.


local module (R_CRROMx2GkGk_LEAKBINDKCT_Qs : ROM_GkGk.Adv_CRROMx2) 
             (RO1 : ROM_GkGk.RandomOracle1) (RO2 : ROM_GkGk.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  import var Counting_RO1
  
  proc find() : ptxt_t * ptxt_t = { 
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    q <- 0;
    J_RO.init();
    
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    GW12(RO1, RO2).init(H pk0, H pk1);
    
    (c0, c1) <@ A(J_RO, Counting_RO1(GW12(RO1, RO2))).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;    
    p1' <- dec sk_pke1 c1;
    
    return (p0', p1');
  }
}.

local lemma EqPr_GkGk_CRROMx2_Qs &m :
  Pr[ROM_GkGk.CR_ROM_x2(ROM_GkGk.RO1_Default, ROM_GkGk.RO2_Default, R_CRROMx2GkGk_LEAKBINDKCT).main() @ &m : res]
  =
  Pr[ROM_GkGk.CR_ROM_x2(ROM_GkGk.RO1_Default, ROM_GkGk.RO2_Default, R_CRROMx2GkGk_LEAKBINDKCT_Qs).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{1} 3; inline{2} 3.
seq 13 14 : (   ={ROM_GkGk.RO1_Default.m, ROM_GkGk.RO2_Default.m} 
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1, LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0}); 2: by sim.
call (:   ={glob GW12, RO.m, ROM_GkGk.RO1_Default.m, ROM_GkGk.RO2_Default.m}
       /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1, LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0}).
+ proc; inline{2} 1.
  sp 0 1; wp 1 1. 
  by sim.
+ by sim.
inline init. 
by auto.
qed.
  
(*
  Translate the assumption regarding the adversary's G oracle 
  queries to concrete statements usable in the current stage 
  of the proof.
*)
local lemma A_find_qG_GkGk_1 (O1 <: ROM_GkGk.RandomOracle1{-R_CRROMx2GkGk_LEAKBINDKCT_Qs, -ROM_GkGk.Counting_RO1}) 
                             (O2 <: ROM_GkGk.RandomOracle1{-R_CRROMx2GkGk_LEAKBINDKCT_Qs, -ROM_GkGk.Counting_RO1, -O1}) :
  hoare[A(J_RO, Counting_RO1(GW12(ROM_GkGk.Counting_RO1(O1), O2))).find :
                Counting_RO1.q = 0
             /\ ROM_GkGk.Counting_RO1.q = 0
         ==> 
                ROM_GkGk.Counting_RO1.q <= qG].
proof.
conseq (: ROM_GkGk.Counting_RO1.q <= Counting_RO1.q ==> ROM_GkGk.Counting_RO1.q <= Counting_RO1.q)
       (A_find_qG (GW12(ROM_GkGk.Counting_RO1(O1), O2)) J_RO) => //; 1: smt().
proc (ROM_GkGk.Counting_RO1.q <= Counting_RO1.q) => //.
+ proc.
  inline 1.
  sp 1; wp 1. 
  if => //.    
  + seq 1 : (#pre); 1: by rnd.
    if => //.
    + inline.
      wp.
      call (: true).
      by wp; skip => /> /#.
    by wp; skip => /> /#. 
  if => //.
  + seq 1 : (#pre); 1: by rnd.
    if => //.
    + inline.
      wp.
      call (: true).
      by wp; skip => /> /#.
    by wp; skip => /> /#. 
  by auto => /> /#.
by proc; auto.
qed.

local lemma A_find_qG_GkGk_2 (O1 <: ROM_GkGk.RandomOracle1{-R_CRROMx2GkGk_LEAKBINDKCT_Qs, -ROM_GkGk.Counting_RO2}) 
                             (O2 <: ROM_GkGk.RandomOracle1{-R_CRROMx2GkGk_LEAKBINDKCT_Qs, -ROM_GkGk.Counting_RO2, -O1}) :
  hoare[A(J_RO, Counting_RO1(GW12(O1, ROM_GkGk.Counting_RO2(O2)))).find :
                Counting_RO1.q = 0
             /\ ROM_GkGk.Counting_RO2.q = 0 
         ==> 
                ROM_GkGk.Counting_RO2.q <= qG].
proof.
conseq (: ROM_GkGk.Counting_RO2.q <= Counting_RO1.q ==> ROM_GkGk.Counting_RO2.q <= Counting_RO1.q)
       (A_find_qG (GW12(O1, ROM_GkGk.Counting_RO2(O2))) J_RO) => //; 1: smt().
proc (ROM_GkGk.Counting_RO2.q <= Counting_RO1.q) => //.
+ proc.
  inline 1.
  sp 1; wp 1. 
  if => //.    
  + seq 1 : (#pre); 1: by rnd.
    if => //.
    + inline.
      wp.
      call (: true).
      by wp; skip => /> /#.
    by wp; skip => /> /#. 
  if => //.
  + seq 1 : (#pre); 1: by rnd.
    if => //.
    + inline.
      wp.
      call (: true).
      by wp; skip => /> /#.
    by wp; skip => /> /#. 
  by auto => /> /#.
by proc; auto.
qed.

local lemma Bnd_GkGk_CRROMx2_Qs &m :
  Pr[ROM_GkGk.CR_ROM_x2(ROM_GkGk.RO1_Default, ROM_GkGk.RO2_Default, R_CRROMx2GkGk_LEAKBINDKCT_Qs).main() @ &m : res]
  <=
  (qG ^ 2 + 1)%r * p_max dkey.
proof.
rewrite expr2.
apply: (ROM_GkGk.Bnd_CRROMx2 R_CRROMx2GkGk_LEAKBINDKCT_Qs _ _ ge0_qG _ _ ge0_qG). 
+ move=> O1 O2 O1ll O2ll.
  proc; inline. 
  wp; call (A_find_ll (Counting_RO1(GW12(O1, O2))) J_RO).
  + proc; inline 1.
    wp 2; sp 1.
    if; 2: if; last by auto => />; smt(dkey_ll drand_ll).
    + wp.
      seq 1 : true 1%r 1%r 0%r 0%r => //; first by auto => />; smt(drand_ll).
      by if => //; wp; call O1ll.      
    wp.
    seq 1 : true 1%r 1%r 0%r 0%r => //; first by auto => />; smt(drand_ll).
    by if => //; wp; call O2ll.
  + by proc; auto => />; smt(dkey_ll).
  by auto => />; smt(drand_ll dkg_ll).
+ move => O1 O2.
  proc; inline.
  wp.
  call (A_find_qG_GkGk_1 O1 O2).
  by auto.
move => O1 O2.
proc; inline.
wp.
call (A_find_qG_GkGk_2 O1 O2).
by auto.
qed.


local module (R_CRROMx2GkJ_LEAKBINDKCT_Qs : ROM_GkJ.Adv_CRROMx2) 
             (RO1 : ROM_GkJ.RandomOracle1) (RO2 : ROM_GkJ.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : (ptxt_t * rand_t) * (rand_t * ctxt_t) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    Counting_RO1.q <- 0;
    Counting_RO2.q <- 0;
    
    GW1(RO1).init();
            
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
        
    (c0, c1) <@ A(Counting_RO2(RO2), Counting_RO1(GW1(RO1))).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p0' <- dec sk_pke0 c0;
    
    return ((p0', H pk0), (z1, c1));
  }
}.

local lemma EqPr_GkJ_CRROMx2_Qs &m :
  Pr[ROM_GkJ.CR_ROM_x2(ROM_GkJ.RO1_Default, ROM_GkJ.RO2_Default, R_CRROMx2GkJ_LEAKBINDKCT).main() @ &m : res]
  =
  Pr[ROM_GkJ.CR_ROM_x2(ROM_GkJ.RO1_Default, ROM_GkJ.RO2_Default, R_CRROMx2GkJ_LEAKBINDKCT_Qs).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{1} 3; inline{2} 3.
seq 12 14 : (   ={pk0, ROM_GkJ.RO1_Default.m, ROM_GkJ.RO2_Default.m} 
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.z1}); 2: by sim.
call (:   ={ROM_G.RO.m, ROM_GkJ.RO1_Default.m, ROM_GkJ.RO2_Default.m}
       /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke0, LEAK_BINDKPK_MLKEM_ROM_JG.z1}).
+ proc; inline{2} 1.
  sp 0 1; wp 3 3. 
  by sim. 
+ proc; inline get. 
  sp 0 1; wp 2 2.
  by sim.
inline init. 
by auto.
qed.
  
(*
  Translate the assumption regarding the adversary's J and G oracle 
  queries to concrete statements usable in the current stage 
  of the proof.
*)
local lemma A_find_qG_GkJ (O1 <: ROM_GkJ.RandomOracle1{-R_CRROMx2GkJ_LEAKBINDKCT_Qs, -ROM_GkJ.Counting_RO1}) 
                             (O2 <: ROM_GkJ.RandomOracle2{-R_CRROMx2GkJ_LEAKBINDKCT_Qs, -ROM_GkJ.Counting_RO1, -O1}) :
  hoare[A(Counting_RO2(O2), Counting_RO1(GW1(ROM_GkJ.Counting_RO1(O1)))).find : 
                Counting_RO1.q = 0
             /\ ROM_GkJ.Counting_RO1.q = 0
         ==> 
                ROM_GkJ.Counting_RO1.q <= qG ].
proof.
conseq (: ROM_GkJ.Counting_RO1.q <= Counting_RO1.q ==> ROM_GkJ.Counting_RO1.q <= Counting_RO1.q)
       (A_find_qG (GW1(ROM_GkJ.Counting_RO1(O1))) (Counting_RO2(O2))) => //; 1: smt().
proc (ROM_GkJ.Counting_RO1.q <= Counting_RO1.q) => //.
+ proc.
  inline 1; inline 3.  
  wp; call (: true). 
  by auto => /> /#. 
proc.
by wp; call(: true). 
qed.


local lemma A_find_qJ_GkJ (O1 <: ROM_GkJ.RandomOracle1{-R_CRROMx2GkJ_LEAKBINDKCT_Qs, -ROM_GkJ.Counting_RO2}) 
                         (O2 <: ROM_GkJ.RandomOracle2{-R_CRROMx2GkJ_LEAKBINDKCT_Qs, -ROM_GkJ.Counting_RO2, -O1}) :
  hoare[A(Counting_RO2(ROM_GkJ.Counting_RO2(O2)), Counting_RO1(GW1(O1))).find : 
                Counting_RO2.q = 0
             /\ ROM_GkJ.Counting_RO2.q = 0
         ==> 
                ROM_GkJ.Counting_RO2.q <= qJ ].
proof.
conseq (: ROM_GkJ.Counting_RO2.q <= Counting_RO2.q ==> ROM_GkJ.Counting_RO2.q <= Counting_RO2.q)
       (A_find_qJ (Counting_RO1(GW1(O1))) ((ROM_GkJ.Counting_RO2(O2)))) => //; 1: smt().
proc (ROM_GkJ.Counting_RO2.q <= Counting_RO2.q) => //.
+ proc.
  by wp; call (: true).
proc.
inline 1.
wp; call(: true).
by auto => /> /#. 
qed.

local lemma Bnd_GkJ_CRROMx2_Qs &m :
  Pr[ROM_GkJ.CR_ROM_x2(ROM_GkJ.RO1_Default, ROM_GkJ.RO2_Default, R_CRROMx2GkJ_LEAKBINDKCT_Qs).main() @ &m : res]
  <=
  (qG * qJ + 1)%r * p_max dkey.
proof.
apply: (ROM_GkJ.Bnd_CRROMx2 R_CRROMx2GkJ_LEAKBINDKCT_Qs _ _ ge0_qG _ _ ge0_qJ). 
+ move=> O1 O2 O1ll O2ll.
  proc; inline. 
  wp; call (A_find_ll (Counting_RO1(GW1(O1))) (Counting_RO2(O2))).
  + proc; inline 1.
    by wp; call O1ll; rnd; wp; skip => />; smt(drand_ll). 
  + proc.
    by wp; call O2ll.
  by auto => />; smt(drand_ll dkg_ll).
+ move => O1 O2.
  proc; inline.
  wp.
  call (A_find_qG_GkJ O1 O2).
  by auto.
move => O1 O2.
proc; inline.
wp.
call (A_find_qJ_GkJ O1 O2).
by auto.
qed.

local module (R_CRROMx2JGk_LEAKBINDKCT_Qs : ROM_JGk.Adv_CRROMx2) 
             (RO1 : ROM_JGk.RandomOracle1) (RO2 : ROM_JGk.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  
  proc find() : (rand_t * ctxt_t) * (ptxt_t * rand_t) = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    Counting_RO1.q <- 0;
    Counting_RO2.q <- 0;
    
    GW2(RO2).init();
            
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
        
    (c0, c1) <@ A(Counting_RO2(RO1), Counting_RO1(GW2(RO2))).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    p1' <- dec sk_pke1 c1;
    
    return ((z0, c0), (p1', H pk1));
  }
}.

local lemma EqPr_JGk_CRROMx2_Qs &m :
  Pr[ROM_JGk.CR_ROM_x2(ROM_JGk.RO1_Default, ROM_JGk.RO2_Default, R_CRROMx2JGk_LEAKBINDKCT).main() @ &m : res]
  =
  Pr[ROM_JGk.CR_ROM_x2(ROM_JGk.RO1_Default, ROM_JGk.RO2_Default, R_CRROMx2JGk_LEAKBINDKCT_Qs).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{1} 3; inline{2} 3.
seq 12 14 : (   ={pk1, ROM_JGk.RO1_Default.m, ROM_JGk.RO2_Default.m} 
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.z0, LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1}); 2: by sim.
call (:   ={ROM_G.RO.m, ROM_JGk.RO1_Default.m, ROM_JGk.RO2_Default.m}
       /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.sk_pke1, LEAK_BINDKPK_MLKEM_ROM_JG.z0}).
+ proc; inline{2} 1.
  sp 0 1; wp 3 3. 
  by sim. 
+ proc; inline get. 
  sp 0 1; wp 2 2.
  by sim.
inline init. 
by auto.
qed.
  
(*
  Translate the assumption regarding the adversary's J and G oracle 
  queries to concrete statements usable in the current stage 
  of the proof.
*)
local lemma A_find_qJ_JGk (O1 <: ROM_JGk.RandomOracle1{-R_CRROMx2JGk_LEAKBINDKCT_Qs, -ROM_JGk.Counting_RO1}) 
                         (O2 <: ROM_JGk.RandomOracle2{-R_CRROMx2JGk_LEAKBINDKCT_Qs, -ROM_JGk.Counting_RO1, -O1}) :
  hoare[A(Counting_RO2(ROM_JGk.Counting_RO1(O1)), Counting_RO1(GW2(O2))).find : 
                Counting_RO2.q = 0
             /\ ROM_JGk.Counting_RO1.q = 0
         ==> 
                ROM_JGk.Counting_RO1.q <= qJ ].
proof.
conseq (: ROM_JGk.Counting_RO1.q <= Counting_RO2.q ==> ROM_JGk.Counting_RO1.q <= Counting_RO2.q)
       (A_find_qJ (Counting_RO1(GW2(O2))) (ROM_JGk.Counting_RO1(O1))) => //; 1: smt().
proc (ROM_JGk.Counting_RO1.q <= Counting_RO2.q) => //.
+ proc.
  inline 1.  
  wp; call (: true). 
  by auto.
proc.
inline 1.
wp; call(: true). 
by auto => /> /#.
qed.

local lemma A_find_qG_JGk (O1 <: ROM_JGk.RandomOracle1{-R_CRROMx2JGk_LEAKBINDKCT_Qs, -ROM_JGk.Counting_RO2}) 
                         (O2 <: ROM_JGk.RandomOracle2{-R_CRROMx2JGk_LEAKBINDKCT_Qs, -ROM_JGk.Counting_RO2, -O1}) :
  hoare[A(Counting_RO2(O1), Counting_RO1(GW2(ROM_JGk.Counting_RO2(O2)))).find : 
                Counting_RO1.q = 0
             /\ ROM_JGk.Counting_RO2.q = 0
         ==> 
                ROM_JGk.Counting_RO2.q <= qG ].
proof.
conseq (: ROM_JGk.Counting_RO2.q <= Counting_RO1.q ==> ROM_JGk.Counting_RO2.q <= Counting_RO1.q)
       (A_find_qG (GW2(ROM_JGk.Counting_RO2(O2))) (Counting_RO2(O1))) => //; 1: smt().
proc (ROM_JGk.Counting_RO2.q <= Counting_RO1.q) => //.
+ proc.
  inline 1; inline 3.  
  wp; call (: true). 
  by auto => /> /#.
proc.
wp; call(: true). 
by auto.
qed.


local lemma Bnd_JGk_CRROMx2_Qs &m :
  Pr[ROM_JGk.CR_ROM_x2(ROM_JGk.RO1_Default, ROM_JGk.RO2_Default, R_CRROMx2JGk_LEAKBINDKCT_Qs).main() @ &m : res]
  <=
  (qJ * qG + 1)%r * p_max dkey.
proof.
apply: (ROM_JGk.Bnd_CRROMx2 R_CRROMx2JGk_LEAKBINDKCT_Qs _ _ ge0_qJ _ _ ge0_qG). 
+ move=> O1 O2 O1ll O2ll.
  proc; inline. 
  wp; call (A_find_ll (Counting_RO1(GW2(O2))) (Counting_RO2(O1))).
  + proc; inline 1.
    by wp; call O2ll; rnd; wp; skip => />; smt(drand_ll). 
  + proc.
    by wp; call O1ll.
  by auto => />; smt(drand_ll dkg_ll).
+ move => O1 O2.
  proc; inline.
  wp.
  call (A_find_qJ_JGk O1 O2).
  by auto.
move => O1 O2.
proc; inline.
wp.
call (A_find_qG_JGk O1 O2).
by auto.
qed.

local module (R_CRROMx2JJ_LEAKBINDKCT_Qs : ROM_JJ.Adv_CRROMx2) 
             (RO1 : ROM_JJ.RandomOracle1) (RO2 : ROM_JJ.RandomOracle2) = {
  import var LEAK_BINDKPK_MLKEM_ROM_JG
  import var Counting_RO2
  
  proc find() : ctxt_t * ctxt_t = { 
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;  
    
    q <- 0;
    G_RO_SSample.init();
    
    z0 <$ drand;
    (pk_pke0, sk_pke0) <$ dkg;
    pk0 <- pk_pke0;
    sk0 <- (sk_pke0, pk0, H pk0, z0);
    
    z1 <$ drand;
    (pk_pke1, sk_pke1) <$ dkg;
    pk1 <- pk_pke1;
    sk1 <- (sk_pke1, pk1, H pk1, z1);
    
    JW12(RO1, RO2).init(z0, z1);
    
    (c0, c1) <@ A(Counting_RO2(JW12(RO1, RO2)), G_RO_SSample).find(K_Binds_PK, pk0, sk0, pk1, sk1);
    
    return (c0, c1);
  }
}.

local lemma EqPr_JJ_CRROMx2_Qs &m :
  Pr[ROM_JJ.CR_ROM_x2(ROM_JJ.RO1_Default, ROM_JJ.RO2_Default, R_CRROMx2JJ_LEAKBINDKCT).main() @ &m : res]
  =
  Pr[ROM_JJ.CR_ROM_x2(ROM_JJ.RO1_Default, ROM_JJ.RO2_Default, R_CRROMx2JJ_LEAKBINDKCT_Qs).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{1} 3; inline{2} 3.
seq 13 14 : (   ={ROM_JJ.RO1_Default.m, ROM_JJ.RO2_Default.m} 
             /\ ={LEAK_BINDKPK_MLKEM_ROM_JG.c0, LEAK_BINDKPK_MLKEM_ROM_JG.c1}); 2: by sim.
call (:   ={glob JW12, ROM_G.RO.m, ROM_JJ.RO1_Default.m, ROM_JJ.RO2_Default.m}).
+ by proc; auto. 
+ proc; inline{2} 1. 
  sp 0 1; wp 1 1. 
  by sim.
inline init. 
by auto.
qed.
  
(*
  Translate the assumption regarding the adversary's G oracle 
  queries to concrete statements usable in the current stage 
  of the proof.
*)
local lemma A_find_qJ_JJ_1 (O1 <: ROM_JJ.RandomOracle1{-R_CRROMx2JJ_LEAKBINDKCT_Qs, -ROM_JJ.Counting_RO1}) 
                           (O2 <: ROM_JJ.RandomOracle1{-R_CRROMx2JJ_LEAKBINDKCT_Qs, -ROM_JJ.Counting_RO1, -O1}) :
  hoare[A(Counting_RO2(JW12(ROM_JJ.Counting_RO1(O1), O2)), G_RO_SSample).find :
                Counting_RO2.q = 0
             /\ ROM_JJ.Counting_RO1.q = 0
         ==> 
                ROM_JJ.Counting_RO1.q <= qJ].
proof.
conseq (: ROM_JJ.Counting_RO1.q <= Counting_RO2.q ==> ROM_JJ.Counting_RO1.q <= Counting_RO2.q)
       (A_find_qJ G_RO_SSample (JW12(ROM_JJ.Counting_RO1(O1), O2))) => //; 1: smt().
proc (ROM_JJ.Counting_RO1.q <= Counting_RO2.q) => //.
+ by proc; auto. 
proc.
inline 1.
sp 1; wp 1. 
if => //.    
+ inline 1. 
  wp.
  call (: true).
  by wp; skip => /> /#.
if => //.
+ call (: true). 
  by skip => /> /#. 
by auto => /> /#. 
qed.

local lemma A_find_qJ_JJ_2 (O1 <: ROM_JJ.RandomOracle1{-R_CRROMx2JJ_LEAKBINDKCT_Qs, -ROM_JJ.Counting_RO2}) 
                           (O2 <: ROM_JJ.RandomOracle1{-R_CRROMx2JJ_LEAKBINDKCT_Qs, -ROM_JJ.Counting_RO2, -O1}) :
  hoare[A(Counting_RO2(JW12(O1, ROM_JJ.Counting_RO2(O2))), G_RO_SSample).find :
                Counting_RO2.q = 0
             /\ ROM_JJ.Counting_RO2.q = 0
         ==> 
                ROM_JJ.Counting_RO2.q <= qJ].
proof.
conseq (: ROM_JJ.Counting_RO2.q <= Counting_RO2.q ==> ROM_JJ.Counting_RO2.q <= Counting_RO2.q)
       (A_find_qJ G_RO_SSample (JW12(O1, ROM_JJ.Counting_RO2(O2)))) => //; 1: smt().
proc (ROM_JJ.Counting_RO2.q <= Counting_RO2.q) => //.
+ by proc; auto. 
proc.
inline 1.
sp 1; wp 1. 
if => //.
+ call (: true).
  by skip => /> /#.
if => //.
+ inline 1.
  wp; call (: true).
  by wp; skip => /> /#. 
by auto => /> /#. 
qed.

local lemma Bnd_JJ_CRROMx2_Qs &m :
  Pr[ROM_JJ.CR_ROM_x2(ROM_JJ.RO1_Default, ROM_JJ.RO2_Default, R_CRROMx2JJ_LEAKBINDKCT_Qs).main() @ &m : res]
  <=
  (qJ ^ 2 + 1)%r * p_max dkey.
proof.
rewrite expr2.
apply: (ROM_JJ.Bnd_CRROMx2 R_CRROMx2JJ_LEAKBINDKCT_Qs _ _ ge0_qJ _ _ ge0_qJ). 
+ move=> O1 O2 O1ll O2ll.
  proc; inline. 
  wp; call (A_find_ll G_RO_SSample (Counting_RO2(JW12(O1, O2)))).
  + by proc; auto => />; smt(dkey_ll drand_ll).
  + proc.
    inline 1.
    wp 2; sp 1.
    if; 2: if; last by auto => />; smt(dkey_ll).
    + by call O1ll. 
    by call O2ll. 
  by auto=> />; smt(drand_ll dkg_ll). 
+ move => O1 O2.
  proc; inline.
  wp.
  call (A_find_qJ_JJ_1 O1 O2).
  by auto.
move => O1 O2.
proc; inline.
wp.
call (A_find_qJ_JJ_2 O1 O2).
by auto.
qed.


(**
  LEAK-BIND-K-PK for ML-KEM-HL in the ROM 
  (modeling G and J as random oracles).
  Bound using separated queries for G and J (i.e., qG and qJ).
**)
lemma Bnd_MLKEMHL_LEAKBINDKPK_ROM_Qs_Sep &m :  
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG, A).main(K_Binds_PK) @ &m : res]
  <=
    (qG ^ 2 + 1)%r * p_max dkey
  + (qG * qJ + 1)%r * p_max dkey
  + (qJ * qG + 1)%r * p_max dkey
  + (qJ ^ 2 + 1)%r * p_max dkey
  + p_max drand 
  + p_max (dmap dkg (fun (kp : pk_t_pke * sk_t_pke) => H kp.`1)).
proof.
rewrite EqPr_LEAKBINDROMJG_KPK.
rewrite (StdOrder.RealOrder.ler_trans _ _ _ (Bnd_LEAKBINDROMJG_KPK_CD &m)).
move: (Bnd_GkGkcoll_CRROMx2 &m) (Bnd_GkJcoll_CRROMx2 &m) (Bnd_JGkcoll_CRROMx2 &m) (Bnd_JJcoll_CRROMx2 &m). 
rewrite EqPr_GkGk_CRROMx2_Qs EqPr_GkJ_CRROMx2_Qs EqPr_JGk_CRROMx2_Qs EqPr_JJ_CRROMx2_Qs.
by move: (Bnd_GkGk_CRROMx2_Qs &m) (Bnd_GkJ_CRROMx2_Qs &m) (Bnd_JGk_CRROMx2_Qs &m) (Bnd_JJ_CRROMx2_Qs &m) => /#. 
qed.


(**
  LEAK-BIND-K-PK for ML-KEM-HL in the ROM 
  (modeling G and J as random oracles).
  Bound using combined queries for G and J (i.e., q).
**)
lemma Bnd_MLKEMHL_LEAKBINDKPK_ROM_Qs_Comb &m :  
  Pr[LEAK_BIND_ROMx2(J_RO, G_RO, ML_KEM_HL_ROM_JG, A).main(K_Binds_PK) @ &m : res]
  <=
    (q ^ 2 + 4)%r * p_max dkey 
  + p_max drand 
  + p_max (dmap dkg (fun (kp : pk_t_pke * sk_t_pke) => H kp.`1)).
proof.
rewrite (StdOrder.RealOrder.ler_trans _ _ _ (Bnd_MLKEMHL_LEAKBINDKPK_ROM_Qs_Sep &m)).
by rewrite (expr2 q) /q mulrDl 2!mulrDr -2!expr2 /#.
qed.


end section MLKEMHL_LEAKBINDKPK_ROMx2.
