(*^ 
  Binding security for (very) high-level specification of ML-KEM.
  Specification considered here abstracts away from any algebraic
  structure used in the construction, particularly 
  viewing the PKE procedures as abstract (black box) operators.
  To be instantiated and linked to lower-level specification
  and, in turn, implementation.
^*)
(* Require/Import *)
require import AllCore Distr PROM.
require (*--*) DMap.
require (*--*) HashFunctions KeyedHashFunctions KeyEncapsulationMechanismsROM.


(* Types *)
(* General *)
(** Randomness ("seeds") **)
type rand_t.


(* Underlying PKE scheme (K-PKE) *)
(** Public keys **)
type pk_t_pke.

(** Secret keys **)
type sk_t_pke.

(** Plaintexts of underlying PKE scheme **)
type ptxt_t = rand_t.

(** Ciphertexts **)
type ctxt_t_pke.


(* KEM (ML-KEM *)
(** Public keys **)
type pk_t = pk_t_pke.

(** Secret keys  **)
type sk_t = sk_t_pke * pk_t * rand_t * rand_t.

(** Shared/session keys (symmetric) **)
type key_t = rand_t.

(** Ciphertexts/Encapsulations **)
type ctxt_t = ctxt_t_pke.


(* Operators *)
(** Hash function H, used to hash public keys **)
op H : pk_t -> rand_t.

(** Hash function J ("keyed"), used to compute implicit rejection key **)
op J : rand_t -> ctxt_t -> key_t.

(** Operator capturing "derandomized" key generation of underlying PKE scheme **)
op kg : rand_t -> pk_t_pke * sk_t_pke.

(** Operator capturing "derandomized" encryption function of underlying PKE scheme **)
op enc : rand_t -> pk_t_pke -> ptxt_t -> ctxt_t_pke.

(** Operator capturing decryption function of underlying PKE scheme **)
(**
  By design, the underlying PKE scheme never returns a failure, 
  so we refrain from using option monad as output.
**)
op dec : sk_t_pke -> ctxt_t_pke -> ptxt_t.


(* Distributions *)
(** Proper, full, and uniform distribution over randomness **)
op [lossless full uniform] drand : rand_t distr.

(** Proper, full, and uniform distribution over (shared) keys **)
op [lossless full uniform] dkey : key_t distr.

(** Proper, full, and uniform distribution over pairs of (shared) keys and randomness **) 
op [lossless full uniform] dkeyrand : (key_t * rand_t) distr.

(** `dkeyrand` is equal to the product distribution of dkey and drand **)
lemma dkeyrand_dprod : dkeyrand = dkey `*` drand.
proof. 
rewrite &(eq_funi_ll) ?is_full_funiform ?(dkeyrand_ll, dkeyrand_fu, dkeyrand_uni).
+ by rewrite dprod_fu_auto ?(dkey_fu, drand_fu) /=. 
+ by rewrite dprod_uni 1,2:(dkey_uni, drand_uni). 
by rewrite dprod_ll_auto 1,2:(dkey_ll, drand_ll). 
qed.

(** Distribution representing key generation of underlying PKE scheme **)
op dkg : (pk_t_pke * sk_t_pke) distr = dmap drand kg.

(** `dkg` is a proper distribution **)
lemma dkg_ll : is_lossless dkg.
proof. by rewrite dmap_ll drand_ll. qed.


(* Clones/Imports *)
(* Definitions and properties for H as a (non-keyed) hash function *)
clone import HashFunctions as H_HF with
  type in_t <- pk_t,
  type out_t <- rand_t,
  
  op f <- H
  
  proof *.
  
(* Definitions and properties for G as a random oracle *)
clone import FullRO as G_RO with
  type in_t <- ptxt_t * rand_t,
  type out_t <- key_t * rand_t,
 
  op dout <- fun _ => dkeyrand
  
  proof *.

(* Definitions and properties for J as a keyed hash function *)
clone import KeyedHashFunctions as J_KHF with 
  type key_t <- rand_t,
  type in_t <- ctxt_t,
  type out_t <- key_t,
  
  op f <- J
  
  proof *. 

(* PRF property for J *)
clone import PRF as J_PRF with
  op dkey <- drand,
  op doutm <- fun _ => dkey,
  
  axiom dkey_ll <- drand_ll
  
  proof *.
  realize doutm_ll by move=> ?; exact: dkey_ll.

 
(* Definitions and properties for KEMs (in the ROM) with types as required for ML-KEM *)
clone import KeyEncapsulationMechanismsROM as KEMsROM with
  type pk_t <- pk_t,
  type sk_t <- sk_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t,
  
  type in_t <- ptxt_t * rand_t, 
  type out_t <- key_t * rand_t
  
  proof *.

(* Non-ROM KEM definitions consistent with above instantiation *) 
import KEMs.


(*
  Note:
  The official FIPS 203 specification of ML-KEM lists only a single G
  function mapping arbitrary-length bit strings 
  (to be instantiated with sha3-512) that is used
  (1) in key generation to expand a single seed to two seeds 
  and (2) in encapsulation/decapsulation to (simulataneously) 
  generate a shared key and a randomness value (each having
  the size of a seed). Now, in an attempt minimize the 
  assumptions on the employed primitives (as well
  as simplify the reasoning), we make use of the fact that 
  the set of possible inputs given to G in key generation is 
  disjoint from the set of possible inputs given to G in
  encapsulation/decapsulation. Particularly, this implies we can
  regard these different uses of G as different (sub)functions, 
  allowing us to require the PRG property for one function
  and model another one as an RO. If we wouldn't take this approach,
  we would need to model G (as a whole) as an RO.   
  As a direct consequence, the key generation can be modeled as sampling 
  from some distribution that captures the sampling and 
  operations (including the PRG evaluations) performed by the key generation
  procedure. This is also the approach taken in the current IND-CCA proof 
  for ML-KEM, which gives another reason to also adopt it here (so equivalence proofs 
  are easier later on). Here, we denote the distribution representing key
  generation by dkg (see above).
*)

(* 
  Next steps:
  Define module K-PKE (straightforwardrly using above distributions and operators)
  Next, use it to define ML-KEM-HL (w.r.t. random oracle).
  Then, start proving binding properties for ML-KEM-HL in ROM
  (use PROM for RO instantiation).
  Penultimately, show equivalence of ML-KEM-HL to FO-K (in ROM),
  and binding properties for FO-K as a result.
  Finally, show binding properties for FO-K imply binding properties
  for ML-KEM-Op (which in turn gives the whole chain down to implementation,
  if code still works)
*)


(* Schemes *)
(** K-PKE, PKE scheme underlying ML-KEM **)
(** 
  As per FIPS 203, we specify the PKE in a derandomized manner.
  That is, any procedure using randomness (i.e., key generation and encryption)
  takes it as input rather than sampling it itself. This also means
  it does not adhere to the regular syntax of a PKE scheme. 
**)  
(**
  Further, this is a (very) high-level specification, essentially abstracting
  away all algebraic structure and modeling the procedures as simple operators 
  (which is possible because all randomness is taken as input)
**)
module K_PKE_HL = {
  proc keygen(d : rand_t) : pk_t_pke * sk_t_pke = {
    return kg d;
  }
  
  proc enc(pk : pk_t_pke, m : ptxt_t, r : rand_t) : ctxt_t_pke = {
    return enc r pk m;
  }
  
  proc dec(sk : sk_t_pke, c : ctxt_t_pke) : ptxt_t = {
    return dec sk c;
  } 
}.


(**
  ML-KEM, where the key/randomness function is modeled as RO.
  Closely follows FIPS 203 (without accounting for sampling failures, so 
  the "internal" ML-KEM procedures are most relevant). 
**)
module (ML_KEM_HL_ROM : Scheme_ROM) (G : RandomOracle) = { 
  proc keygen() : pk_t * sk_t = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var d, z : rand_t;
    var pk : pk_t;
    var sk : sk_t;
    
    d <$ drand;
    z <$ drand;
    
    (pk_pke, sk_pke) <@ K_PKE_HL.keygen(d);
    
    pk <- pk_pke;
    sk <- (sk_pke, pk, H pk, z);
    
    return (pk, sk);
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var m, r : rand_t; 
    var k : key_t;
    var c : ctxt_t_pke;
    
    m <$ drand;
    (k, r) <@ G.get((m, H pk));
    
    c <@ K_PKE_HL.enc(pk, m, r);
        
    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var m' : ptxt_t;
    var k', k_ : key_t;
    var c' : ctxt_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    m' <@ K_PKE_HL.dec(sk_pke, c);
    
    (k', r') <@ G.get((m', h));
    k_ <- J z c;
    
    c' <@ K_PKE_HL.enc(pk_pke, m', r');
    
    if (c <> c') {
      k' <- k_;
    }
    
    return Some k';
  }
}.

(** 
  Trimmed version of ML_KEM_HL_ROM (e.g., inlined procedures, less variables).
  Equivalent to the standard version above (as shown in the corresponding lemmas).
**)
(**
  Besides inlining and removing variables, the sampling of randomness into "derandomized" 
  key generation is replaced by directly sampling from the appropriate distribution (dkg). 
**)
module (ML_KEM_HL_ROM_Trim : Scheme_ROM) (G : RandomOracle) = { 
  proc keygen() : pk_t * sk_t = {
    var z : rand_t;
    var sk_pke : sk_t_pke;
    var pk : pk_t;
        
    z <$ drand;
    (pk, sk_pke) <$ dkg;
    
    return (pk, (sk_pke, pk, H pk, z));
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var m, r : rand_t; 
    var k : key_t;
    
    m <$ drand;
    (k, r) <@ G.get((m, H pk));
     
    return (k, enc r pk m);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var pk_pke : pk_t_pke;
    var sk_pke : sk_t_pke;
    var h, z, r' : rand_t;
    var m' : ptxt_t;
    var k' : key_t;
    
    (sk_pke, pk_pke, h, z) <- sk;
    
    m' <- dec sk_pke c;
    
    (k', r') <@ G.get((m', h));
    
    return Some (if c <> enc r' pk_pke m' then J z c else k');
  }
}.


(* Section for proving equivalence of key generation procedures, hiding auxiliary artifacts *)
section.
(* Auxiliary clone for proving sampling equivalence *)
local clone DMap.DMapSampling as DMS with
  type t1 <- rand_t,
  type t2 <- pk_t_pke * sk_t_pke
  
  proof *.

(** 
  Equivalence between key generation procedures of ML_KEM_HL_ROM 
  and ML_KEM_HL_ROM_Trim, for any instantiation of the oracle
**)    
equiv Eqv_ML_KEM_HL_ROM_Trim_Keygen (G <: RandomOracle) :
  ML_KEM_HL_ROM(G).keygen ~ ML_KEM_HL_ROM_Trim(G).keygen : true ==> ={res}.
proof. 
proc.
inline K_PKE_HL.keygen; swap{1} 1 1.
wp.
transitivity{2} { z <$ drand; (pk, sk_pke) <@ DMS.S.sample(drand, kg); } 
                (true 
                 ==> 
                 let tpl = kg d{1} in 
                   (tpl.`1, (tpl.`2, tpl.`1, H tpl.`1, z{1})) 
                   = 
                   (pk{2}, (sk_pke{2}, pk{2}, H pk{2}, z{2}))) 
                (true ==> ={z, pk, sk_pke}) => //.
+ rewrite equiv[{2} 2 DMS.sample].
  inline{2} DMS.S.map.
  by wp; rnd; wp; rnd; skip.
inline{1} DMS.S.sample.
by wp; rnd; wp; rnd. 
qed.

end section.

(** 
  Equivalence between encapsulation procedures of ML_KEM_HL_ROM 
  and ML_KEM_HL_ROM_Trim, for any instantiation of the oracle
**) 
equiv Eqv_ML_KEM_HL_ROM_Trim_Encaps (G <: RandomOracle) :
  ML_KEM_HL_ROM(G).encaps ~ ML_KEM_HL_ROM_Trim(G).encaps : ={glob G, arg} ==> ={res}.
proof.
proc.
inline K_PKE_HL.enc.
by wp; sim.
qed.

(** 
  Equivalence between decapsulations procedures of ML_KEM_HL_ROM 
  and ML_KEM_HL_ROM_Trim, for any instantiation of the oracle
**) 
equiv Eqv_ML_KEM_HL_ROM_Trim_Decaps (G <: RandomOracle) :
  ML_KEM_HL_ROM(G).decaps ~ ML_KEM_HL_ROM_Trim(G).decaps : ={glob G, arg} ==> ={res}.
proof.
proc.
inline K_PKE_HL.enc K_PKE_HL.dec.
by wp; call (: true); wp.
qed.




(* Proofs *)
(** Counting wrapper around (regular) random oracles, used for query counting **)
module Counting_RO (RO : RandomOraclei) : RandomOraclei = {
  var q : int
  
  proc init() : unit = {
    RO.init();
    q <- 0;
  }
  
  proc get(pr : ptxt_t * rand_t) : key_t * rand_t = {
    var kr : key_t * rand_t;
    
    kr <@ RO.get(pr);
    
    q <- q + 1;
    
    return kr;
  }
}.

(* 
  Proof sketch for LEAK-BIND-K,CT-PK in ROM (G modeled as ROM).
  Assume adversary that breaks LEAK-BIND-K,CT-PK for ML-KEM.
  That means that we are dealing with two independently generated key pairs (pk0, sk0) and (pk1, sk1)
  (due to pk being binding target), both of which are passed to the adversary, 
  upon which it returns a single ciphertext c (actually, it returns two ciphertexts c0 = c1
  by assumption of adversary succeeding; we regard these as a single ciphertext c)
  This ciphertext c is then decapsulated under sk0 and sk1.
  Basic argument:
  - Only looking at the final return values of both decapsulations, the following
    is the case if the adversary succeeds (See ML_KEM_HL_ROM.decaps):
    Some (if c <> enc r0' pk_pke0 m0' then J z0 c else k0')
    =
    Some (if c <> enc r1' pk_pke1 m1' then J z1 c else k1')
    Notice that, because z0 and z1 are independently sampled (due to public key being a binding target),
    J z0 and J z1 can each be replaced by (independent) random functions due to J's PRF property.
    Doing this globally (i.e., before the following case analysis) gives us two PRF terms in the
    bound and lets us reason as follows.
    Case analysis:
    1. c <> enc r0' pk_pke0 m0' /\ c <> enc r1' pk_pke1 m1'
       In this case, adversary succeeds iff J z0 c = J z1 c. 
       Replacing J z0 and J z1 by indpendent random functions (as explained above) means that 
       the probability of this equality holding is bounded by 1 / |seed_t|.
    2. c <> enc r0' pk_pke0 m0' /\ c = enc r1' pk_pke1 m1' 
       In this case, adversary succeeds iff J z0 c = k1'
       Replacing J z0 by a random function (as explained above) means that 
       the probability of this equality holding is bounded by 1 / |seed_t|.
    3. c = enc r0' pk_pke0 m0' /\ c <> enc r1' pk_pke1 m1'
       This case is symmetrical to case 2.
    4. c = enc r0' pk_pke0 m0' /\ c = enc r1' pk_pke1 m1'
       In this case, adversary succeeds iff k0' = k1'
       Alternatively stated, this means the first part of G(m0, h0) equals
       that of G(m1, h1). Here, we want to show that the inputs are not equal so we
       can relate this case to the collision resistance of the random oracle. That is,
       if the input would be equal, the output would also be trivially equal (so in particular also 
       k0' and k1') and the adversary could win. (Note: in case the encryption 
       operator is injective w.r.t. public key, then m0' = m1' and r0' = r1' means that 
       enc r0' pk_pke0 m0' and enc r1' pk_pke1 m1' cannot be equal when pk_pke0 <> pk_pke1.
       Particularly, this means that these encryptions cannot both be equal to (the same) c and,
       hence, messages and randomness cannot be the same for this case to even occur.
       Not sure if this injectivity is a property of the PKE underlying ML-KEM though.)
       Now, since the ciphertexts are equal and the key pairs are independently generated,
       we can do two things to get to the fact that the inputs to G are different:
       m0' <> m1' because otherwise we get a SCFR-LEAK break for the underlying PKE 
       (independently generated key pairs and single ciphertext decrypt to the same plaintext)
       OR h0' <> h1' because (excluding the case that the public keys are equal by a purely
       statistical argument stating that generating the same public keys is not likely) otherwise
       we have a collision for H (different public keys, same output; here, we can exclude the case 
       that the public keys are equal by a purely statistical argument stating that 
       generating the same public keys is not likely). With the different inputs established, 
       a collision for (the first argument of) G can happen in four more ways:
       4.1. The advesary didn't query (m0', h0') and/or didn't query (m1', h1') in its execution,
            but they still collided (in the first part of the output) during decapsulation by the game.
            These are the first three cases, each of which can be bounded by 1 / |key_t|.
       4.2. The adversary queried both (m0', h0') and (m1', h1') in its execution, and they collided
            in the first part of the output. This is a birthday bound.

This feels very crude and suboptimal...
*)
section ML_KEM_HL_LEAKBINDKCTPK_ROM.

declare module A <: Adv_LEAKBIND_ROM {-RO}.

lemma MLKEMHL_LEAKBINDKCTPK_ROM &m : 
  Pr[LEAK_BIND_ROM(RO, ML_KEM_HL_ROM, A).main(KCT_Binds_PK) @ &m : res] <= witness.
proof. admit. qed.

end section ML_KEM_HL_LEAKBINDKCTPK_ROM.


(* 
  Proof sketch for LEAK-BIND-PK,K-CT in ROM (G modeled as ROM).
  Setup and first three cases very similar to LEAK-BIND-K,CT-PK proof, except
  that J only needs to be replaced once since the keys are equal (so in particular the
  seed used to index J is equal). First case still workds because now the ciphertexts are
  different.
  For the fourth (and final case), note that since the considered public keys are equal,
  the hash given to G as a second input are equal. Hence, if the messages obtained from
  decryption would be equal, then *both* k0' = k1' and r0' = r1'. However, then 
  enc r0' pk_pke0 m0' = enc r1' pk_pke1 m1' (because arguments are all the same) and at least
  one of them cannot equal the respective ciphertext (since c0' <> c1' by assumption that the
  adversary wins). Hence, if this case is ever to go through, we have m0' <> m1' and we can
  argue as before about collisions in the random oracle.
*)
section ML_KEM_HL_LEAKBINDPKKCT_ROM.

declare module A <: Adv_LEAKBIND_ROM {-RO}.

lemma MLKEMHL_LEAKBINDKPKCT_ROM &m : 
  Pr[LEAK_BIND_ROM(RO, ML_KEM_HL_ROM, A).main(PKK_Binds_CT) @ &m : res] <= witness.
proof. admit. qed.

end section ML_KEM_HL_LEAKBINDPKKCT_ROM.


(*
  Proof sketch for LEAK-BIND-K-PK in ROM (G modeled as ROM). 
  Same as LEAK-BIND-K,CT-PK, except that we cannot reduce from SCFR-LEAK (on its own at least)
  to "exclude" the case that the plaintext resulting from decryption are equal. This because 
  the ciphertexts might be different (and SCFR requires a single ciphertext). So, here,
  we must resort to CR of H to argue inputs to G are different.
*)
section ML_KEM_HL_LEAKBINDKPK_ROM.

declare module A <: Adv_LEAKBIND_ROM {-RO}.

lemma MLKEMHL_LEAKBINDKPK_ROM &m : 
  Pr[LEAK_BIND_ROM(RO, ML_KEM_HL_ROM, A).main(K_Binds_PK) @ &m : res] <= witness.
proof. admit. qed.

end section ML_KEM_HL_LEAKBINDKPK_ROM.


(* 
  Proof sketch for LEAK-BIND-K-CT in ROM (G modeled as ROM). 
  Combine proof for LEAK-BIND-K,PK-CT and LEAK-BIND-K-PK
  (If adversary chooses equal PK, then LEAK-BIND-K,PK-CT proof, else
   LEAK-BIND-K-PK. Perhaps by reduction even?)
*)
section ML_KEM_HL_LEAKBINDKCT_ROM.

declare module A <: Adv_LEAKBIND_ROM {-RO}.

lemma MLKEMHL_LEAKBINDKCT_ROM &m : 
  Pr[LEAK_BIND_ROM(RO, ML_KEM_HL_ROM, A).main(K_Binds_CT) @ &m : res] <= witness.
proof. admit. qed.

end section ML_KEM_HL_LEAKBINDKCT_ROM.





(* CR of H implies LEAK-BIND-K-PK in the ROM (with G modeled as ROM)
(** Reduction adversary reducing CR of H to LEAK-BIND-K-PK of ML_KEM_HL_ROM **)
print RO. print LEAK_BIND_ROM. print KEMs.LEAK_BIND.
module R_CR_LEAKBINDKPK (A : Adv_LEAKBIND_ROM) : Adv_CR = {
  proc find() : pk_t * pk_t = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var pk0', pk1' : pk_t_pke;
    
    RO.init();
    
    (pk0, sk0) <@ ML_KEM_HL_ROM(RO).keygen();
    (pk1, sk1) <@ ML_KEM_HL_ROM(RO).keygen();
    
    
    
    return witness;  
  }  
}.
*)
