require import AllCore Distr.
require KeyEncapsulationMechanismsROM.


(* Types *)
(** Public keys (asymmetric) **)
type pk_t.

(** Secret keys (asymmetric) **)
type sk_t.

(** Shared/session keys (symmetric) **)
type key_t.

(** Ciphertexts/Encapsulations **)
type ctxt_t.

(** Randomness **)
type rand_t.

(* Inputs to the random oracle *)
type in_t.

(* Outputs of the random oracle *)
type out_t.


(* Operators *)
(** Key derivation function (keyed hash function) **)
op kdf : key_t -> ctxt_t -> key_t.


(* Distributions *)
(**  **)
op dkeym : pk_t -> key_t distr.

  
(* Clones and imports *)
(* Definitions and properties for KEMs in ROM *)
clone import KeyEncapsulationMechanismsROM as KEMsROM with
  type pk_t <- pk_t,
  type sk_t <- sk_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t,
  
  type in_t <- key_t * ctxt_t,
  type out_t <- key_t
  
  proof *.

clone import MALBINDROM with
  type rand_t <- rand_t.

import MALBIND KEMs F_RO.
    
(* Indistinguishability properties (in ROM) *)
clone import INDROM with
  op dkeym <- dkeym
  
  proof *. 

import IND. 


module (KEM_KDF_PP_Ct (S : SchemeDerand) : SchemeDerand_ROM) (RO : RandomOracle) = {
  proc keygen = S.keygen
  
  proc encaps(pk : pk_t, r : rand_t) : key_t * ctxt_t = {
    var k, kpp : key_t;
    var c : ctxt_t;
    
    (k, c) <@ S.encaps(pk, r);
    kpp <@ RO.get((k, c));
    
    return (kpp, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = {
    var ko, kppo : key_t option;
    var kpp : key_t;
    
    ko <@ S.decaps(sk, c);
    
    if (ko = None) {
      kppo <- None;
    } else {
      kpp <@ RO.get((oget ko, c));
      kppo <- Some kpp;
    }
    
    return kppo;
  }
}.

(* Class of adversaries againt CR (of a random oracle) *)
module type Adv_CR_ROM (RO : RandomOracle) = {
  proc find() : (key_t * ctxt_t) * (key_t * ctxt_t)
}.

(* CR (of a random oracle) game *)
module CR_ROM (RO : RandomOraclei, A : Adv_CR_ROM) = {
  proc main() = {
    var kc, kc' : key_t * ctxt_t;
    var k, k' : key_t;
    
    RO.init();
    
    (kc, kc') <@ A(RO).find();
    
    k <@ RO.get(kc);
    k' <@ RO.get(kc');
    
    return kc <> kc' /\ k = k';
  }
}.


module (R_KCT_CR (S : SchemeDerand) (A : Adv_MALBIND_ROM) : Adv_CR_ROM) (RO : RandomOracle) = {
  proc find() : (key_t * ctxt_t) * (key_t * ctxt_t) = {
    var mbs : malbind_scenario;
    var sk0, sk1 : sk_t;
    var r0, r1 : rand_t;
    var c0, c1 : ctxt_t;
    var k0, k1 : key_t;
    var k0o, k1o : key_t option;
    var pk0, pk1 : pk_t;
    var kc0, kc1 : key_t * ctxt_t;
        
    mbs <@ A(RO).choose(K_Binds_CT);
    
    if (mbs = DECAPS_DECAPS) {
      (sk0, sk1, c0, c1) <@ A(RO).find_dd();
    
      pk0 <- sk2pk sk0;
      pk1 <- sk2pk sk1;

      k0o <@ S.decaps(sk0, c0);
      k1o <@ S.decaps(sk1, c1);
      
      kc0 <- (oget k0o, c0);
      kc1 <- (oget k1o, c1);
    } elif (mbs = ENCAPS_DECAPS) {
      (sk0, sk1, r0, c1) <@ A(RO).find_ed();

      pk0 <- sk2pk sk0;
      pk1 <- sk2pk sk1;

      (k0, c0) <@ S.encaps(pk0, r0);
      k1o <@ S.decaps(sk1, c1);
      
      kc0 <- (k0, c0);
      kc1 <- (oget k1o, c1);
    } else { (* mbs = ENCAPS_ENCAPS *)
      (sk0, sk1, r0, r1) <@ A(RO).find_ee();
    
      pk0 <- sk2pk sk0;
      pk1 <- sk2pk sk1;

      (k0, c0) <@ S.encaps(pk0, r0);
      (k1, c1) <@ S.encaps(pk1, r1);
      
      kc0 <- (k0, c0);
      kc1 <- (k1, c1);
    }

    return (kc0, kc1);
  }  
}.



section.

declare module S <: SchemeDerand{-RO}.

declare module A <: Adv_MALBIND_ROM{-S, -RO}.

local lemma test : 
  equiv[MAL_BIND_ROM(RO, KEM_KDF_PP_Ct(S), A).main ~ CR_ROM(RO, R_KCT_CR(S, A)).main : ={glob S, glob A} /\ arg{1} = K_Binds_CT ==> res{1} => res{2}]. 
proof.

qed.

end section.
