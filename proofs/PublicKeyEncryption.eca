(*^
  This library generically defines Public-Key Encryption (PKE) schemes
  and their properties (both correctness and security).
  For convenience, it also provides some sensible defaults, particularly for oracles.
  Most of the content is based on relevant literature.
  More precisely, (almost) all of the content is extracted from 
  one or more of the following papers (in no particular order):
  - [Relations Among Notions of Security for Public-Key Encryption Schemes](https://eprint.iacr.org/1998/021)
  - [Robust Encryption, Revisited](https://eprint.iacr.org/2012/673)
  - [A Modular Analysis of the Fujisaki-Okamoto Transformation](https://eprint.iacr.org/2017/604.pdf)
  - [Completely Non-Malleable Encryption Revisited](https://iacr.org/archive/pkc2008/49390068/49390068.pdf)
  - [New security notions and relations for public-key encryption](https://www.degruyter.com/document/doi/10.1515/jmc-2010-0099)
    (TODO: Add more niche properties (complete non-malleability, key indistinguishability, plaintext awareness)))
^*)

(* Require/Import libraries *)
require import AllCore List DBool.

(* Types *)
(** Public keys **)
type pk_t.

(** Secret keys **)
type sk_t.

(** Plaintext/messages **)
type ptxt_t.

(** Ciphertexts **)
type ctxt_t.


(* Distributions *)
(** (Sub-)Distribution over plaintexts **)
op dptxt : ptxt_t distr.


(* Module types *)
(** PKE scheme (interface) **)
module type Scheme = {
  proc keygen() : pk_t * sk_t
  proc enc(pk : pk_t, p : ptxt_t) : ctxt_t
  proc dec(sk : sk_t, c : ctxt_t) : ptxt_t option 
}.


(* Properties (regular) *)
(** Correctness **)
module Correctness (S : Scheme) = {
  proc main(p : ptxt_t) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var c : ctxt_t;
    var p' : ptxt_t option;
    
    (pk, sk) <@ S.keygen();
    c <@ S.enc(pk, p);
    p' <@ S.dec(sk, c);
    
    return p' = Some p;
  }
}.


(* 
  Chosen-Plaintext Attacks (CPA).
  The adversary is given the considered public key and, hence, 
  is able to produce ciphertexts corresponding to chosen plaintexts.
*)
(*
  One-Wayness under Chosen-Plaintext Attacks (OW-CPA).
  In a CPA setting, the adversary is asked to produce the message/plaintext 
  encrypted by a given ciphertext.
*)
(** Adversary class considered for OW-CPA **)
module type Adv_OWCPA = {
  proc find(pk : pk_t, c : ctxt_t) : ptxt_t
}.

(** OW-CPA security game **)
module OW_CPA (S : Scheme, A : Adv_OWCPA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var p, p' : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    p <$ dptxt;
    c <@ S.enc(pk, p);
    
    p' <@ A.find(pk, c);

    return p' = p; 
  }
}.


(*
  (ciphertext) INDistinguishability under Chosen-Plaintext Attacks (IND-CPA).
  In a CPA setting, the adversary is asked to provide two plaintexts and, subsequently,
  determine which of these plaintexts is encrypted by a given ciphertext.
*)
(** Adversary class considered for IND-CPA **)
module type Adv_INDCPA = {
  proc choose(pk : pk_t) : ptxt_t * ptxt_t
  proc distinguish(c : ctxt_t) : bool 
}.

(** IND-CPA security game (sampled bit) **)
module IND_CPA (S : Scheme, A : Adv_INDCPA) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var p0, p1 : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (p0, p1) <@ A.choose(pk);
    
    b <$ {0,1};
    
    c <@ S.enc(pk, if b then p1 else p0);
    
    b' <@ A.distinguish(c);
    
    return b' = b; 
  }
}.

(** IND-CPA security game (provided bit) **)
module IND_CPA_P (S : Scheme, A : Adv_INDCPA) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var p0, p1 : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    
    (p0, p1) <@ A.choose(pk);
    
    c <@ S.enc(pk, if b then p1 else p0);
    
    b' <@ A.distinguish(c);
    
    return b';
  }
}.


(* 
  non-adaptive Chosen-Ciphertext Attacks (CCA1)
  The adversary is given the considered public key and access to a decryption oracle
  *before* the stage in which it is expected to distinguish/return a break.
  Hence, the adversary is able to produce ciphertext corresponding to chosen plaintexts
  *and* query for decryptions of chosen ciphertexts.
*)
(* Oracles *)
(** Interface for oracles employed in CCA1 security games **)
module type Oracles_CCA1i = {
  proc init(sk_init : sk_t) : unit
  proc dec(c : ctxt_t) : ptxt_t option
}.

(** A default implementation for the oracles employed in CCA1 security games **)
module O_CCA1_Default (S : Scheme) : Oracles_CCA1i = {
  var sk : sk_t
  var qs : (ctxt_t * ptxt_t option) list
  
  proc init(sk_init : sk_t) = {
    sk <- sk_init;
    qs <- [];
  }
  
  proc dec(c : ctxt_t) : ptxt_t option = {
    var p : ptxt_t option;
    
    p <@ S.dec(sk, c);
    
    qs <- rcons qs (c, p);
    
    return p;
  }
}.

(** Interface for oracles given to the adversary in CCA1 security games **)
module type Oracles_CCA1 = {
  include Oracles_CCA1i [-init]
}.


(*
  One-Wayness under non-adaptive Chosen-Ciphertext Attacks (OW-CCA1).
  In a CCA1 setting, the adversary is asked to produce the message/plaintext 
  encrypted by a given ciphertext.
*)
(** Adversary class considered for OW-CCA1 **)
module type Adv_OWCCA1 (O : Oracles_CCA1) = { 
  proc scout(pk : pk_t) : unit { O.dec } 
  proc find(c : ctxt_t) : ptxt_t { }
}.

(** OW-CCA1 security game **)
module OW_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_OWCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var p, p' : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    A(O).scout(pk);
    
    p <$ dptxt;
    
    c <@ S.enc(pk, p);
    
    p' <@ A(O).find(c);
    
    return p' = p; 
  }
}.


(*
  (ciphertext) INDistinguishability under non-adaptive Chosen-Ciphertext Attacks (IND-CCA1).
  In a CCA1 setting, the adversary is asked to provide two plaintexts and, subsequently,
  determine which of these plaintexts is encrypted by a given ciphertext.
*)
(** Adversary class considered for IND-CCA1 **)
module type Adv_INDCCA1 (O : Oracles_CCA1) = { 
  proc choose(pk : pk_t) : ptxt_t * ptxt_t { O.dec } 
  proc distinguish(c : ctxt_t) : bool { }
}.

(** IND-CCA1 security game (sampled bit) **)
module IND_CCA1 (S : Scheme, O : Oracles_CCA1i, A : Adv_INDCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var p0, p1 : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    (p0, p1) <@ A(O).choose(pk);
    
    b <$ {0,1};
    
    c <@ S.enc(pk, if b then p1 else p0);
    
    b' <@ A(O).distinguish(c);
    
    return b' = b;
  }
}.

(** IND-CCA1 security game (provided bit) **)
module IND_CCA1_P (S : Scheme, O : Oracles_CCA1i, A : Adv_INDCCA1) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var p0, p1 : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O.init(sk);
    
    (p0, p1) <@ A(O).choose(pk);
    
    c <@ S.enc(pk, if b then p1 else p0);
    
    b' <@ A(O).distinguish(c);
    
    return b' = b; 
  }
}.


(* 
  adaptive Chosen-Ciphertext Attacks (CCA2)
  The adversary is given the considered public key and access to a decryption oracle throughout.  
  Hence, the adversary is able to produce ciphertext corresponding to chosen plaintexts
  *and* query for decryptions of chosen ciphertexts (potentially barring ciphertexts
  that are part of the challenge).
*)
(* Oracles *)
(** Interface for oracles employed in (the first stage of) CCA1 security games **)
module type Oracles_CCA2i1 = {
  proc init(sk_init : sk_t) : unit
  proc dec(c : ctxt_t) : ptxt_t option
}.

(** Interface for oracles employed in (the second stage of) CCA1 security games **)
module type Oracles_CCA2i2 = {
  proc init(sk_init : sk_t, c'_init : ctxt_t) : unit
  proc dec(c : ctxt_t) : ptxt_t option
}.

(** A default implementation for the oracles employed in (the first stage of) CCA1 security games **)
module O_CCA21_Default (S : Scheme) : Oracles_CCA2i1 = {
  var sk : sk_t
  var qs : (ctxt_t * ptxt_t option) list
  
  proc init(sk_init : sk_t) = {
    sk <- sk_init;
    qs <- [];
  }
  
  proc dec(c : ctxt_t) : ptxt_t option = {
    var p : ptxt_t option;
    
    p <@ S.dec(sk, c);
    
    qs <- rcons qs (c, p);
    
    return p;
  }
}.

(** A default implementation for the oracles employed in (the second stage of) CCA1 security games **)
module O_CCA22_Default (S : Scheme) : Oracles_CCA2i2 = {
  var sk : sk_t
  var c' : ctxt_t
  var qs : (ctxt_t * ptxt_t option) list
  
  proc init(sk_init : sk_t, c'_init : ctxt_t) = {
    sk <- sk_init;
    c' <- c'_init;
    qs <- [];
  }
  
  proc dec(c : ctxt_t) : ptxt_t option = {
    var p : ptxt_t option;
    
    if (c <> c') {
      p <@ S.dec(sk, c);
    } else {
      p <- None;
    }
    
    qs <- rcons qs (c, p);
    
    return p;
  }
}.

(** Interface for oracles given to the adversary in CCA1 security games **)
module type Oracles_CCA2 = {
  include Oracles_CCA2i2 [-init]
}.



(*
  One-Wayness under adaptive Chosen-Ciphertext Attacks (OW-CCA2).
  In a CCA2 setting, the adversary is asked to produce the message/plaintext 
  encrypted by a given ciphertext.
*)
(** Adversary class considered for OW-CCA1 **)
module type Adv_OWCCA2 (O : Oracles_CCA2) = { 
  proc scout(pk : pk_t) : unit
  proc find(c : ctxt_t) : ptxt_t
}.

(** OW-CCA1 security game **)
module OW_CCA2 (S : Scheme, O1 : Oracles_CCA2i1, O2 : Oracles_CCA2i2, A : Adv_OWCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var p, p' : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    A(O1).scout(pk);
    
    p <$ dptxt;
    
    c <@ S.enc(pk, p);
    O2.init(sk, c);
    
    p' <@ A(O2).find(c);
    
    return p' = p; 
  }
}.



(*
  (ciphertext) INDistinguishability under adaptive Chosen-Ciphertext Attacks (IND-CCA2).
  In a CCA2 setting, the adversary is asked to provide two plaintexts and, subsequently,
  determine which of these plaintexts is encrypted by a given ciphertext.
*)
(** Adversary class considered for IND-CCA2 **)
module type Adv_INDCCA2 (O : Oracles_CCA2) = { 
  proc choose(pk : pk_t) : ptxt_t * ptxt_t
  proc distinguish(c : ctxt_t) : bool
}.

(** IND-CCA2 security game (sampled bit) **)
module IND_CCA2 (S : Scheme, O1 : Oracles_CCA2i1, O2 : Oracles_CCA2i2, A : Adv_INDCCA1) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b, b' : bool;
    var p0, p1 : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    (p0, p1) <@ A(O1).choose(pk);
    
    b <$ {0,1};
    
    c <@ S.enc(pk, if b then p1 else p0);
    O2.init(sk, c);
    
    b' <@ A(O2).distinguish(c);
    
    return b' = b;
  }
}.

(** IND-CCA1 security game (provided bit) **)
module IND_CCA2_P (S : Scheme, O1 : Oracles_CCA2i1, O2 : Oracles_CCA2i2, A : Adv_INDCCA1) = {
  proc main(b : bool) : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var b' : bool;
    var p0, p1 : ptxt_t;
    var c : ctxt_t;
    
    (pk, sk) <@ S.keygen();
    O1.init(sk);
    
    (p0, p1) <@ A(O1).choose(pk);
    
    c <@ S.enc(pk, if b then p1 else p0);
    O2.init(sk, c);
    
    b' <@ A(O2).distinguish(c);
    
    return b' = b;
  }
}.






(* Properties (variants, e.g., for delta-correct schemes) *)
(** Adversary class considered for (partial/delta) correctness **)
module type Adv_Cor = {
  proc find(pk : pk_t, sk : sk_t) : ptxt_t
}.

(** Correctness (partial/delta) **)
module Correctness_Delta (S : Scheme, A : Adv_Cor) = {
  proc main() : bool = {
    var pk : pk_t;
    var sk : sk_t;
    var p : ptxt_t;
    var c : ctxt_t;
    var p' : ptxt_t option;
    
    (pk, sk) <@ S.keygen();
    
    p <@ A.find(pk, sk);
    
    c <@ S.enc(pk, p);
    p' <@ S.dec(sk, c);
    
    return p' = Some p;
  }
}.


(** Interface for Plaintext-Checking (PC) oracles **)
module type Oracles_PCi = {
  proc init(sk_init : sk_t) : unit
  proc check(p : ptxt_t, c : ctxt_t) : bool
}.

module PCO_Default (S : Scheme) = {
  var sk : sk_t
  var qs : (ptxt_t * ctxt_t * bool) list
  
  proc init(sk_init : sk_t) = {
    sk <- sk_init;
    qs <- [];
  }
  
  proc check(p : ptxt_t, c : ctxt_t) : bool = {
    return witness;
  }
}.
