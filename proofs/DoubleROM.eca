require import AllCore Distr List FMap PROM.

(* 
  Start with simple (most specific and relevant for ML-KEM) case: 
  only input type (potentially) different between ROs and constant/fixed distribution
*)
type in_t1.
type in_t2.

type out_t.
op [lossless] dout : out_t distr.


clone FullRO as FullRO1 with
  type in_t <- in_t1,
  type out_t <- out_t,
  
  op dout <- fun _ => dout
  
  proof *. 
  
clone FullRO as FullRO2 with
  type in_t <- in_t2,
  type out_t <- out_t,
  
  op dout <- fun _ => dout
  
  proof *. 

  
module type Adv_CRROMx2 (RO1 : FullRO1.RO) (RO2 : FullRO2.RO) ={ 
  proc find() : in_t1 * in_t2 { RO1.get, RO2.get }
}.


module CR_ROM_x2 (RO1 : FullRO1.RO) (RO2 : FullRO2.RO) (A : Adv_CRROMx2) = {
  proc main() : bool = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y1, y2 : out_t;
    
    RO1.init();
    RO2.init();
        
    (x1, x2) <@ A(RO1, RO2).find();
    
    y1 <@ RO1.get(x1);
    y2 <@ RO2.get(x2);
    
    return y1 = y2; 
  }
}.


require import FelTactic.


section.

declare module A <: Adv_CRROMx2 { -FullRO1.RO, -FullRO2.RO }.

declare op q1 : { int | 0 <= q1 } as ge0_q1.
declare op q2 : { int | 0 <= q2 } as ge0_q2.



(* 
  Intermediate RO definition to perform lazy-eager argument on 
  RO1 (can do similarly on RO2 if desired).
*)
local clone import FullRO as FullROI with
  type in_t <- int,
  type out_t <- out_t,
  
  type d_in_t <- unit,
  type d_out_t <- bool,
  
  op dout <- fun _ => dout
  
  proof *.

(*
local module RO1_W (ROI : FullROI.RO) : FullRO1.RO = {
  include var FullRO1.RO [-init, get] 
  var q : int

  proc init() : unit = { 
    var i : int;

    i <- 0;
    while (i < q1) { 
      ROI.sample(i);
    }
  }

  proc get(x : in_t1) : out_t = {
    var y : out_t;

    if (x \notin FullRO1.RO.m) {
      y <@ ROI.get(q);
      q <- q + 1;
    } else {
      y <- oget FullRO1.RO.m.[x];
    }

    return y;
  }
}.
*)
(*
local module R_ROD_CRROMx2 (ROI : FullROI.RO) = {
  proc distinguish() = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y1, y2 : out_t;
    
    RO1_W(ROI).init();
    RO2.init();
    (x1, x2) <@ A(RO1_W(ROI), RO2).find();
    
    y1 <@ RO1.get(x1);
    y2 <@ RO2.get(x2);
    
    return y1 = y2;
  }
}.
*)

local module RO1_W (ROI : FullROI.RO) : FullRO1.RO = {
  include var FullRO1.RO [-init, get] 
  var q : int

  proc init() : unit = { 
    var i : int;

    i <- 0;
    while (i < q1) { 
      ROI.sample(i);
      i <- i + 1;
    }
  }

  proc get(x : in_t1) : out_t = {
    var y : out_t;

    if (x \notin FullRO1.RO.m) {
      y <@ ROI.get(q);
      FullRO1.RO.m.[x] <- y;
      q <- q + 1;
    } else {
      y <- oget FullRO1.RO.m.[x];
    }

    return y;
  }
}.

local module CR_ROM_x2_I (ROI : FullROI.RO) = {
(*
  module RO1_W : FullRO1.RO = {
    include var FullRO1.RO [-init, get] 
    var q : int

    proc init() : unit = { 
      var i : int;

      i <- 0;
      while (i < q1) { 
        ROI.sample(i);
      }
    }

    proc get(x : in_t1) : out_t = {
      var y : out_t;

      if (x \notin FullRO1.RO.m) {
        y <@ ROI.get(q);
        q <- q + 1;
      } else {
        y <- oget FullRO1.RO.m.[x];
      }

      return y;
    }
  }
*)  
  proc distinguish() = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y1, y2 : out_t;
    
    RO1_W(ROI).init();
    
    (x1, x2) <@ A(RO1_W(ROI), FullRO2.LRO).find();

    y1 <@ RO1_W(ROI).get(x1);
    y2 <@ FullRO2.LRO.get(x2);
    
    return y1 = y2;
      
  }
  
  proc main() = {
    var b : bool;
    
    ROI.init();
    FullRO1.RO.m <- empty;
    RO1_W.q <- 0;
    FullRO2.RO.m <- empty;
    
    b <@ distinguish();
    
    return b;
  }  
}.

local equiv Eqv_CRROMx2RO_ILRO :
  CR_ROM_x2(FullRO1.RO, FullRO2.RO, A).main ~ CR_ROM_x2_I(FullROI.LRO).main :
    ={glob A} ==> ={res}.
proof.
proc.
inline{2} CR_ROM_x2_I(LRO).distinguish.
seq 2 5 : (   ={glob A} 
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{2} = empty
           /\ RO1_W.q{2} = 0).
+ inline *.
  while{2} (true) (q1 - i{2}).
  + by auto => /> /#. 
  by auto => />; smt(ge0_q1). inline *.   
seq 1 1 : (   ={x1, x2, FullRO1.RO.m, FullRO2.RO.m}
           /\ RO1_W.q{2} \notin RO.m{2}).
+ call (:   ={FullRO1.RO.m, FullRO2.RO.m} 
         /\ dom RO.m{2} = mem (range 0 RO1_W.q{2}) 
         /\ 0 <= RO1_W.q{2}).
  + proc.
    inline{2} LRO.get.
    case (x{1} \notin FullRO1.RO.m{1}).
    + rcondt{1} ^if; 1: by auto.
      rcondt{2} ^if; 1: by auto.
      rcondt{2} ^if; 1: move => &m. 
      + rnd; wp; skip => /> &m'. 
        by rewrite fun_ext => /(_ RO1_W.q{m'}); rewrite mem_range => -> /#.
      by wp; rnd; wp; skip => /> &m; smt(get_set_sameE mem_range mem_set). 
    rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by rnd{1}; wp.
  + proc.
    by wp; rnd; skip => />.
  by skip => />; smt(mem_empty mem_range). 
wp; rnd; sp 1 1.
case (x{1} \notin FullRO1.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  do 2! (rcondt{2} ^if; 1: by auto).
  by wp; rnd; wp; skip => />; smt(get_set_sameE).
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
by wp; rnd{1}. 
qed.


local equiv Eqv_CRROMx2_Dist_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).distinguish ~ CR_ROM_x2_I(FullROI.RO).distinguish :
    ={glob CR_ROM_x2_I, FullROI.RO.m} ==> ={res, glob CR_ROM_x2_I}.   
proof.
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D CR_ROM_x2_I _) => //.
by move => ?; apply dout_ll.
qed.

local equiv Eqv_CRROMx2_Main_LRO_RO :
  CR_ROM_x2_I(FullROI.LRO).main ~ CR_ROM_x2_I(FullROI.RO).main :
    ={glob A} ==> ={res}.   
proof.
proc.
seq 4 4 : ( ={glob CR_ROM_x2_I, FullROI.RO.m}); 1: by inline *; auto. 
by rewrite equiv[{1} 1 Eqv_CRROMx2_Dist_LRO_RO]; sim.
qed.


local module CR_ROM_x2_I_RS (ROI : FullROI.RO) = {
  proc distinguish() = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y1, y2 : out_t;
    
    RO1_W(ROI).init();
    
    (x1, x2) <@ A(RO1_W(ROI), FullRO2.LRO).find();

    
    if (x1 \notin FullRO1.RO.m) {
      y1 <$ dout;
    } else {
      y1 <- oget FullRO1.RO.m.[x1];
    }
    
    if (x2 \notin FullRO2.RO.m) {
      y2 <$ dout;
    } else {
      y2 <- oget FullRO2.RO.m.[x2];
    }
    
    return y1 = y2;  
  }
  
  proc main() = {
    var b : bool;
    
    ROI.init();
    FullRO1.RO.m <- empty;
    RO1_W.q <- 0;
    FullRO2.RO.m <- empty;
    
    b <@ distinguish();
    
    return b;
  }  
}.

local equiv Eqv_CRROMx2RORS_ILRO :
  CR_ROM_x2(FullRO1.RO, FullRO2.RO, A).main ~ CR_ROM_x2_I_RS(FullROI.LRO).main :
    ={glob A} ==> ={res}.
proof.
proc.
inline{2} distinguish.
seq 2 5 : (   ={glob A} 
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{2} = empty
           /\ RO1_W.q{2} = 0).
+ inline *.
  while{2} (true) (q1 - i{2}).
  + by auto => /> /#. 
  by auto => />; smt(ge0_q1). 
inline *.   
seq 1 1 : (   ={x1, x2, FullRO1.RO.m, FullRO2.RO.m}
           /\ RO1_W.q{2} \notin RO.m{2}).
+ call (:   ={FullRO1.RO.m, FullRO2.RO.m} 
         /\ dom RO.m{2} = mem (range 0 RO1_W.q{2}) 
         /\ 0 <= RO1_W.q{2}).
  + proc.
    inline{2} LRO.get.
    case (x{1} \notin FullRO1.RO.m{1}).
    + rcondt{1} ^if; 1: by auto.
      rcondt{2} ^if; 1: by auto.
      rcondt{2} ^if; 1: move => &m. 
      + rnd; wp; skip => /> &m'. 
        by rewrite fun_ext => /(_ RO1_W.q{m'}); rewrite mem_range => -> /#.
      by wp; rnd; wp; skip => /> &m; smt(get_set_sameE mem_range mem_set). 
    rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    by rnd{1}; wp.
  + proc.
    by wp; rnd; skip => />.
  by skip => />; smt(mem_empty mem_range). 
sp.
case (x{1} \notin FullRO1.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  case (x2{1} \notin FullRO2.RO.m{1}).
  + rcondt{1} ^if; 1: by auto.
    rcondt{2} ^if; 1: by auto.
    auto => />.
    progress.
    smt(get_set_sameE).  
  + rcondf{1} ^if; 1: by auto.
    rcondf{2} ^if; 1: by auto.
    wp; rnd{1}; wp; rnd; skip => />.
    smt(get_set_sameE).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
case (x2{1} \notin FullRO2.RO.m{1}).
+ rcondt{1} ^if; 1: by auto.
  rcondt{2} ^if; 1: by auto.
  auto => />.
  progress.
  smt(get_set_sameE).  
rcondf{1} ^if; 1: by auto.
rcondf{2} ^if; 1: by auto.
by wp; rnd{1}; wp; rnd{1}; skip => />.
qed.

local equiv Eqv_CRROMx2RS_Dist_LRO_RO :
  CR_ROM_x2_I_RS(FullROI.LRO).distinguish ~ CR_ROM_x2_I_RS(FullROI.RO).distinguish :
    ={glob CR_ROM_x2_I_RS, FullROI.RO.m} ==> ={res, glob CR_ROM_x2_I_RS}.   
proof.
symmetry. 
conseq (FullROI.FullEager.RO_LRO_D CR_ROM_x2_I_RS _) => //.
by move => ?; apply dout_ll.
qed.

local equiv Eqv_CRROMx2RS_Main_LRO_RO :
  CR_ROM_x2_I_RS(FullROI.LRO).main ~ CR_ROM_x2_I_RS(FullROI.RO).main :
    ={glob A} ==> ={res}.   
proof.
proc.
seq 4 4 : ( ={glob CR_ROM_x2_I_RS, FullROI.RO.m}); 1: by inline *; auto. 
by rewrite equiv[{1} 1 Eqv_CRROMx2RS_Dist_LRO_RO]; sim.
qed.

local module RO1_Eager = {
  include var FullRO1.RO [-init, get]
  var mi : (int, out_t) fmap

  proc init() = {
    var y : out_t;

    m <- empty;

    mi <- empty;
    while (fsize mi < q1) {
      y <$ dout;
      mi.[fsize mi] <- y;
    }
  }

  proc get(x : in_t1) = {
    var y : out_t;

    if (x \notin m) {
      if (fsize m < q1) {
        m.[x] <- oget mi.[fsize m];
      }  
      y <- oget m.[x];
    } else {
      y <- oget m.[x];
    }

    return y;
  }     
}.  
  
local module CR_ROM_x2_Eager1 = {
  proc main() = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y, y1, y2 : out_t;
        
    RO1_Eager.init();
    FullRO2.RO.init();
    
    (x1, x2) <@ A(RO1_Eager, FullRO2.LRO).find();

    if (fsize FullRO1.RO.m < q1) {
      y1 <@ RO1_Eager.get(x1);
    } else {
      y1 <@ FullRO1.RO.get(x1);
    }
    
    y2 <@ FullRO2.LRO.get(x2);
    
    return y1 = y2;
  }
}.


local lemma A_RO1_qs :
  hoare[A(RO1_W(RO), FullRO2.LRO).find : RO1_W.q = 0 ==> RO1_W.q <= q1]. 
proof. admit. qed.

declare axiom A_find_ll (RO1 <: FullRO1.RO{-A}) (RO2 <: FullRO2.RO{-A}) :
  islossless RO1.get => islossless RO2.get => islossless A(RO1, RO2).find.
  
local equiv Eqv_CRROMx2RO_ILROT :
  CR_ROM_x2_I(FullROI.RO).main ~ CR_ROM_x2_Eager1.main :
    ={glob A} ==> ={res}.
proof.
proc.
inline{1} RO.init CR_ROM_x2_I(RO).distinguish RO1_W(RO).init.
inline{2} RO1_Eager.init FullRO2.LRO.init.
seq 6 4 : (   ={glob A}
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{1} = RO1_Eager.mi{2}
           /\ dom FullROI.RO.m{1} = mem (range 0 q1)
           /\ RO1_W.q{1} = 0).
+ swap{2} 4 -1. 
  while (   FullROI.RO.m{1} = RO1_Eager.mi{2}
         /\ dom FullROI.RO.m{1} = mem (range 0 i{1})
         /\ i{1} = fsize FullROI.RO.m{1}
         /\ i{1} <= q1).
  + inline{1} RO.sample RO.get. 
    sp; rcondt{1} ^if; first by auto => />; smt(mem_range).
    wp; rnd; skip => />. progress.
    rewrite fun_ext => x. rewrite mem_set mem_range.
    smt(ge0_q1 mem_set mem_range fsize_set ge0_fsize).
     smt(ge0_q1 mem_set mem_range fsize_set). 
     smt(ge0_q1 mem_set mem_range fsize_set).
     smt(ge0_q1 mem_set mem_range fsize_set). 
     smt(ge0_q1 mem_set mem_range fsize_set). 
  by wp; skip => />; smt(ge0_q1 fsize_empty mem_empty mem_range).
wp; call (: ={FullRO2.RO.m}); 1: by auto. 
inline{1} RO1_W(RO).get RO.get.
inline{2} RO1_Eager.get.
seq 1 1 : (   ={FullRO1.RO.m, FullRO2.RO.m, x1, x2}
           /\ RO1_W.q{1} = fsize FullRO1.RO.m{1}
           /\ FullROI.RO.m{1} = RO1_Eager.mi{2}
           /\ dom FullROI.RO.m{1} = mem (range 0 q1)).
+ call (: ={glob A} /\
            FullRO1.RO.m{1} = empty /\
            FullRO1.RO.m{2} = empty /\
            FullRO2.RO.m{1} = empty /\
            FullRO2.RO.m{2} = empty /\
            RO.m{1} = RO1_Eager.mi{2} /\ dom RO.m{1} = mem (range 0 q1) /\ RO1_W.q{1} = 0
           ==>           
         RO1_W.q{1} <= q1 
         /\
         (RO1_W.q{1} <= q1 =>  
          ={FullRO1.RO.m, FullRO2.RO.m, res}
         /\ RO1_W.q{1} = fsize FullRO1.RO.m{1}
         /\ FullROI.RO.m{1} = RO1_Eager.mi{2}
         /\ dom FullROI.RO.m{1} = mem (range 0 q1))).
        conseq (: RO1_W.q{1} <= q1 =>  
                ={FullRO1.RO.m, FullRO2.RO.m, res}
               /\ RO1_W.q{1} = fsize FullRO1.RO.m{1}
               /\ FullROI.RO.m{1} = RO1_Eager.mi{2}
               /\ dom FullROI.RO.m{1} = mem (range 0 q1))
         A_RO1_qs _. 
         smt(). smt(). 
       symmetry.
       proc (q1 < RO1_W.q) (
            ={FullRO1.RO.m, FullRO2.RO.m}
         /\ RO1_W.q{2} = fsize FullRO1.RO.m{1}
         /\ FullROI.RO.m{2} = RO1_Eager.mi{1}
         /\ dom FullROI.RO.m{2} = mem (range 0 q1)).
         progress. 
         smt(fsize_empty).
         progress. 
         move: H. 
         smt(). 
         smt().
         smt().
         smt().
         smt().
        smt().  apply A_find_ll.
    proc.
    inline{2} RO.get.
    if => //.
      case (RO1_W.q{2} = q1).

            wp 1 -1.
      conseq (: _ ==> true).  smt().
       auto.
      rcondf{2} ^if.
      + auto. progress. 
        smt(ge0_q1 mem_set mem_range fsize_set ge0_fsize).
        rcondt{1} ^if; first auto; smt(). 
        wp; rnd{2}.
        wp; skip => />. progress.
        
        smt(ge0_q1 get_set_sameE oget_some mem_set mem_range fsize_set ge0_fsize).         
        smt(ge0_q1 get_set_sameE oget_some mem_set mem_range fsize_set ge0_fsize). 
      wp. skip=> />. 
    progress.
    proc. by wp.
    progress.
    proc. inline.
    if => //; auto.
    progress. smt(dout_ll).
    smt().
    proc.
    wp; rnd; skip => />.
    progress.
    proc. by wp; rnd; skip => />; smt(dout_ll).
    progress.
    proc. by wp; rnd; skip => />; smt(dout_ll).
    skip => />.
wp; sp.
inline RO.get FullRO1.RO.get. 
if{1}; if{2} => //.
+ rcondt{2} ^if; 1: by auto. 
  rcondf{1} ^if; 1: auto.   progress. 

     smt(ge0_q1 mem_set mem_range fsize_set ge0_fsize). 
  wp; rnd{1}; wp; skip => />. progress.
  rewrite get_set_sameE oget_some //.
+ rcondt{1} ^if; 1: auto. progress. smt(mem_range).
  wp; rnd; wp; skip => />.
  progress. smt(get_set_sameE).
+ rcondf{2} ^if; 1: auto.
   wp; skip =>/>.
+ rcondf{2} ^if. auto.
  wp; rnd{2}; wp; skip => />. 
qed.

local module CR_ROM_x2_Eager1_RS = {
  proc main() = {
    var x1 : in_t1;
    var x2 : in_t2;
    var y, y1, y2 : out_t;
        
    RO1_Eager.init();
    FullRO2.RO.init();
    
    (x1, x2) <@ A(RO1_Eager, FullRO2.LRO).find();

    if (x1 \notin FullRO1.RO.m) {
      y1 <$ dout;
    } else {
      y1 <- oget FullRO1.RO.m.[x1];
    }
    
    if (x2 \notin FullRO2.RO.m) {
      y2 <$ dout;
    } else {
      y2 <- oget FullRO2.RO.m.[x2];
    }
    
    return y1 = y2;
  }
}.

local equiv Eqv_CRROMx2RO_ILROT_RS :
  CR_ROM_x2_I_RS(FullROI.RO).main ~ CR_ROM_x2_Eager1_RS.main :
    ={glob A} ==> ={res}.
proof.
proc.
inline{1} RO.init distinguish RO1_W(RO).init.
inline{2} RO1_Eager.init FullRO2.LRO.init.
seq 6 4 : (   ={glob A}
           /\ FullRO1.RO.m{1} = empty
           /\ FullRO1.RO.m{2} = empty
           /\ FullRO2.RO.m{1} = empty
           /\ FullRO2.RO.m{2} = empty
           /\ FullROI.RO.m{1} = RO1_Eager.mi{2}
           /\ dom FullROI.RO.m{1} = mem (range 0 q1)
           /\ RO1_W.q{1} = 0).
+ swap{2} 4 -1. 
  while (   FullROI.RO.m{1} = RO1_Eager.mi{2}
         /\ dom FullROI.RO.m{1} = mem (range 0 i{1})
         /\ i{1} = fsize FullROI.RO.m{1}
         /\ i{1} <= q1).
  + inline{1} RO.sample RO.get. 
    sp; rcondt{1} ^if; first by auto => />; smt(mem_range).
    wp; rnd; skip => />. progress.
    rewrite fun_ext => x. rewrite mem_set mem_range.
    smt(ge0_q1 mem_set mem_range fsize_set ge0_fsize).
     smt(ge0_q1 mem_set mem_range fsize_set). 
     smt(ge0_q1 mem_set mem_range fsize_set).
     smt(ge0_q1 mem_set mem_range fsize_set). 
     smt(ge0_q1 mem_set mem_range fsize_set). 
  by wp; skip => />; smt(ge0_q1 fsize_empty mem_empty mem_range).
wp.
seq 1 1 : (={x2, x1, FullRO2.RO.m, FullRO1.RO.m}); 2: by sim.
+ call (: ={glob A} /\
            FullRO1.RO.m{1} = empty /\
            FullRO1.RO.m{2} = empty /\
            FullRO2.RO.m{1} = empty /\
            FullRO2.RO.m{2} = empty /\
            RO.m{1} = RO1_Eager.mi{2} /\ 
            dom RO.m{1} = mem (range 0 q1) /\ 
            RO1_W.q{1} = 0
           ==>           
         RO1_W.q{1} <= q1 
         /\
         (RO1_W.q{1} <= q1 =>  
          ={FullRO1.RO.m, FullRO2.RO.m, res})).
        conseq (: RO1_W.q{1} <= q1 =>  
                ={FullRO1.RO.m, FullRO2.RO.m, res})
         A_RO1_qs _. 
         smt(). smt(). 
       symmetry.
       proc (q1 < RO1_W.q) (fsize FullRO1.RO.m {1} = RO1_W.q{2} /\ 
            ={FullRO1.RO.m, FullRO2.RO.m} /\
         RO.m{2} = RO1_Eager.mi{1} /\ 
            dom RO.m{2} = mem (range 0 q1)) => //. 
         progress; smt(fsize_empty). 
         progress; smt().
         apply A_find_ll.
         proc.
         inline get.
         if => //. 
      case (RO1_W.q{2} = q1).
      wp 1 -1.
      conseq (: _ ==> true).  
      smt(). by auto.      
      rcondf{2} ^if.
      + auto. progress.
        smt(ge0_q1 mem_set mem_range fsize_set ge0_fsize).  
        rcondt{1} ^if; first auto; smt(). 
        wp; rnd{2}.
        wp; skip => />. progress.
        
        smt(ge0_q1 get_set_sameE oget_some mem_set mem_range fsize_set ge0_fsize).         
        smt(ge0_q1 get_set_sameE oget_some mem_set mem_range fsize_set ge0_fsize). 
      wp. skip=> />. 
      progress.
      proc.
      by wp.
      progress.
      proc.
      inline get.
      if => //; auto; smt(dout_ll).
      proc. by auto.
      progress; proc; auto; smt(dout_ll).
      progress.
      progress; proc; auto; smt(dout_ll).
by auto => /> /#.
qed.

local module CR_ROM_x2_Eager1_V = {  
  var x1 : in_t1
  var x2 : in_t2
    
  proc cr() : unit = {
    RO1_Eager.init();
    FullRO2.LRO.init();
    
    (x1, x2) <@ A(RO1_Eager, FullRO2.LRO).find();    
  }
  
  proc main() = {
    var y, y1, y2 : out_t;

    cr();
    
    if (fsize FullRO1.RO.m < q1) {
      y1 <@ RO1_Eager.get(x1);
    } else {
      y1 <@ FullRO1.RO.get(x1);
    }
    
    y2 <@ FullRO2.LRO.get(x2);
    
    return y1 = y2;
  }
}.

local equiv Eqv_CRROMx2Eager1_V :
  CR_ROM_x2_Eager1.main ~ CR_ROM_x2_Eager1_V.main :
    ={glob A} ==> ={res}.
proof. by proc; inline cr; sim. qed.


local lemma Bnd_CRROMx2Eager1V_CR &m :
  Pr[CR_ROM_x2_Eager1_V.cr() @ &m : 
         fsize FullRO2.RO.m <= q2
      /\ CR_ROM_x2_Eager1_V.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1_V.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_V.x2]]
  <=
  (q1 * q2)%r * p_max dout.
proof.  
fel 2
    (fsize FullRO2.RO.m)
    (fun _ => q1%r * p_max dout)
    q2
    (exists (x1 : int) (x2 : in_t2), 
           x1 \in RO1_Eager.mi 
        /\ x2 \in FullRO2.RO.m 
        /\ RO1_Eager.mi.[x1] = FullRO2.RO.m.[x2])
    [ RO1_Eager.get : false; FullRO2.LRO.get : (arg \notin FullRO2.RO.m) ]
    (   dom RO1_Eager.mi = mem (range 0 q1) 
     /\ rng FullRO1.RO.m <= rng RO1_Eager.mi
     /\ fsize RO1_Eager.mi = q1) => //. 
+ by rewrite StdBigop.Bigreal.BRA.sumri_const 1:ge0_q2 RField.intmulr /#.
+ progress.
  move: H4 => /(_ (oget FullRO1.RO.m{m0}.[CR_ROM_x2_Eager1_V.x1{m0}]) _). 
  rewrite /rng; exists (CR_ROM_x2_Eager1_V.x1{m0}). smt(). 
  rewrite /rng => -[i].
  print some_oget. 
  rewrite -some_oget; 1: smt().
  move=> eq.
  exists i CR_ROM_x2_Eager1_V.x2{m0}. 
  smt(). 
+ inline FullRO2.RO.init RO1_Eager.init. 
  wp; sp.
  while (   dom RO1_Eager.mi = mem (range 0 (fsize RO1_Eager.mi))
         /\ fsize RO1_Eager.mi <= q1).
  + wp; rnd; skip => />.
    progress. 
    rewrite fun_ext => x. rewrite mem_set mem_range.
    smt(mem_set mem_range ge0_fsize fsize_set).
    smt(fsize_set).
     skip => />. smt(mem_empty fsize_empty mem_range ge0_q1 rngE emptyE).
+ progress.
  proc. 
  wp; skip => />. 
  progress. 
  print rng_set.
  move=> t.
  rewrite rng_set.
  search FMap.rem. rewrite rem_id //. 
  case.  smt().
  move => ->. 
  rewrite rngE /=.
  exists (fsize FullRO1.RO.m{hr}). rewrite -some_oget //.  
  smt(domE mem_range ge0_fsize rngE).
+ proc.
  rcondt ^if; 1: by rnd. 
  wp; rnd; skip => />.
  progress. print rng.
  apply (StdOrder.RealOrder.ler_trans (mu dout (fun y => exists (i : int), dom RO1_Eager.mi{hr} i /\ RO1_Eager.mi{hr}.[i] = Some y))).
  apply mu_sub => k.
  move => -[x1 x2] [].
  case (x2 = x{hr}) => eqxs.
  rewrite mem_set eqxs get_set_sameE /=. smt(rngE).
  rewrite ?get_set_neqE 1://.
  smt().
  rewrite -H4.
  apply Mu_mem.mu_mem_le_fsize. 
  move => u ? /= -@/pred1. 
  apply (StdOrder.RealOrder.ler_trans (mu1 dout (oget RO1_Eager.mi{hr}.[u]))).
  apply mu_sub => r ->. by rewrite oget_some.
  smt(pmax_upper_bound).  
+ progress.  
  proc.
  rcondt ^if; 1: by auto.
  wp; rnd.
  skip => />.
  progress. smt(fsize_set).
progress.
proc.
rcondf ^if; 1: by auto.
by rnd.
qed.

local module CR_ROM_x2_Eager1_RS_V = {
  var x1 : in_t1
  var x2 : in_t2

  proc cr() = {  
    RO1_Eager.init();
    FullRO2.RO.init();
    
    (x1, x2) <@ A(RO1_Eager, FullRO2.LRO).find();
  }
  
  proc main() = {
    var y, y1, y2 : out_t;      

    cr();
    
    if (x1 \notin FullRO1.RO.m) {
      y1 <$ dout;
    } else {
      y1 <- oget FullRO1.RO.m.[x1];
    }
    
    if (x2 \notin FullRO2.RO.m) {
      y2 <$ dout;
    } else {
      y2 <- oget FullRO2.RO.m.[x2];
    }
    
    return y1 = y2;
  }
}.

local equiv Eqv_CRROMx2Eager1_V_RS :
  CR_ROM_x2_Eager1_RS.main ~ CR_ROM_x2_Eager1_RS_V.main :
    ={glob A} ==> ={res}.
proof. by proc; inline cr; sim. qed.


local lemma Bnd_CRROMx2Eager1V_CR_RS &m :
  Pr[CR_ROM_x2_Eager1_RS_V.cr() @ &m : 
         fsize FullRO2.RO.m <= q2
      /\ CR_ROM_x2_Eager1_RS_V.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1_RS_V.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_RS_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_RS_V.x2]]
  <=
  (q1 * q2)%r * p_max dout.
proof.  
fel 2
    (fsize FullRO2.RO.m)
    (fun _ => q1%r * p_max dout)
    q2
    (exists (x1 : int) (x2 : in_t2), 
           x1 \in RO1_Eager.mi 
        /\ x2 \in FullRO2.RO.m 
        /\ RO1_Eager.mi.[x1] = FullRO2.RO.m.[x2])
    [ RO1_Eager.get : false; FullRO2.LRO.get : (arg \notin FullRO2.RO.m) ]
    (   dom RO1_Eager.mi = mem (range 0 q1) 
     /\ rng FullRO1.RO.m <= rng RO1_Eager.mi
     /\ fsize RO1_Eager.mi = q1) => //. 
+ by rewrite StdBigop.Bigreal.BRA.sumri_const 1:ge0_q2 RField.intmulr /#.
+ progress.
  move: H4 => /(_ (oget FullRO1.RO.m{m0}.[CR_ROM_x2_Eager1_RS_V.x1{m0}]) _). 
  rewrite /rng; exists (CR_ROM_x2_Eager1_RS_V.x1{m0}). smt(). 
  rewrite /rng => -[i].
  print some_oget. 
  rewrite -some_oget; 1: smt().
  move=> eq.
  exists i CR_ROM_x2_Eager1_RS_V.x2{m0}. 
  smt(). 
+ inline FullRO2.RO.init RO1_Eager.init. 
  wp; sp.
  while (   dom RO1_Eager.mi = mem (range 0 (fsize RO1_Eager.mi))
         /\ fsize RO1_Eager.mi <= q1).
  + wp; rnd; skip => />.
    progress. 
    rewrite fun_ext => x. rewrite mem_set mem_range.
    smt(mem_set mem_range ge0_fsize fsize_set).
    smt(fsize_set).
     skip => />. smt(mem_empty fsize_empty mem_range ge0_q1 rngE emptyE).
+ progress.
  proc. 
  wp; skip => />. 
  progress. 
  print rng_set.
  move=> t.
  rewrite rng_set.
  search FMap.rem. rewrite rem_id //. 
  case.  smt().
  move => ->. 
  rewrite rngE /=.
  exists (fsize FullRO1.RO.m{hr}). rewrite -some_oget //.  
  smt(domE mem_range ge0_fsize rngE).
+ proc.
  rcondt ^if; 1: by rnd. 
  wp; rnd; skip => />.
  progress. print rng.
  apply (StdOrder.RealOrder.ler_trans (mu dout (fun y => exists (i : int), dom RO1_Eager.mi{hr} i /\ RO1_Eager.mi{hr}.[i] = Some y))).
  apply mu_sub => k.
  move => -[x1 x2] [].
  case (x2 = x{hr}) => eqxs.
  rewrite mem_set eqxs get_set_sameE /=. smt(rngE).
  rewrite ?get_set_neqE 1://.
  smt().
  rewrite -H4.
  apply Mu_mem.mu_mem_le_fsize. 
  move => u ? /= -@/pred1. 
  apply (StdOrder.RealOrder.ler_trans (mu1 dout (oget RO1_Eager.mi{hr}.[u]))).
  apply mu_sub => r ->. by rewrite oget_some.
  smt(pmax_upper_bound).  
+ progress.  
  proc.
  rcondt ^if; 1: by auto.
  wp; rnd.
  skip => />.
  progress. smt(fsize_set).
progress.
proc.
rcondf ^if; 1: by auto.
by rnd.
qed.


local lemma A_RO2_qs :
  hoare[A(RO1_Eager, FullRO2.LRO).find : fsize FullRO2.RO.m = 0 ==> fsize FullRO2.RO.m <= q2]. 
proof. admit. qed.
(*
local lemma EqPr_CRROMx2Eager1V_CR &m :
  Pr[CR_ROM_x2_Eager1_V.cr() @ &m : 
         fsize FullRO2.RO.m <= q2
      /\ CR_ROM_x2_Eager1_V.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1_V.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_V.x2]]
  =
  Pr[CR_ROM_x2_Eager1_V.main() @ &m : 
         CR_ROM_x2_Eager1_V.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1_V.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_V.x2]].
proof.
have ->:
  Pr[CR_ROM_x2_Eager1_V.cr() @ &m : 
         fsize FullRO2.RO.m <= q2
      /\ CR_ROM_x2_Eager1_V.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1_V.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_V.x2]]
  =
  Pr[CR_ROM_x2_Eager1_V.cr() @ &m : 
         CR_ROM_x2_Eager1_V.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1_V.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_V.x2]].
+ byequiv => //.
  proc.
  call (:    ={glob A, glob RO1_Eager, glob FullRO2.RO}
          /\ FullRO2.RO.m{1} = empty
            ==>
            ={res, FullRO1.RO.m, FullRO2.RO.m} /\
            (fsize FullRO2.RO.m{1} <= q2)).
  conseq (:    ={glob A, glob RO1_Eager, glob FullRO2.RO}
            /\ FullRO2.RO.m{1} = empty
            ==>
            ={res, FullRO1.RO.m, FullRO2.RO.m})
          A_RO2_qs
          _.
          progress.
smt(fsize_empty).             
progress. 
proc (={glob RO1_Eager, glob FullRO2.RO}).
progress.
progress. 
sim.
sim.
inline.
wp; while (={RO1_Eager.mi}). auto. 
wp; skip => />. 
byequiv (: ={glob A}
            ==> 
              (CR_ROM_x2_Eager1_V.x1 \in FullRO1.RO.m){1} = (CR_ROM_x2_Eager1_V.x1 \in FullRO1.RO.m){2}
           /\ (CR_ROM_x2_Eager1_V.x2 \in FullRO2.RO.m){1} = (CR_ROM_x2_Eager1_V.x2 \in FullRO2.RO.m){2}
           /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_V.x1]{1} = FullRO1.RO.m.[CR_ROM_x2_Eager1_V.x1]{2}
           /\ FullRO2.RO.m.[CR_ROM_x2_Eager1_V.x2]{1} = FullRO2.RO.m.[CR_ROM_x2_Eager1_V.x2]{2}) => //.
+ proc.
  seq 3 1 : #post.
  + inline{2} cr.
    conseq (: _ ==> ={CR_ROM_x2_Eager1_V.x1, CR_ROM_x2_Eager1_V.x2, FullRO1.RO.m, FullRO2.RO.m}).
    smt().
    by sim.
  if{2} => //.
  inline.
  wp; rnd{2}; wp; skip =>/>. progress.
  smt(mem_set).
progress.
smt().
smt().
smt().
smt().
smt().
smt().
qed.
*)

lemma Bnd_CRROMx2 &m :
  Pr[CR_ROM_x2(FullRO1.RO, FullRO2.RO, A).main() @ &m : res] 
  <=
  (q1 * q2 + 1)%r * p_max dout.
proof.
have ->: 
  Pr[CR_ROM_x2(FullRO1.RO, FullRO2.RO, A).main() @ &m : res]
  =
  Pr[CR_ROM_x2_Eager1_RS_V.main() @ &m : res].
+ byequiv (: ={glob A} ==> _) => //.
  transitivity CR_ROM_x2_I_RS(LRO).main
               (={glob A} ==> ={res})
               (={glob A} ==> ={res}) => //.
  smt().
  apply Eqv_CRROMx2RORS_ILRO.
  transitivity CR_ROM_x2_I_RS(RO).main
               (={glob A} ==> ={res})
               (={glob A} ==> ={res}) => //.
  smt().
  apply Eqv_CRROMx2RS_Main_LRO_RO.
  transitivity CR_ROM_x2_Eager1_RS.main
               (={glob A} ==> ={res})
               (={glob A} ==> ={res}) => //.
  smt().
  apply Eqv_CRROMx2RO_ILROT_RS.
  by apply Eqv_CRROMx2Eager1_V_RS.      
rewrite fromintD RField.mulrDl /=.
byphoare => //.
proc.
seq 1 : (    CR_ROM_x2_Eager1_RS_V.x1 \in FullRO1.RO.m 
          /\ CR_ROM_x2_Eager1_RS_V.x2 \in FullRO2.RO.m 
          /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_RS_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_RS_V.x2]) 
        ((q1 * q2)%r * p_max dout) 
        1%r 
        1%r 
        (p_max dout) => //.
call (: true ==>
        (CR_ROM_x2_Eager1_RS_V.x1 \in FullRO1.RO.m) /\
        (CR_ROM_x2_Eager1_RS_V.x2 \in FullRO2.RO.m) /\
        FullRO1.RO.m.[CR_ROM_x2_Eager1_RS_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_RS_V.x2]) => //.
+ bypr. 
  progress.
  have ->:
  Pr[CR_ROM_x2_Eager1_RS_V.cr() @ &m0 :
   (CR_ROM_x2_Eager1_RS_V.x1 \in FullRO1.RO.m) /\
   (CR_ROM_x2_Eager1_RS_V.x2 \in FullRO2.RO.m) /\
   FullRO1.RO.m.[CR_ROM_x2_Eager1_RS_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_RS_V.x2]]
  = 
  Pr[CR_ROM_x2_Eager1_RS_V.cr() @ &m0 : 
         fsize FullRO2.RO.m <= q2
      /\ CR_ROM_x2_Eager1_RS_V.x1 \in FullRO1.RO.m 
      /\ CR_ROM_x2_Eager1_RS_V.x2 \in FullRO2.RO.m 
      /\ FullRO1.RO.m.[CR_ROM_x2_Eager1_RS_V.x1] = FullRO2.RO.m.[CR_ROM_x2_Eager1_RS_V.x2]].
  byequiv=> //.
  proc.
  call (: ={glob A, glob RO1_Eager, glob FullRO2.RO} /\ FullRO2.RO.m{2} = empty
          ==>
          fsize FullRO2.RO.m{2} <= q2 /\ ={res, glob RO1_Eager, glob FullRO2.RO}).
  conseq (: ={glob A, glob RO1_Eager, glob FullRO2.RO} ==> ={res, glob RO1_Eager, glob FullRO2.RO}) _ A_RO2_qs => //.
  + smt(fsize_empty). 
  proc (={glob RO1_Eager, glob FullRO2.RO}) => //.
  proc.
  wp. skip => />.
  proc. wp; rnd ; skip => />. 
  inline.
  wp.
  while (={RO1_Eager.mi}). auto.
  auto.  
  by apply (Bnd_CRROMx2Eager1V_CR_RS &m0).  
if => //; swap 1 1; if => //; swap 1 1. 
+ rnd; rnd. 
skip => />. 
progress.
rewrite (mu_eq _ _ (pred1 y10)) 1:/#.
smt(pmax_upper_bound).
wp; rnd.
skip => />. 
progress.
rewrite (mu_eq _ _ (pred1 (oget FullRO2.RO.m{hr}.[CR_ROM_x2_Eager1_RS_V.x2{hr}]))) 1:/#.
smt(pmax_upper_bound).
rnd; wp.
skip => />. 
progress.
rewrite (mu_eq _ _ (pred1 (oget FullRO1.RO.m{hr}.[CR_ROM_x2_Eager1_RS_V.x1{hr}]))) 1:/#.
smt(pmax_upper_bound).
wp.
conseq (: _ ==> false). smt().
hoare; trivial => />.
smt(pmax_ge0).
qed.

end section.




(* 
  Now, consider a variant of the "Double ROM" CR property 
  where the adversary is only asked to produce a *single* input x 
  such that x maps (under the first random oracle) to the
  same output as another input x' (derived from x) does (under the
  second random oracle). Here, the deriviation may be anything, i.e.,
  x' = f(x) for some arbitrary f.
  
  This is an abstraction for the binding properties where the binding sources,
  or mappings thereof, are used as input to the random oracle.
  Even more abstractly, we might consider an injective function h
  such that h x, given to the first random oracle, must collide with 
  f x, given to the second random oracle. (Indeed, the situation without such 
  an injective h is actually a special case where h is the identity function)
  
  Then, the appraoch is:
  - Eagerly sample the random oracle that is given (as input) the output of the
    non-injective function.
  - Use fel over the oracle call that is given (as input) the output of the
    injective function:
    > In each iteration, the upperbound on a collision is p_max dout because
      the input query to the random oracle (taking injective input) has at most
      one preimage x, for which it must collide with the other random oracle on
      f x.
*)
