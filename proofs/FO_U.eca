require import AllCore Distr.
require HashFunctions PublicKeyEncryption KeyEncapsulationMechanisms.



(* Types *)
(** Public keys (asymmetric) **)
type pk_t.

(** Secret keys (asymmetric) **)
type sk_t.

(** Plaintexts **)
type ptxt_t.

(** Ciphertexts/Encapsulations **)
type ctxt_t.

(** (Shared) Symmetric keys **)
type key_t. 

(* Distributions *)
op dptxtm : pk_t -> ptxt_t distr.

(* Instantiate and import definitions for PKE schemes (shared by all variants) *)   
clone import PublicKeyEncryption as PKE with
  type pk_t <- pk_t,
  type sk_t <- sk_t,
  type ptxt_t <- ptxt_t,
  type ctxt_t <- ctxt_t
  
  proof *. 

  
(** FO U tranform that hashes both message and ciphertext. **)
abstract theory Umc.
(* Operators *)
(** Hash function to compute shared keys **)
op h : ptxt_t * ctxt_t -> key_t.

(* Instantiate and import definitions for hash functions *)
clone import HashFunctions as H with
  type in_t <- ptxt_t * ctxt_t,
  type out_t <- key_t,
  
  op f <- h
  
  proof *.
  
 
(** Explicit rejection variant of the FO U tranform that hashes both message and ciphertext **)
theory Explicit.
(* Instantiate and import definitions for KEMs *)
clone import KeyEncapsulationMechanisms as KEM with
  type pk_t <- pk_t,
  type sk_t <- sk_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t
  
  proof *.

  
(** Transformation U, hashing both message and ciphertext, with explicit rejection **)
module Umc_Explicit (S : PKE.Scheme) : KEM.Scheme = {
  proc keygen = S.keygen
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p : ptxt_t;
    var c : ctxt_t;
    var k : key_t;
    
    p <$ dptxtm pk;
    
    c <@ S.enc(pk, p);
    
    k <- h (p, c);
    
    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = { 
    var po : ptxt_t option;
    var k : key_t;
    var ko : key_t option;
    
    po <@ S.dec(sk, c);
    
    ko <- if po = None then None else Some (h ((oget po), c)); 
    
    return ko; 
  }  
}.


(*
Properties:
> X-BIND-K-CT break gives CR break: 
  Different ct, which is input to h, but equal k, which is output of h.
> HON-BIND-K-PK break gives SROB-CCA or CR break: 
  Equal non-None k means equal outcome of hash, so if c are different (input of hash), then CR break;
  else, c are equal, and since k are non-None (and PK are different), c breaks SROB-CCA.
> HON-BIND-K-PK break gives SCFR-CCA or (one of two) CR break: 
  Equal non-None k means equal outcome of hash, so if c are different (input of hash), then CR break;
  else, c are equal, but if p are unequal, then another CR break; else, c and p are equal, and 
  p are non-None, so SCFR-CCA.
> LEAK-BIND-K-PK break gives SROB-LEAK or CR break: 
  Same as HON case.
> LEAK-BIND-K-PK break gives SCFR-LEAK or (one of two) CR break: 
  Same as HON case.
> HON-BIND-CT-K break gives SROB-CCA break:
  If adversary chooses "equal key pair", then advantage equals 0, because decryption is deterministic
  (so the dec calls give equal p and c are equal --> equal input to h --> equal k --> fail).
  Else, adversary chooses "independently generated key pair", and c are equal and k are non-None,
  we get break of SROB-CCA.
> LEAK-BIND-CT-K break gives SROB-LEAK break:
  Same as HON case.
> HON-BIND-CT-PK break gives SROB-CCA break:
  non-None k and equal c means decryption of c with both sk gives non-None p and --> SROB-CCA break.
> LEAK-BIND-CT-PK break gives SROB-LEAK break:
  Same as HON case.
> HON-BIND-K,CT-PK break gives SCFR-CCA break or CR break:
  Equal non-None k and equal c means decryption of c with both sk gives non-None p and 
  and hashing these p (with c) gives the equal k. So, if these p are unequal --> collision;
  if these p are equal --> SCFR-CCA break.
> LEAK-BIND-K,CT-PK break gives SCFR-LEAK break or CR break:
  Same as HON case.
> X-BIND-K,PK-CT break gives CR break:
  Follows from X-BIND-K-CT break gives CR break. 
*)

(* LEAK-BIND-K-CT break for Umc-Explicit gives CR break for h *)
(** Reduction adversary reducing CR (for h) to LEAK-BIND-K-CT (for Umc-Explicit) **)
module R_CR_HONBINDKCT (S : PKE.Scheme) (O0 : Oracles_CCA1i, O1 : Oracles_CCA1i) (A : Adv_HONBIND) : Adv_CR = {
  proc find() = {
    var pk0, pk1 : pk_t;
    var sk0, sk1 : sk_t;
    var p0, p1 : ptxt_t option;
    var b : bool;
    var c0, c1 : ctxt_t;
    
    (pk0, sk0) <@ Umc_Explicit(S).keygen();
    b <@ A(O0(Umc_Explicit(S)), O1(Umc_Explicit(S))).choose(K_Binds_CT);
    if (b) { 
      (pk1, sk1) <@ S.keygen();
    } else {
      (pk1, sk1) <- (pk0, sk0);
    }
         
    O0(Umc_Explicit(S)).init(sk0);
    O1(Umc_Explicit(S)).init(sk1);
    
    (c0, c1) <@ A(O0(Umc_Explicit(S)), O1(Umc_Explicit(S))).find(K_Binds_CT, pk0, pk1);
    
    p0 <@ S.dec(sk0, c0);
    p1 <@ S.dec(sk1, c1);
    
    return ((oget p0, c0), (oget p1, c1));
  }
}.


  
end Explicit.


(** Implicit rejection variant of the FO U tranform that hashes both message and ciphertext **)
theory Implicit.
(* Instantiate and import definitions for KEMs *)
clone import KeyEncapsulationMechanisms as KEM with
  type pk_t <- pk_t,
  type sk_t <- sk_t * ptxt_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t
  
  proof *.

(* Scheme/transform *)
(** Transformation U, hashing both message and ciphertext, with implicit rejection **)
module Umc_Implicit (S : PKE.Scheme) : KEM.Scheme = {
  proc keygen() : pk_t * (sk_t * ptxt_t) = {
    var pk : pk_t;
    var sk : sk_t;
    var s : ptxt_t;
    
    (pk, sk) <@ S.keygen();
    
    s <$ dptxtm pk;
    
    return (pk, (sk, s));
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p : ptxt_t;
    var c : ctxt_t;
    var k : key_t;
    
    p <$ dptxtm pk;
    
    c <@ S.enc(pk, p);
    
    k <- h (p, c);
    
    return (k, c);
  }
  
  proc decaps(sks : sk_t * ptxt_t, c : ctxt_t) : key_t option = { 
    var sk : sk_t;
    var s : ptxt_t;
    var po : ptxt_t option;
    var k : key_t;
    var ko : key_t option;
    
    (sk, s) <- sks;
    
    po <@ S.dec(sk, c);
    
    ko <- if po = None then Some (h (s, c)) else Some (h ((oget po), c)); 
    
    return ko; 
  }  
}.
  
(*
Properties:
> X-BIND-K-CT break gives CR break: 
  Different ct, which is input to h, but equal k, which is output of h.
> HON-BIND-K-PK break gives SROB-CCA or (one of two) CR break (unless equal s or s equals po): 
  Equal k means equal outcome of hash, so if c are different (input of hash), then CR break. 
  Else (c are equal), if po0 or po1 is none, then CR break unless equal s or s equal to po.
  Else (c are equal and po are non-None), SROB-CCA break. 
> HON-BIND-K-PK break gives SCFR-CCA or (one of multiple) CR break (unless equal s or s equals po): 
  Same as SROB-CCA case, but split "po are non-None" further into "equal po" and "unequal po";
  in the former SCFR-CCA break, in the latter CR break.  
> LEAK-BIND-K-PK break gives SROB-LEAK or CR break: 
  Same as HON case.
> LEAK-BIND-K-PK break gives SCFR-LEAK or (one of two) CR break: 
  Same as HON case.
> HON-BIND-K,CT-PK break gives SCFR-CCA break or CR break:
  Same as HON-BIND-K-PK, but collision can only come from s/po being unequal (instead of also from
  c being unequal).
> LEAK-BIND-K,CT-PK break gives SCFR-LEAK break or CR break:
  Same as HON case.
> X-BIND-K,PK-CT break gives CR break:
  Follows from X-BIND-K-CT break gives CR break. 
*)

  
end Implicit.


end Umc.


(** FO U tranform, hashing only the message **)  
theory Um.
(** Explicit rejection variant of the FO U tranform that hashes only the message **)
abstract theory Explicit.
(* Operators *)
(** Hash function to compute shared keys **)
op h : ptxt_t -> key_t.

(* Instantiate and import definitions for hash functions *)
clone import HashFunctions as H with
  type in_t <- ptxt_t,
  type out_t <- key_t,
  
  op f <- h
  
  proof *.
  
(* Instantiate and import definitions for KEMs *)
clone import KeyEncapsulationMechanisms as KEM with
  type pk_t <- pk_t,
  type sk_t <- sk_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t
  
  proof *.

  
(** Transformation U, hashing both message and ciphertext, with explicit rejection **)
module Um_Explicit (S : PKE.Scheme) : KEM.Scheme = {
  proc keygen = S.keygen
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p : ptxt_t;
    var c : ctxt_t;
    var k : key_t;
    
    p <$ dptxtm pk;
    
    c <@ S.enc(pk, p);
    
    k <- h p;
    
    return (k, c);
  }
  
  proc decaps(sk : sk_t, c : ctxt_t) : key_t option = { 
    var po : ptxt_t option;
    var k : key_t;
    var ko : key_t option;
    
    po <@ S.dec(sk, c);
    
    ko <- if po = None then None else Some (h (oget po)); 
    
    return ko; 
  }  
}.


(*
Properties:
> X-BIND-K-CT --> ?
> HON-BIND-K-PK --> ?
> LEAK-BIND-K-PK --> ?
> HON-BIND-CT-K break gives SROB-CCA break:
  If adversary chooses "equal key pair", then advantage equals 0, because decryption is deterministic
  (so the dec calls give equal p and c are equal --> equal input to h --> equal k --> fail).
  Else, adversary chooses "independently generated key pair", and c are equal and k are non-None,
  we get break of SROB-CCA.
> LEAK-BIND-CT-K break gives SROB-LEAK break:
  Same as HON case.
> HON-BIND-CT-PK break gives SROB-CCA break:
  non-None k and equal c means decryption of c with both sk gives non-None p --> SROB-CCA break.
> LEAK-BIND-CT-PK break gives SROB-LEAK break:
  Same as HON case.
> HON-BIND-K,CT-PK break gives SCFR-CCA break or CR break:
  Equal non-None k and equal c means decryption of c with both sk gives non-None p and 
  and hashing these p gives equal k. So, if these p are unequal --> collision;
  if these p are equal --> SCFR-CCA break.
> LEAK-BIND-K,CT-PK break gives SCFR-LEAK break or CR break:
  Same as HON case.
> X-BIND-K,PK-CT --> ?
*)

  
end Explicit.


(** Implicit rejection variant of the FO U tranform that hashes only the message **)
abstract theory Implicit.
(* Types *)
(** Inputs (to hash function) **)
(** 
  In this case, the (same) hash function may be given inputs of different types
  (specifically: only a message in case of acceptance, a message and a ciphertext in case of rejection), 
  meaning we need a way to combine both input.
  Here, we achieve this by means of a separate input type and operators mapping the different types
  that are actually used as input to this type.  
**)
type in_t.

(* Operators *)
(** Hash function to compute shared keys **)
op h : in_t -> key_t.

(** Operator mapping plaintexts to the input type of the hash function **)
(** 
  Concretely, this will most likely be instantiated with simple lifings/casts 
  (e.g., from fixed-length bitstrings to arbitrary-length bitstrings) 
**)
op p2in : ptxt_t -> in_t.

(** Operator mapping (pairs of) plaintexts and ciphertexts to the input type of the hash function **)
(** 
  Concretely, this will most likely be instantiated with simple lifings/casts 
  (e.g., from pairs of fixed-length bitstrings to arbitrary-length bitstrings) 
**)
op pc2in : ptxt_t * ctxt_t -> in_t.


(* Instantiate and import definitions for hash functions *)
clone import HashFunctions as H with
  type in_t <- in_t,
  type out_t <- key_t,
  
  op f <- h
  
  proof *.
  
(* Instantiate and import definitions for KEMs *)
clone import KeyEncapsulationMechanisms as KEM with
  type pk_t <- pk_t,
  type sk_t <- sk_t * ptxt_t,
  type key_t <- key_t,
  type ctxt_t <- ctxt_t
  
  proof *.

(* Scheme/transform *)
(** Transformation U, hashing only the message, with implicit rejection **)
module Um_Implicit (S : PKE.Scheme) : KEM.Scheme = {
  proc keygen() : pk_t * (sk_t * ptxt_t) = {
    var pk : pk_t;
    var sk : sk_t;
    var s : ptxt_t;
    
    (pk, sk) <@ S.keygen();
    
    s <$ dptxtm pk;
    
    return (pk, (sk, s));
  }
  
  proc encaps(pk : pk_t) : key_t * ctxt_t = {
    var p : ptxt_t;
    var c : ctxt_t;
    var k : key_t;
    
    p <$ dptxtm pk;
    
    c <@ S.enc(pk, p);
    
    k <- h (p2in p);
    
    return (k, c);
  }
  
  proc decaps(sks : sk_t * ptxt_t, c : ctxt_t) : key_t option = { 
    var sk : sk_t;
    var s : ptxt_t;
    var po : ptxt_t option;
    var k : key_t;
    var ko : key_t option;
    
    (sk, s) <- sks;
    
    po <@ S.dec(sk, c);
    
    ko <- if po = None then Some (h (pc2in (s, c))) else Some (h (pc2in ((oget po), c))); 
    
    return ko; 
  }  
}.
 
end Implicit.


end Um.




(*
module R_CR_HONBINDKCT (S : PKE.Scheme) (O0 : Oracles_CCA1i, O1 : Oracles_CCA1i) (A : Adv_HONBIND) : Adv_CR = {
  proc find() = {
    var pk0 : pk_t;
    var pk1 : pk_t;
    var sk0 : sk_t;
    var sk1 : sk_t;
    var p0, p1 : ptxt_t option;
    var b : bool;
    var c0 : ctxt_t;
    var c1 : ctxt_t;
    var k0 : key_t option;
    var k1 : key_t option;
    var no_fail : bool;
    
    (pk0, sk0) <@ FO_Umc_Explicit(S).keygen();
    b <@ A(O0(FO_Umc_Explicit(S)), O1(FO_Umc_Explicit(S))).choose(K_Binds_CT);
    if (b) { 
      (pk1, sk1) <@ S.keygen();
    } else {
      (pk1, sk1) <- (pk0, sk0);
    }
         
    O0( FO_Umc_Explicit(S)).init(sk0);
    O1( FO_Umc_Explicit(S)).init(sk1);
    
    (c0, c1) <@ A(O0(FO_Umc_Explicit(S)), O1(FO_Umc_Explicit(S))).find(K_Binds_CT, pk0, pk1);
    
    p0 <@ S.dec(sk0, c0);
    p1 <@ S.dec(sk1, c1);
    
    return ((oget p0, c0), (oget p1, c1));
  }
}.



section.

declare module S <: PKE.Scheme{-O_CCA1_Default, -O_CCA1_DDefault}.

declare module A <: Adv_HONBIND{-S, -O_CCA1_Default, -O_CCA1_DDefault}. 

lemma test &m :
  Pr[HON_BIND(FO_Umc_Explicit(S), KEM.O_CCA1_Default, KEM.O_CCA1_DDefault, A).main(K_Binds_CT) @ &m : res]
  <=
  Pr[CR(R_CR_HONBINDKCT(S, KEM.O_CCA1_Default, KEM.O_CCA1_DDefault, A)).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{2} 1.
seq 1 1 : (={glob A, glob S, pk0, sk0} /\ bc{1} = K_Binds_CT); 1: by call (: true).
do 2! (rcondf{1} ^if; 1: auto).
inline{1} FO_Umc_Explicit(S).decaps. 
wp; call (: true); wp; call (: true); wp. 
conseq (: _ ==> ={c0, c1, glob S, sk1}); 1: smt().
call (: ={glob O_CCA1_Default, glob O_CCA1_DDefault, glob S}); 1..2: by sim.  
conseq />.
seq 1 1 : (#pre /\ ={b}); 1: by call (: true).
by sim.
qed.

end section.


print PKE.SROB_CCA.

module (R_SROBCCA_HONBINDCTPK (S : PKE.Scheme) (A : Adv_HONBIND) : Adv_SROBCCA) (O0 : Oracles_CCA, O1 : Oracles_CCA) = {
  proc find(pk0 : pk_t, pk1 : pk_t) = {
    var pk0 : pk_t;
    var pk1 : pk_t;
    var sk0 : sk_t;
    var sk1 : sk_t;
    var p0, p1 : ptxt_t option;
    var b : bool;
    var c0 : ctxt_t;
    var c1 : ctxt_t;
    var k0 : key_t option;
    var k1 : key_t option;
    var no_fail : bool;
    
    (pk0, sk0) <@ FO_Umc_Explicit(S).keygen();
    b <@ A(O0(FO_Umc_Explicit(S)), O1(FO_Umc_Explicit(S))).choose(K_Binds_CT);
    if (b) { 
      (pk1, sk1) <@ S.keygen();
    } else {
      (pk1, sk1) <- (pk0, sk0);
    }
         
    O0( FO_Umc_Explicit(S)).init(sk0);
    O1( FO_Umc_Explicit(S)).init(sk1);
    
    (c0, c1) <@ A(O0(FO_Umc_Explicit(S)), O1(FO_Umc_Explicit(S))).find(K_Binds_CT, pk0, pk1);
    
    p0 <@ S.dec(sk0, c0);
    p1 <@ S.dec(sk1, c1);
    
    return ((oget p0, c0), (oget p1, c1));
  }
}.



section.

declare module S <: PKE.Scheme{-O_CCA1_Default, -O_CCA1_DDefault}.

declare module A <: Adv_HONBIND{-S, -O_CCA1_Default, -O_CCA1_DDefault}. 

lemma test &m :
  Pr[HON_BIND(FO_Umc_Explicit(S), KEM.O_CCA1_Default, KEM.O_CCA1_DDefault, A).main(K_Binds_CT) @ &m : res]
  <=
  Pr[CR(R_CR_HONBINDKCT(S, KEM.O_CCA1_Default, KEM.O_CCA1_DDefault, A)).main() @ &m : res].
proof.
byequiv => //.
proc.
inline{2} 1.
seq 1 1 : (={glob A, glob S, pk0, sk0} /\ bc{1} = K_Binds_CT); 1: by call (: true).
do 2! (rcondf{1} ^if; 1: auto).
inline{1} FO_Umc_Explicit(S).decaps. 
wp; call (: true); wp; call (: true); wp. 
conseq (: _ ==> ={c0, c1, glob S, sk1}); 1: smt().
call (: ={glob O_CCA1_Default, glob O_CCA1_DDefault, glob S}); 1..2: by sim.  
conseq />.
seq 1 1 : (#pre /\ ={b}); 1: by call (: true).
by sim.
qed.

end section.
*)
